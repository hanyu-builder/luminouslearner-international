<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unit Cell Viewer</title>
    
    <!-- React & Tailwind -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #0F172A; color: #e2e8f0; margin: 0; overflow: hidden; }
        .font-mono { font-family: 'JetBrains Mono', monospace; }
        canvas { outline: none; }
        
        /* Custom Scrollbar */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #1e293b; }
        ::-webkit-scrollbar-thumb { background: #475569; border-radius: 3px; }
        
        /* Slider */
        input[type=range] { -webkit-appearance: none; width: 100%; background: transparent; }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; height: 16px; width: 16px; border-radius: 50%; 
            background: #10B981; cursor: pointer; margin-top: -6px; 
            box-shadow: 0 0 8px rgba(16, 185, 129, 0.5);
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%; height: 4px; cursor: pointer; background: #334155; border-radius: 2px;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // --- SAFE ICON COMPONENT ---
        const Icon = ({ name, className = "", size = 20 }) => {
            const [svgHtml, setSvgHtml] = useState('');
            useEffect(() => {
                if (window.lucide && window.lucide.icons) {
                    const pascalName = name.split('-').map(part => part.charAt(0).toUpperCase() + part.slice(1)).join('');
                    const iconData = window.lucide.icons[pascalName];
                    if (iconData && typeof window.lucide.createElement === 'function') {
                        const svgElement = window.lucide.createElement(iconData);
                        svgElement.setAttribute('class', className);
                        svgElement.setAttribute('width', size);
                        svgElement.setAttribute('height', size);
                        setSvgHtml(svgElement.outerHTML);
                    }
                }
            }, [name, className, size]);
            if (!svgHtml) return <span className={className} style={{ width: size, height: size, display: 'inline-block' }}></span>;
            return <span dangerouslySetInnerHTML={{ __html: svgHtml }} className="flex items-center justify-center" />;
        };

        // --- UNIT CELL DATA (Translated) ---
        const CELLS = {
            sc: {
                name: 'Simple Cubic (SC)',
                cn: 6,
                atomsPerCell: 1,
                packing: '52.4%',
                desc: 'Atoms are located only at the corners of the cube. This structure has the lowest packing efficiency.',
                radiusRatio: 0.5, // r = a/2
                color: 0x60A5FA // Blue
            },
            bcc: {
                name: 'Body-Centered Cubic (BCC)',
                cn: 8,
                atomsPerCell: 2,
                packing: '68.0%',
                desc: 'Atoms at the corners plus one full atom in the very center. Common in Group 1 metals.',
                radiusRatio: 0.433, // r = (sqrt(3)/4)a
                color: 0x34D399 // Green
            },
            fcc: {
                name: 'Face-Centered Cubic (FCC)',
                cn: 12,
                atomsPerCell: 4,
                packing: '74.0%',
                desc: 'Atoms at corners plus one atom at the center of each face. Also known as Cubic Close Packed (CCP).',
                radiusRatio: 0.354, // r = (sqrt(2)/4)a
                color: 0xF472B6 // Pink
            }
        };

        // --- 3D VIEWER ---
        const UnitCellScene = ({ type, radiusScale, showRepeat, showCut }) => {
            const mountRef = useRef(null);
            
            useEffect(() => {
                if (!mountRef.current) return;

                // 1. Scene Setup
                const width = mountRef.current.clientWidth;
                const height = mountRef.current.clientHeight;
                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0x0F172A); // Dark background

                const camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 100);
                camera.position.set(4, 3, 5);

                const renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(width, height);
                mountRef.current.appendChild(renderer.domElement);

                const controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;

                // Lights
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                scene.add(ambientLight);
                const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
                dirLight.position.set(5, 10, 7);
                scene.add(dirLight);

                // --- BUILD ATOMS ---
                const group = new THREE.Group();
                const cellData = CELLS[type];
                const baseColor = cellData.color;
                const atomGeo = new THREE.SphereGeometry(1, 32, 32);
                const atomMat = new THREE.MeshPhysicalMaterial({ 
                    color: baseColor, metalness: 0.1, roughness: 0.3, clearcoat: 1.0 
                });
                
                // Box Helper (Wireframe)
                const boxSize = 2;
                
                // Helper to add atom
                const addAtom = (x, y, z, scale) => {
                    const mesh = new THREE.Mesh(atomGeo, atomMat);
                    mesh.position.set(x, y, z);
                    mesh.scale.setScalar(scale);
                    group.add(mesh);
                };

                // Determine atom radius
                const maxR = cellData.radiusRatio * boxSize; 
                const r = maxR * radiusScale;

                // Generate Positions
                const positions = [];
                const layers = showRepeat ? 2 : 1;

                for (let i = 0; i < layers; i++) {
                    for (let j = 0; j < layers; j++) {
                        for (let k = 0; k < layers; k++) {
                            const offsetX = i * boxSize;
                            const offsetY = j * boxSize;
                            const offsetZ = k * boxSize;

                            // Draw Box Wireframe for each cell
                            const boxGeo = new THREE.BoxGeometry(boxSize, boxSize, boxSize);
                            const edges = new THREE.EdgesGeometry(boxGeo);
                            const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x475569 }));
                            line.position.set(offsetX, offsetY, offsetZ);
                            group.add(line);

                            // Corners (All types have corners)
                            const corners = [
                                [-0.5, -0.5, -0.5], [0.5, -0.5, -0.5], [-0.5, 0.5, -0.5], [0.5, 0.5, -0.5],
                                [-0.5, -0.5, 0.5], [0.5, -0.5, 0.5], [-0.5, 0.5, 0.5], [0.5, 0.5, 0.5]
                            ];
                            corners.forEach(pos => positions.push([pos[0]*boxSize + offsetX, pos[1]*boxSize + offsetY, pos[2]*boxSize + offsetZ]));

                            // Body Center (BCC only)
                            if (type === 'bcc') {
                                positions.push([offsetX, offsetY, offsetZ]);
                            }

                            // Face Centers (FCC only)
                            if (type === 'fcc') {
                                const faces = [
                                    [0, 0, 0.5], [0, 0, -0.5], [0, 0.5, 0], [0, -0.5, 0], [0.5, 0, 0], [-0.5, 0, 0]
                                ];
                                faces.forEach(pos => positions.push([pos[0]*boxSize + offsetX, pos[1]*boxSize + offsetY, pos[2]*boxSize + offsetZ]));
                            }
                        }
                    }
                }

                // Filter Duplicates (Shared atoms)
                const uniquePos = [];
                positions.forEach(p => {
                    // Check if already exists (approx)
                    const exists = uniquePos.some(up => 
                        Math.abs(up[0]-p[0]) < 0.01 && Math.abs(up[1]-p[1]) < 0.01 && Math.abs(up[2]-p[2]) < 0.01
                    );
                    if (!exists) uniquePos.push(p);
                });

                // Add Atoms to Scene
                uniquePos.forEach(pos => {
                    addAtom(pos[0], pos[1], pos[2], r);
                });
                
                // Center the group
                const centerOffset = showRepeat ? -boxSize/2 : 0;
                group.position.set(centerOffset, centerOffset, centerOffset);
                
                scene.add(group);

                // Animation Loop
                let frameId;
                const animate = () => {
                    frameId = requestAnimationFrame(animate);
                    controls.update();
                    renderer.render(scene, camera);
                };
                animate();

                // Cleanup
                return () => {
                    cancelAnimationFrame(frameId);
                    if (mountRef.current && renderer.domElement) {
                        mountRef.current.removeChild(renderer.domElement);
                    }
                    // Dispose
                    atomGeo.dispose();
                    atomMat.dispose();
                };
            }, [type, radiusScale, showRepeat, showCut]);

            return <div ref={mountRef} className="w-full h-full" />;
        };

        const App = () => {
            const [type, setType] = useState('sc');
            const [radiusScale, setRadiusScale] = useState(0.4); // 0.1 to 1.0
            const [showRepeat, setShowRepeat] = useState(false);
            
            const current = CELLS[type];

            return (
                <div className="min-h-screen bg-[#0F172A] text-white flex flex-col md:flex-row overflow-hidden">
                    
                    {/* Sidebar */}
                    <div className="w-full md:w-80 bg-slate-900 border-r border-slate-800 flex flex-col z-10 shadow-xl h-screen shrink-0">
                        <div className="p-6 border-b border-slate-800">
                            <h1 className="text-xl font-bold flex items-center gap-2">
                                <Icon name="box" className="text-emerald-400" /> Unit Cell Viewer
                            </h1>
                            <p className="text-xs text-slate-400 mt-1">Crystal Lattice Structure</p>
                        </div>

                        <div className="p-4 space-y-2 flex-1 overflow-y-auto">
                            <label className="text-xs font-bold text-slate-500 uppercase tracking-widest px-2 mb-2 block">Select Type</label>
                            {Object.entries(CELLS).map(([key, cell]) => (
                                <button 
                                    key={key}
                                    onClick={() => setType(key)}
                                    className={`w-full text-left p-4 rounded-xl border transition-all relative overflow-hidden group
                                        ${type === key 
                                            ? 'bg-slate-800 border-emerald-500 ring-1 ring-emerald-500/50' 
                                            : 'bg-slate-900/50 border-slate-700 hover:bg-slate-800'}
                                    `}
                                >
                                    <div className="relative z-10">
                                        <div className={`font-bold ${type === key ? 'text-white' : 'text-slate-300'}`}>
                                            {cell.name.split(' (')[0]}
                                        </div>
                                        <div className="text-xs text-slate-500">{cell.name.split(' (')[1]?.replace(')', '')}</div>
                                    </div>
                                    {type === key && <div className="absolute right-0 top-0 bottom-0 w-1 bg-emerald-500"></div>}
                                </button>
                            ))}

                            {/* Controls */}
                            <div className="mt-8 pt-6 border-t border-slate-800">
                                <label className="text-xs font-bold text-slate-500 uppercase tracking-widest px-2 mb-4 block">View Options</label>
                                
                                {/* Radius Slider */}
                                <div className="px-2 mb-6">
                                    <div className="flex justify-between text-xs text-slate-300 mb-2">
                                        <span>Atom Size</span>
                                        <span>{Math.round(radiusScale * 100)}%</span>
                                    </div>
                                    <input 
                                        type="range" min="0.2" max="1.0" step="0.01"
                                        value={radiusScale}
                                        onChange={(e) => setRadiusScale(parseFloat(e.target.value))}
                                    />
                                    <div className="flex justify-between text-[10px] text-slate-500 mt-1">
                                        <span>Small</span>
                                        <span>Close Packed</span>
                                    </div>
                                </div>

                                {/* Repeat Toggle */}
                                <button 
                                    onClick={() => setShowRepeat(!showRepeat)}
                                    className={`w-full p-3 rounded-xl border text-sm font-bold flex items-center justify-between transition-all
                                        ${showRepeat ? 'bg-blue-900/30 border-blue-500 text-blue-300' : 'bg-slate-800 border-slate-700 text-slate-400'}
                                    `}
                                >
                                    <span>Show Lattice (2x2x2)</span>
                                    <div className={`w-10 h-5 rounded-full relative transition-colors ${showRepeat ? 'bg-blue-500' : 'bg-slate-600'}`}>
                                        <div className={`absolute top-1 w-3 h-3 bg-white rounded-full transition-transform ${showRepeat ? 'left-6' : 'left-1'}`}></div>
                                    </div>
                                </button>
                            </div>
                        </div>
                    </div>

                    {/* Main Stage */}
                    <div className="flex-1 relative flex flex-col h-screen">
                        
                        {/* 3D Canvas */}
                        <div className="flex-1 bg-slate-900/50 relative">
                            <div className="absolute inset-0 opacity-10 pointer-events-none" 
                                style={{backgroundImage: 'radial-gradient(#334155 1px, transparent 1px)', backgroundSize: '20px 20px'}}>
                            </div>
                            <UnitCellScene type={type} radiusScale={radiusScale} showRepeat={showRepeat} showCut={false} />
                            
                            <div className="absolute top-6 left-6 z-10 pointer-events-none">
                                <h2 className="text-4xl font-black text-white drop-shadow-lg opacity-90">{current.name.split(' (')[1]?.replace(')', '')}</h2>
                            </div>

                            <div className="absolute bottom-6 right-6 text-slate-600 text-xs pointer-events-none">
                                Click & Drag to Rotate â€¢ Scroll to Zoom
                            </div>
                        </div>

                        {/* Stats Panel */}
                        <div className="h-48 bg-slate-800 border-t border-slate-700 p-6 shrink-0 flex gap-6 overflow-x-auto safe-area-bottom">
                            
                            <div className="bg-slate-900/50 p-4 rounded-xl border border-slate-600 w-48 shrink-0 flex flex-col justify-center">
                                <div className="text-xs text-slate-500 font-bold uppercase mb-1">Coordination No.</div>
                                <div className="text-4xl font-mono font-black text-emerald-400">{current.cn}</div>
                                <div className="text-xs text-emerald-400/60 mt-1">Nearest Neighbors</div>
                            </div>

                            <div className="bg-slate-900/50 p-4 rounded-xl border border-slate-600 w-48 shrink-0 flex flex-col justify-center">
                                <div className="text-xs text-slate-500 font-bold uppercase mb-1">Atoms per Cell (Z)</div>
                                <div className="text-4xl font-mono font-black text-blue-400">{current.atomsPerCell}</div>
                                <div className="text-xs text-blue-400/60 mt-1">Effective Atoms</div>
                            </div>

                            <div className="bg-slate-900/50 p-4 rounded-xl border border-slate-600 w-48 shrink-0 flex flex-col justify-center">
                                <div className="text-xs text-slate-500 font-bold uppercase mb-1">Packing Efficiency</div>
                                <div className="text-4xl font-mono font-black text-purple-400">{current.packing}</div>
                                <div className="text-xs text-purple-400/60 mt-1">Space Occupied</div>
                            </div>

                            <div className="bg-slate-700/30 p-4 rounded-xl border border-slate-600/50 flex-1 min-w-[200px] flex flex-col justify-center">
                                <div className="text-xs text-slate-400 font-bold uppercase mb-2 flex items-center gap-2">
                                    <Icon name="info" size={14} /> Description
                                </div>
                                <p className="text-sm text-slate-300 leading-relaxed">
                                    {current.desc}
                                </p>
                            </div>

                        </div>
                    </div>

                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
