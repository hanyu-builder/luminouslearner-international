<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Carbon Allotrope Gallery - LuminousLearner International</title>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <!-- Load Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&family=JetBrains+Mono:wght@400;700&display=swap');
        body { font-family: 'Inter', sans-serif; background-color: #0F172A; color: #e2e8f0; }
        
        #canvas-container {
            width: 100%;
            height: 100%;
            overflow: hidden;
            outline: none;
            /* Dark gradient background for space-like feel */
            background: radial-gradient(circle at center, #1e293b 0%, #0f172a 100%);
        }
        canvas { outline: none; }
        
        .btn-active {
            background-color: #7c3aed; /* Violet-600 */
            border-color: #6d28d9;
            color: white;
            box-shadow: 0 0 15px rgba(124, 58, 237, 0.5);
        }
        .btn-inactive {
            background-color: #1e293b; /* Slate-800 */
            border-color: #334155;
            color: #94a3b8;
        }
        .btn-inactive:hover {
            background-color: #334155;
            color: white;
        }
    </style>
</head>
<body class="min-h-screen flex flex-col">

    <div id="root" class="flex-grow flex flex-col"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        const Icon = ({ name, size = 20, className = "" }) => {
            const [svg, setSvg] = useState('');
            useEffect(() => {
                if (window.lucide) {
                    const iconNode = window.lucide.icons[name];
                    if (iconNode) {
                        const iconSvg = window.lucide.createElement(iconNode);
                        iconSvg.setAttribute('width', size);
                        iconSvg.setAttribute('height', size);
                        iconSvg.setAttribute('class', className);
                        setSvg(iconSvg.outerHTML);
                    }
                }
            }, [name, size, className]);
            return <span dangerouslySetInnerHTML={{ __html: svg }} className="flex items-center" />;
        };

        const Structures = [
            { 
                id: 'Diamond', 
                name: 'Diamond', 
                category: '3D Giant Covalent', 
                desc: 'Each carbon atom is covalently bonded to 4 others in a tetrahedral arrangement. This rigid 3D network makes diamond extremely hard, with a high melting point and no electrical conductivity.',
                keyFeature: '3D Network Structure'
            },
            { 
                id: 'Graphite', 
                name: 'Graphite', 
                category: '2D Layered Giant Covalent', 
                desc: 'Carbon atoms are arranged in hexagonal rings forming flat layers. Strong covalent bonds exist within layers, but weak Van der Waals forces between layers allow them to slide. Contains delocalized electrons, so it conducts electricity.',
                keyFeature: 'Layered Structure'
            },
            { 
                id: 'Graphene', 
                name: 'Graphene', 
                category: '2D Giant Covalent', 
                desc: 'A single layer of graphite. Just one atom thick, arranged in a honeycomb lattice. It has incredible tensile strength, thermal conductivity, and electrical conductivity.',
                keyFeature: 'Single Atomic Layer'
            },
            { 
                id: 'Nanotube', 
                name: 'Carbon Nanotube', 
                category: '1D Nanostructure', 
                desc: 'A sheet of graphene rolled into a seamless cylinder. These have diameters on the nanometer scale but can be very long. Known for exceptional strength-to-weight ratio.',
                keyFeature: 'Tubular Structure'
            },
            { 
                id: 'C60', 
                name: 'Buckminsterfullerene (C60)', 
                category: '0D Simple Molecular', 
                desc: 'A spherical molecule made of 60 carbon atoms arranged in 12 pentagons and 20 hexagons, resembling a soccer ball. It is a simple molecule, not a giant lattice.',
                keyFeature: 'Spherical Molecule'
            }
        ];

        const ThreeScene = ({ structureId }) => {
            const mountRef = useRef(null);
            const sceneRef = useRef(null);
            const controlsRef = useRef(null);
            const rendererRef = useRef(null);

            useEffect(() => {
                // Setup
                const scene = new THREE.Scene();
                // Transparent background so CSS gradient shows through
                scene.background = null; 
                scene.fog = new THREE.Fog(0x0f172a, 10, 60);
                sceneRef.current = scene;

                const camera = new THREE.PerspectiveCamera(60, mountRef.current.clientWidth / mountRef.current.clientHeight, 0.1, 1000);
                camera.position.z = 18;

                const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                renderer.setSize(mountRef.current.clientWidth, mountRef.current.clientHeight);
                renderer.setPixelRatio(window.devicePixelRatio);
                mountRef.current.appendChild(renderer.domElement);
                rendererRef.current = renderer;

                // Lights
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
                scene.add(ambientLight);
                const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
                dirLight.position.set(10, 10, 10);
                scene.add(dirLight);
                const pointLight = new THREE.PointLight(0x8b5cf6, 0.8); // Violet tint
                pointLight.position.set(-10, -5, 5);
                scene.add(pointLight);

                // Controls
                const controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
                controls.autoRotate = true;
                controls.autoRotateSpeed = 0.8;
                controlsRef.current = controls;

                // Build Logic
                const buildStructure = (id) => {
                    while(scene.children.length > 0){ 
                        const obj = scene.children[0];
                        if (obj !== ambientLight && obj !== dirLight && obj !== pointLight) {
                            scene.remove(obj); 
                        } else {
                            // Keep lights, break loop manually if only lights left to avoid infinite loop logic error
                            // Better approach: remove specific group
                             scene.remove(obj); // Actually remove all and re-add lights is safer for clean slate
                        }
                    }
                    scene.add(ambientLight); scene.add(dirLight); scene.add(pointLight);

                    const group = new THREE.Group();
                    const matC = new THREE.MeshPhongMaterial({ color: 0x334155, shininess: 90, specular: 0x666666 }); 
                    const matBond = new THREE.MeshPhongMaterial({ color: 0x94a3b8 });
                    const geoAtom = new THREE.SphereGeometry(0.4, 24, 24);

                    const addAtom = (x, y, z) => {
                        const mesh = new THREE.Mesh(geoAtom, matC);
                        mesh.position.set(x, y, z);
                        group.add(mesh);
                        return mesh.position;
                    };

                    const addBond = (p1, p2) => {
                        const distance = p1.distanceTo(p2);
                        const cylinder = new THREE.CylinderGeometry(0.1, 0.1, distance, 8);
                        const mesh = new THREE.Mesh(cylinder, matBond);
                        mesh.position.copy(p1).lerp(p2, 0.5);
                        mesh.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), new THREE.Vector3().subVectors(p2, p1).normalize());
                        group.add(mesh);
                    };

                    if (id === 'Diamond') {
                        const points = [
                            [0,0,0], [1,1,1], [-1,-1,1], [-1,1,-1], [1,-1,-1],
                            [2,2,0], [2,0,2], [0,2,2], [-2,-2,0], [-2,0,-2], [0,-2,-2]
                        ];
                        const atomPos = points.map(p => addAtom(p[0]*1.5, p[1]*1.5, p[2]*1.5));
                        // Connect neighbors
                        for(let i=0; i<atomPos.length; i++) {
                            for(let j=i+1; j<atomPos.length; j++) {
                                if(atomPos[i].distanceTo(atomPos[j]) < 3.0) addBond(atomPos[i], atomPos[j]);
                            }
                        }

                    } else if (id === 'Graphite') {
                        // Two layers
                        [-2, 2].forEach(y => {
                            // Create hex grid
                            for(let r=-1; r<=1; r++) {
                                for(let c=-1; c<=1; c++) {
                                    const cx = c * 2.5 + (r%2)*1.25;
                                    const cz = r * 2.2;
                                    // Hexagon points
                                    for(let k=0; k<6; k++) {
                                        const ang = k * Math.PI/3;
                                        const px = cx + Math.cos(ang)*0.8;
                                        const pz = cz + Math.sin(ang)*0.8;
                                        
                                        // Simple check to avoid duplicates visually for this demo
                                        const p = new THREE.Vector3(px*1.5, y, pz*1.5);
                                        
                                        let exists = false;
                                        group.children.forEach(child => {
                                            if (child.geometry === geoAtom && child.position.distanceTo(p) < 0.5) exists = true;
                                        });
                                        
                                        if (!exists) {
                                            const mesh = new THREE.Mesh(geoAtom, matC);
                                            mesh.position.copy(p);
                                            group.add(mesh);
                                        }
                                    }
                                }
                            }
                        });
                        
                        // Connect bonds within layer
                         const atoms = group.children.filter(c => c.geometry === geoAtom);
                         for(let i=0; i<atoms.length; i++) {
                            for(let j=i+1; j<atoms.length; j++) {
                                const d = atoms[i].position.distanceTo(atoms[j].position);
                                // Intra-layer bond
                                if (d > 0.5 && d < 1.8) addBond(atoms[i].position, atoms[j].position);
                                // Van der Waals (dashed line equivalent, simplified as long thin bond for visual)
                                if (Math.abs(atoms[i].position.y - atoms[j].position.y) > 2 && d < 4.1 && d > 3.9) {
                                    // Optional: show weak force
                                }
                            }
                        }

                    } else if (id === 'Graphene') {
                        // Single Layer of Graphite logic
                         for(let r=-2; r<=2; r++) {
                            for(let c=-2; c<=2; c++) {
                                const cx = c * 2.5 + (r%2)*1.25;
                                const cz = r * 2.2;
                                for(let k=0; k<6; k++) {
                                    const ang = k * Math.PI/3;
                                    const px = (cx + Math.cos(ang)*0.8) * 1.8;
                                    const pz = (cz + Math.sin(ang)*0.8) * 1.8;
                                    
                                    let exists = false;
                                    group.children.forEach(child => {
                                        if (child.geometry === geoAtom && child.position.distanceTo(new THREE.Vector3(px,0,pz)) < 0.5) exists = true;
                                    });
                                    
                                    if (!exists) addAtom(px, 0, pz);
                                }
                            }
                        }
                         const atoms = group.children.filter(c => c.geometry === geoAtom);
                         for(let i=0; i<atoms.length; i++) {
                            for(let j=i+1; j<atoms.length; j++) {
                                const d = atoms[i].position.distanceTo(atoms[j].position);
                                if (d > 0.5 && d < 1.8) addBond(atoms[i].position, atoms[j].position);
                            }
                        }
                        // Rotate for better view
                        group.rotation.x = Math.PI / 6;

                    } else if (id === 'Nanotube') {
                        const r = 3.5;
                        const h = 14;
                        const segs = 16;
                        const stacks = 8;
                        
                        const atoms = [];
                        for(let y=0; y<stacks; y++) {
                            for(let i=0; i<segs; i++) {
                                const angle = (i/segs) * Math.PI * 2 + (y%2 ? Math.PI/segs : 0);
                                const px = Math.cos(angle) * r;
                                const pz = Math.sin(angle) * r;
                                const py = (y - stacks/2) * 1.2;
                                atoms.push(addAtom(px, py, pz));
                            }
                        }
                        
                        for(let i=0; i<atoms.length; i++) {
                            for(let j=i+1; j<atoms.length; j++) {
                                const d = atoms[i].distanceTo(atoms[j]);
                                if (d < 1.8) addBond(atoms[i], atoms[j]);
                            }
                        }
                    } else if (id === 'C60') {
                         // Fibonacci Sphere Distribution for visual approximation of Buckyball
                         const phi = (1 + Math.sqrt(5)) / 2;
                         const count = 60;
                         const radius = 4.5;
                         
                         const atoms = [];
                         for (let i = 0; i < count; i++) {
                             const y = 1 - (i / (count - 1)) * 2;
                             const r = Math.sqrt(1 - y * y);
                             const theta = phi * i * 2 * Math.PI;
                             
                             const x = Math.cos(theta) * r;
                             const z = Math.sin(theta) * r;
                             
                             const p = new THREE.Vector3(x * radius, y * radius, z * radius);
                             atoms.push(p);
                             addAtom(p.x, p.y, p.z);
                         }
                         
                         // Connect nearest neighbors
                         for(let i=0; i<atoms.length; i++) {
                             // Find 3 nearest
                             const neighbors = atoms
                                 .map((p, idx) => ({ idx, d: p.distanceTo(atoms[i]) }))
                                 .sort((a,b) => a.d - b.d)
                                 .slice(1, 4); // Self is 0
                                 
                             neighbors.forEach(n => {
                                 if(n.d < 2.5) {
                                     // Avoid duplicate bonds? ThreeJS handles intersecting geometries fine visually
                                     addBond(atoms[i], atoms[n.idx]);
                                 }
                             });
                         }
                    }

                    scene.add(group);
                };

                buildStructure(structureId);

                // Animation
                const animate = () => {
                    requestAnimationFrame(animate);
                    controls.update();
                    renderer.render(scene, camera);
                };
                animate();

                // Resize
                const handleResize = () => {
                    if (mountRef.current) {
                        camera.aspect = mountRef.current.clientWidth / mountRef.current.clientHeight;
                        camera.updateProjectionMatrix();
                        renderer.setSize(mountRef.current.clientWidth, mountRef.current.clientHeight);
                    }
                };
                window.addEventListener('resize', handleResize);

                return () => {
                    window.removeEventListener('resize', handleResize);
                    if (mountRef.current && rendererRef.current) {
                        mountRef.current.removeChild(rendererRef.current.domElement);
                        rendererRef.current.dispose();
                    }
                };
            }, [structureId]);

            return <div id="canvas-container" ref={mountRef} />;
        };

        const App = () => {
            const [currentStruct, setCurrentStruct] = useState(Structures[0]);

            return (
                <div className="flex flex-col h-full container mx-auto px-4 py-6 max-w-7xl">
                    
                    {/* Header */}
                    <div className="flex flex-col md:flex-row justify-between items-center mb-6 border-b border-slate-700 pb-4 gap-4">
                        <div>
                            <h1 className="text-3xl font-bold text-purple-400 flex items-center gap-2">
                                <Icon name="Hexagon" size={32} /> Carbon Allotrope Gallery
                            </h1>
                            <p className="text-slate-400 text-sm">Interactive 3D Structures of Carbon</p>
                        </div>
                    </div>

                    {/* Navigation Buttons */}
                    <div className="flex flex-wrap justify-center gap-2 mb-6">
                        {Structures.map(s => (
                            <button
                                key={s.id}
                                onClick={() => setCurrentStruct(s)}
                                className={`px-4 py-2 rounded-lg border text-sm font-bold transition-all shadow-md
                                    ${currentStruct.id === s.id ? 'btn-active' : 'btn-inactive'}
                                `}
                            >
                                {s.name.split(' ')[0]}
                            </button>
                        ))}
                    </div>

                    <div className="flex flex-col lg:flex-row gap-8 flex-grow">
                        
                        {/* 3D Viewport */}
                        <div className="w-full lg:w-2/3 h-[500px] lg:h-[600px] bg-slate-800 rounded-3xl border-4 border-slate-700 relative shadow-2xl overflow-hidden group">
                            <ThreeScene structureId={currentStruct.id} />
                            
                            {/* Hint Overlay */}
                            <div className="absolute bottom-4 left-4 text-xs text-slate-400 bg-black/60 px-3 py-2 rounded-lg pointer-events-none border border-slate-600 backdrop-blur-sm">
                                <span className="flex items-center gap-2"><Icon name="Move" size={14} /> Left Click to Rotate</span>
                                <span className="flex items-center gap-2 mt-1"><Icon name="ZoomIn" size={14} /> Scroll to Zoom</span>
                            </div>
                        </div>

                        {/* Info Panel */}
                        <div className="w-full lg:w-1/3 flex flex-col gap-6">
                            <div className="bg-slate-800 p-6 rounded-2xl border border-slate-700 shadow-lg flex-grow animate-in slide-in-from-right duration-500">
                                <div className="mb-6 border-b border-slate-700 pb-4">
                                    <div className="text-xs text-slate-400 uppercase font-bold mb-2 tracking-wider">Structure Type</div>
                                    <div className="inline-block bg-purple-900/50 text-purple-300 px-3 py-1 rounded-full text-xs border border-purple-700 mb-3 shadow-sm font-mono">
                                        {currentStruct.category}
                                    </div>
                                    <div className="text-3xl font-bold text-white leading-tight">{currentStruct.name.split(' ')[0]}</div>
                                    <div className="text-xs text-slate-500 font-mono mt-1">{currentStruct.name.split('(')[1]?.replace(')', '')}</div>
                                </div>
                                
                                <div className="space-y-6 text-sm text-slate-300 leading-relaxed">
                                    <div className="p-4 bg-slate-900/50 rounded-xl border-l-4 border-purple-500 shadow-inner">
                                        <strong className="text-white block mb-2 text-base">Characteristics</strong>
                                        {currentStruct.desc}
                                    </div>
                                    
                                    <div className="p-4 bg-slate-900/50 rounded-xl border border-slate-600">
                                        <strong className="text-white block mb-2 flex items-center gap-2 text-base">
                                            <Icon name="Eye" size={18} className="text-yellow-400" /> Key Feature
                                        </strong>
                                        <p className="text-xs opacity-90">
                                            {currentStruct.keyFeature}
                                        </p>
                                    </div>
                                </div>
                            </div>
                        </div>

                    </div>
                    
                    <div className="text-center text-slate-600 text-xs mt-8 border-t border-slate-800 pt-4">
                        Luminous Learner International | IB/A-Level Chemistry
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
