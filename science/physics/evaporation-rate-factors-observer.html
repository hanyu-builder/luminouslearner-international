<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Evaporation Rate Lab | Luminous Learner</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@0.263.1"></script>

    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;700;900&display=swap" rel="stylesheet">

    <style>
        body { font-family: 'Inter', sans-serif; background-color: #0f172a; color: #e2e8f0; }
        .slider-thumb::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none; width: 16px; height: 16px;
            border-radius: 50%; background: #3b82f6; cursor: pointer; border: 2px solid #ffffff;
        }
        canvas { touch-action: none; }
    </style>
</head>
<body>

<div id="root"></div>

<script type="text/babel">
    const { useState, useEffect, useRef } = React;

    const CANVAS_WIDTH = 600;
    const CANVAS_HEIGHT = 400;
    const WATER_LEVEL = 300; // Y position of water surface

    const App = () => {
        // --- State ---
        const [temperature, setTemperature] = useState(30); // Celsius
        const [surfaceArea, setSurfaceArea] = useState(50); // % Width
        const [humidity, setHumidity] = useState(40); // %
        const [evapRate, setEvapRate] = useState(0); // Particles per sec
        
        // --- Refs for Animation ---
        const canvasRef = useRef(null);
        const requestRef = useRef();
        const simState = useRef({
            particles: [],       // Water molecules
            airParticles: [],    // Humidity molecules
            escapedCount: 0,     // For rate calculation
            lastRateCheck: 0,
            waterWidth: 300
        });

        // --- Initialization ---
        useEffect(() => {
            initParticles();
        }, []); 

        const initParticles = () => {
            // Initial fill handled in loop now
            simState.current.particles = [];
        };

        const createWaterParticle = (reset = false) => {
            const width = simState.current.waterWidth;
            const centerX = CANVAS_WIDTH / 2;
            const halfWidth = width / 2;
            const startX = centerX - halfWidth;
            
            return {
                x: startX + Math.random() * width,
                y: reset ? WATER_LEVEL + Math.random() * (CANVAS_HEIGHT - WATER_LEVEL) : CANVAS_HEIGHT - 5,
                vx: (Math.random() - 0.5) * 1,
                vy: (Math.random() - 0.5) * 1,
                state: 'liquid', // liquid or gas
                energy: Math.random() // 0 to 1
            };
        };

        // --- Physics Loop ---
        const updatePhysics = (time) => {
            const ctx = canvasRef.current?.getContext('2d');
            if (!ctx) return;
            const state = simState.current;

            // 0. Update Water Dimensions & Particle Count based on Surface Area
            // LOGIC FIX: Scale particle count with surface area to simulate more surface exposure
            const targetWidth = 100 + (surfaceArea / 100) * 400; // 100px to 500px
            state.waterWidth = targetWidth;
            
            const targetParticleCount = Math.floor(150 + (surfaceArea / 100) * 400); // 150 to 550 particles

            // Add particles if needed
            if (state.particles.length < targetParticleCount) {
                for(let i=0; i < 5; i++) { // Add a few per frame to be smooth
                    if(state.particles.length < targetParticleCount) {
                        state.particles.push(createWaterParticle(true));
                    }
                }
            } 
            // Remove particles if needed
            else if (state.particles.length > targetParticleCount) {
                 state.particles.splice(0, state.particles.length - targetParticleCount);
            }

            // 1. Clear Canvas
            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            // 2. Draw Environment
            drawEnvironment(ctx, state.waterWidth);

            // 3. Humidity Logic (Air Particles)
            const targetAirParticles = Math.floor((humidity / 100) * 150);
            
            if (state.airParticles.length < targetAirParticles) {
                state.airParticles.push({
                    x: Math.random() * CANVAS_WIDTH,
                    y: Math.random() * WATER_LEVEL,
                    vx: (Math.random() - 0.5) * 0.5,
                    vy: (Math.random() - 0.5) * 0.5
                });
            } else if (state.airParticles.length > targetAirParticles) {
                state.airParticles.pop();
            }

            ctx.fillStyle = 'rgba(200, 200, 200, 0.3)';
            state.airParticles.forEach(p => {
                p.x += p.vx;
                p.y += p.vy;
                if(p.x < 0 || p.x > CANVAS_WIDTH) p.vx *= -1;
                if(p.y < 0 || p.y > WATER_LEVEL) p.vy *= -1;
                
                ctx.beginPath();
                ctx.arc(p.x, p.y, 2, 0, Math.PI*2);
                ctx.fill();
            });


            // 4. Water Particle Logic
            const speedFactor = 0.2 + (temperature / 100) * 2.8; 
            const escapeEnergyThreshold = 1.1 - (temperature / 150);

            const centerX = CANVAS_WIDTH / 2;
            const halfWidth = state.waterWidth / 2;

            state.particles.forEach(p => {
                const left = centerX - halfWidth;
                const right = centerX + halfWidth;

                if (p.state === 'liquid') {
                    p.x += p.vx * speedFactor;
                    p.y += p.vy * speedFactor;

                    // Walls
                    if (p.x < left) { p.x = left; p.vx *= -1; }
                    if (p.x > right) { p.x = right; p.vx *= -1; }
                    if (p.y > CANVAS_HEIGHT) { p.y = CANVAS_HEIGHT; p.vy *= -1; }
                    
                    // Surface Interaction
                    if (p.y < WATER_LEVEL) {
                        const humidityBlock = (humidity / 100) * 0.9; 
                        
                        if (p.energy * speedFactor > escapeEnergyThreshold && Math.random() > humidityBlock) {
                            p.state = 'gas';
                            state.escapedCount++;
                        } else {
                            p.y = WATER_LEVEL;
                            p.vy *= -1;
                        }
                    }
                } else {
                    // Gas State
                    p.x += p.vx * speedFactor;
                    p.y += p.vy * speedFactor - 0.5;
                    p.energy *= 0.99;

                    // Recycle
                    if (p.y < -10 || p.x < -50 || p.x > CANVAS_WIDTH + 50) {
                         // Reset to liquid
                         const newP = createWaterParticle();
                         p.x = newP.x;
                         p.y = newP.y;
                         p.state = 'liquid';
                         p.vx = newP.vx;
                         p.vy = newP.vy;
                         p.energy = newP.energy;
                    }
                }
            });

            // 5. Draw Water Particles
            state.particles.forEach(p => {
                ctx.beginPath();
                if (p.state === 'liquid') {
                    ctx.fillStyle = `rgba(59, 130, 246, 0.8)`;
                    ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
                } else {
                    const opacity = Math.max(0, 1 - (WATER_LEVEL - p.y) / 200);
                    ctx.fillStyle = `rgba(147, 197, 253, ${opacity})`;
                    ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
                }
                ctx.fill();
            });

            // 6. Rate Calculation (Smoothed)
            if (time - state.lastRateCheck > 500) {
                const currentRate = state.escapedCount * 2;
                setEvapRate(prev => Math.round(prev * 0.7 + currentRate * 0.3));
                state.escapedCount = 0;
                state.lastRateCheck = time;
            }

            requestRef.current = requestAnimationFrame((t) => updatePhysics(t));
        };

        const drawEnvironment = (ctx, width) => {
            const centerX = CANVAS_WIDTH / 2;
            const halfWidth = width / 2;
            
            // Draw Container Walls
            ctx.strokeStyle = '#94a3b8';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(centerX - halfWidth, WATER_LEVEL - 20); // Lip
            ctx.lineTo(centerX - halfWidth, CANVAS_HEIGHT);
            ctx.lineTo(centerX + halfWidth, CANVAS_HEIGHT);
            ctx.lineTo(centerX + halfWidth, WATER_LEVEL - 20);
            ctx.stroke();

            // Draw Water Bulk
            ctx.fillStyle = 'rgba(30, 64, 175, 0.2)';
            ctx.fillRect(centerX - halfWidth, WATER_LEVEL, width, CANVAS_HEIGHT - WATER_LEVEL);
            
            // Surface Line
            ctx.strokeStyle = 'rgba(59, 130, 246, 0.5)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(centerX - halfWidth, WATER_LEVEL);
            ctx.lineTo(centerX + halfWidth, WATER_LEVEL);
            ctx.stroke();

            // Sun/Heat Visual
            const sunOpacity = 0.2 + (temperature / 100) * 0.8;
            const sunColor = temperature > 80 ? '#ef4444' : '#fbbf24';
            
            const gradient = ctx.createRadialGradient(CANVAS_WIDTH - 60, 60, 10, CANVAS_WIDTH - 60, 60, 80);
            gradient.addColorStop(0, `${sunColor}${Math.floor(sunOpacity*255).toString(16).padStart(2,'0')}`);
            gradient.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(CANVAS_WIDTH - 60, 60, 80, 0, Math.PI*2);
            ctx.fill();
        };

        useEffect(() => {
            requestRef.current = requestAnimationFrame((t) => updatePhysics(t));
            return () => cancelAnimationFrame(requestRef.current);
        }, [temperature, surfaceArea, humidity]);

        return (
            <div className="min-h-screen bg-slate-900 pb-12 font-sans text-slate-200">
                <nav className="bg-slate-800 border-b border-slate-700 px-6 py-4 flex items-center justify-between">
                    <div className="flex items-center space-x-3">
                        <div className="bg-blue-500/20 p-2 rounded-lg">
                            <i data-lucide="droplets" className="w-6 h-6 text-blue-400"></i>
                        </div>
                        <h1 className="text-xl font-bold text-white tracking-wide">Evaporation Rate Lab</h1>
                    </div>
                    <div className="text-xs text-slate-400 font-mono bg-slate-900 px-3 py-1 rounded-full border border-slate-700">
                        Topic: Thermal Physics
                    </div>
                </nav>

                <main className="max-w-6xl mx-auto p-6 grid grid-cols-1 lg:grid-cols-3 gap-6">
                    
                    {/* Controls */}
                    <div className="bg-slate-800 rounded-2xl p-6 border border-slate-700 h-fit space-y-8">
                        <div>
                            <h2 className="text-blue-400 font-bold mb-6 flex items-center">
                                <i data-lucide="sliders" className="w-5 h-5 mr-2"></i> Factors
                            </h2>

                            {/* Surface Area */}
                            <div className="mb-6">
                                <div className="flex justify-between mb-2">
                                    <label className="text-sm font-medium text-slate-300">Surface Area</label>
                                    <span className="text-blue-400 font-mono">{surfaceArea}%</span>
                                </div>
                                <input 
                                    type="range" min="10" max="100" 
                                    value={surfaceArea} onChange={(e) => setSurfaceArea(Number(e.target.value))}
                                    className="w-full h-2 bg-slate-700 rounded-lg slider-thumb appearance-none"
                                />
                                <div className="flex justify-between text-[10px] text-slate-500 mt-1">
                                    <span>Cup</span>
                                    <span>Bowl</span>
                                    <span>Tray</span>
                                </div>
                            </div>

                            {/* Temperature */}
                            <div className="mb-6">
                                <div className="flex justify-between mb-2">
                                    <label className="text-sm font-medium text-slate-300">Temperature</label>
                                    <span className={`${temperature > 70 ? 'text-red-400' : 'text-orange-400'} font-mono`}>{temperature}Â°C</span>
                                </div>
                                <input 
                                    type="range" min="0" max="100" 
                                    value={temperature} onChange={(e) => setTemperature(Number(e.target.value))}
                                    className="w-full h-2 bg-slate-700 rounded-lg slider-thumb appearance-none"
                                />
                            </div>

                            {/* Humidity */}
                            <div className="mb-6">
                                <div className="flex justify-between mb-2">
                                    <label className="text-sm font-medium text-slate-300">Air Humidity</label>
                                    <span className="text-slate-400 font-mono">{humidity}%</span>
                                </div>
                                <input 
                                    type="range" min="0" max="100" 
                                    value={humidity} onChange={(e) => setHumidity(Number(e.target.value))}
                                    className="w-full h-2 bg-slate-700 rounded-lg slider-thumb appearance-none"
                                />
                                <div className="flex justify-between text-[10px] text-slate-500 mt-1">
                                    <span>Dry Day</span>
                                    <span>Rainy Day</span>
                                </div>
                            </div>
                        </div>

                        {/* Results Panel */}
                        <div className="bg-slate-900 rounded-xl p-5 border border-slate-700">
                            <div className="text-xs text-slate-500 uppercase tracking-widest mb-2">Evaporation Rate</div>
                            <div className="flex items-end gap-3">
                                <span className="text-4xl font-bold text-white font-mono">{evapRate}</span>
                                <span className="text-sm text-slate-400 mb-1">particles / sec</span>
                            </div>
                            
                            {/* Visual Bar */}
                            <div className="w-full h-2 bg-slate-800 rounded-full mt-4 overflow-hidden">
                                <div 
                                    className="h-full bg-gradient-to-r from-blue-600 to-cyan-400 transition-all duration-300"
                                    style={{width: `${Math.min(100, evapRate / 1.5)}%`}}
                                ></div>
                            </div>
                        </div>
                    </div>

                    {/* Simulation Canvas */}
                    <div className="lg:col-span-2 bg-black rounded-2xl border border-slate-700 overflow-hidden relative shadow-2xl">
                        <canvas 
                            ref={canvasRef} 
                            width={CANVAS_WIDTH} 
                            height={CANVAS_HEIGHT}
                            className="w-full h-full block bg-slate-950"
                        />
                        
                        {/* Overlay Legends */}
                        <div className="absolute top-4 left-4 space-y-2 pointer-events-none">
                            <div className="flex items-center bg-black/40 backdrop-blur px-3 py-1.5 rounded-full border border-slate-700/50">
                                <div className="w-2 h-2 rounded-full bg-blue-500 mr-2"></div>
                                <span className="text-xs text-slate-300">Liquid Water</span>
                            </div>
                            <div className="flex items-center bg-black/40 backdrop-blur px-3 py-1.5 rounded-full border border-slate-700/50">
                                <div className="w-2 h-2 rounded-full bg-gray-400 mr-2"></div>
                                <span className="text-xs text-slate-300">Humidity (Water Vapor)</span>
                            </div>
                        </div>
                    </div>

                </main>
            </div>
        );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);

    if (typeof lucide !== 'undefined') {
        setTimeout(() => lucide.createIcons(), 100);
    }
</script>
</body>
</html>
