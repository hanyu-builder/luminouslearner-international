<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Background Radiation Lab | Luminous Learner</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@0.263.1"></script>

    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;700;900&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Digital-7&display=swap" rel="stylesheet">

    <style>
        body { font-family: 'Inter', sans-serif; background-color: #0f172a; color: #e2e8f0; }
        .digital-font { font-family: 'Courier New', monospace; letter-spacing: -1px; }
        .canvas-container { cursor: default; }
    </style>
</head>
<body>

<div id="root"></div>

<script type="text/babel">
    const { useState, useEffect, useRef } = React;

    const CANVAS_WIDTH = 800;
    const CANVAS_HEIGHT = 400;
    const CENTER_Y = CANVAS_HEIGHT / 2;
    
    const SOURCE_X = 100;
    const BARRIER_X = 400;
    const DETECTOR_X = 700;

    const App = () => {
        // --- State ---
        // 'alpha', 'beta', 'gamma'
        const [sourceType, setSourceType] = useState('alpha'); 
        // 'none', 'paper', 'aluminium', 'lead'
        const [barrierType, setBarrierType] = useState('none'); 
        const [thickness, setThickness] = useState(5); 
        
        // Operation State
        const [mode, setMode] = useState('background'); // 'background' or 'source'
        const [isCounting, setIsCounting] = useState(false);
        const [timer, setTimer] = useState(0); 
        const [totalCounts, setTotalCounts] = useState(0);
        const [currentCpm, setCurrentCpm] = useState(0);
        const [soundEnabled, setSoundEnabled] = useState(false);

        // Lab Results
        const [bgRate, setBgRate] = useState(null); 
        const [sourceRate, setSourceRate] = useState(null); 
        const [correctedRate, setCorrectedRate] = useState(null);

        // Refs
        const particlesRef = useRef([]);
        const canvasRef = useRef(null);
        const requestRef = useRef();
        const audioCtxRef = useRef(null);
        const lastTickRef = useRef(0);
        
        // Refs for loop access to current state
        const paramsRef = useRef({ sourceType, barrierType, mode });

        // Sync params
        useEffect(() => {
            paramsRef.current = { sourceType, barrierType, mode };
        }, [sourceType, barrierType, mode]);

        // --- Physics Logic ---
        const getPenetrationChance = (type, barrier) => {
            if (barrier === 'none') return 1.0; 

            if (type === 'alpha') {
                if (barrier === 'paper') return 0.0;
                if (barrier === 'aluminium') return 0.0;
                if (barrier === 'lead') return 0.0;
            }
            if (type === 'beta') {
                if (barrier === 'paper') return 0.95;
                if (barrier === 'aluminium') return 0.0;
                if (barrier === 'lead') return 0.0;
            }
            if (type === 'gamma') {
                if (barrier === 'paper') return 1.0;
                if (barrier === 'aluminium') return 0.95;
                if (barrier === 'lead') return 0.1;
            }
            return 1.0;
        };

        // --- Audio ---
        const playClick = () => {
            if (!soundEnabled) return;
            
            if (!audioCtxRef.current) {
                audioCtxRef.current = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (audioCtxRef.current.state === 'suspended') audioCtxRef.current.resume();

            const osc = audioCtxRef.current.createOscillator();
            const gain = audioCtxRef.current.createGain();

            osc.type = 'square';
            osc.frequency.value = 800 + Math.random() * 200;
            
            gain.gain.setValueAtTime(0.1, audioCtxRef.current.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtxRef.current.currentTime + 0.05);

            osc.connect(gain);
            gain.connect(audioCtxRef.current.destination);
            
            osc.start();
            osc.stop(audioCtxRef.current.currentTime + 0.05);
        };
        
        // --- Controls ---
        const startCount = () => {
            if (isCounting) return;
            setIsCounting(true);
            setTimer(0);
            setTotalCounts(0);
            setCurrentCpm(0);
            lastTickRef.current = performance.now();
            requestRef.current = requestAnimationFrame(loop);
        };

        const stopCount = () => {
            setIsCounting(false);
            cancelAnimationFrame(requestRef.current);
            
            // Final calculation
            let finalRate = 0;
            if (timer > 0.1) {
                finalRate = Math.round(totalCounts / (timer / 60));
            }

            if (mode === 'background') setBgRate(finalRate);
            else setSourceRate(finalRate);
        };

        const reset = () => {
            setIsCounting(false);
            cancelAnimationFrame(requestRef.current);
            setTimer(0);
            setTotalCounts(0);
            setCurrentCpm(0);
            setBgRate(null);
            setSourceRate(null);
            setCorrectedRate(null);
            particlesRef.current = [];
            // Force redraw
            setTimeout(draw, 0); 
        };
        
        const calculateCorrection = () => {
            if (bgRate !== null && sourceRate !== null) {
                // Ensure non-negative result
                const val = Math.max(0, sourceRate - bgRate);
                setCorrectedRate(val);
            }
        };

        const setBarrier = (type) => {
            setBarrierType(type);
            if (type === 'paper') setThickness(2);
            else if (type === 'aluminium') setThickness(10);
            else if (type === 'lead') setThickness(40);
        };

        // --- Simulation Loop ---
        const loop = (timestamp) => {
            const dt = (timestamp - lastTickRef.current) / 1000;
            
            if (isCounting) {
                 if (dt < 0.1 && dt > 0) {
                     setTimer(prev => {
                         const nextT = prev + dt;
                         if (nextT >= 60) {
                             // Will stop in next render cycle effect, but let's handle via flag
                             // Better to let state update drive it
                             return 60;
                         }
                         return nextT;
                     });
                 }
            }
            lastTickRef.current = timestamp;
            
            // Check timer limit
            if (timer >= 60 && isCounting) {
                stopCount();
                return; // Stop loop
            }

            const { sourceType: currSource, barrierType: currBarrier, mode: currMode } = paramsRef.current;

            // 1. Spawn Particles
            
            // Background Radiation (Always spawn some random particles)
            // Low probability, random position/direction
            if (Math.random() < 0.05) { 
                particlesRef.current.push({
                    x: Math.random() * CANVAS_WIDTH,
                    y: Math.random() * CANVAS_HEIGHT,
                    vx: (Math.random() - 0.5) * 4,
                    vy: (Math.random() - 0.5) * 4,
                    type: 'bg', // Special type for background
                    dead: false,
                    passed: false
                });
            }

            // Source Radiation (Only if mode is 'source')
            if (currMode === 'source' && Math.random() < 0.3) {
                particlesRef.current.push({
                    x: SOURCE_X + 40,
                    y: CENTER_Y + (Math.random() - 0.5) * 40,
                    vx: (5 + Math.random() * 2),
                    vy: (Math.random() - 0.5) * 0.5,
                    type: currSource,
                    dead: false,
                    passed: false
                });
            }

            // 2. Update Particles
            let hits = 0;
            
            particlesRef.current = particlesRef.current.map(p => {
                if (p.dead) return p;

                let nextX = p.x + p.vx;
                let nextY = p.y + p.vy;
                let isDead = false;

                // Barrier Collision
                if (!p.passed && p.type !== 'bg' && nextX >= BARRIER_X - thickness && nextX <= BARRIER_X + thickness) {
                    const chance = getPenetrationChance(p.type, currBarrier);
                    if (Math.random() > chance) { // Blocked
                        isDead = true; 
                        nextX = BARRIER_X - Math.random() * 5; 
                    } else {
                        p.passed = true; 
                    }
                }

                // Detector Collision
                if (nextX >= DETECTOR_X - 10 && nextX <= DETECTOR_X + 10 && 
                    nextY >= CENTER_Y - 30 && nextY <= CENTER_Y + 30) {
                    isDead = true;
                    hits++;
                    playClick();
                }

                // Out of bounds
                if (nextX < -50 || nextX > CANVAS_WIDTH + 50 || nextY < -50 || nextY > CANVAS_HEIGHT + 50) {
                    isDead = true;
                }

                return { ...p, x: nextX, y: nextY, dead: isDead };
            }).filter(p => !p.dead || Math.random() > 0.1); // Keep dead briefly for visual, then remove

            // 3. Update Counts
            if (isCounting && hits > 0) {
                setTotalCounts(prev => prev + hits);
            }
            
            // Calculate instantaneous CPM for display
            if (isCounting && timer > 0.5) {
                setCurrentCpm(Math.round(totalCounts / (timer / 60)));
            } else {
                setCurrentCpm(0);
            }

            draw();
            
            if (isCounting) {
                requestRef.current = requestAnimationFrame(loop);
            }
        };

        // --- Rendering ---
        const draw = () => {
            const ctx = canvasRef.current?.getContext('2d');
            if (!ctx) return;

            const { sourceType: currSource, barrierType: currBarrier, mode: currMode } = paramsRef.current;

            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            // 1. Source Block (Only if mode is source)
            if (currMode === 'source') {
                ctx.fillStyle = '#334155';
                ctx.fillRect(SOURCE_X - 40, CENTER_Y - 40, 80, 80);
                
                // Radiation Symbol
                ctx.fillStyle = '#facc15';
                ctx.beginPath();
                ctx.moveTo(SOURCE_X, CENTER_Y - 20);
                ctx.lineTo(SOURCE_X + 20, CENTER_Y + 15);
                ctx.lineTo(SOURCE_X - 20, CENTER_Y + 15);
                ctx.fill();
                
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 12px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(currSource.toUpperCase(), SOURCE_X, CENTER_Y + 50);
            } else {
                // Empty stand
                ctx.fillStyle = '#1e293b';
                ctx.fillRect(SOURCE_X - 20, CENTER_Y + 30, 40, 10);
                ctx.fillStyle = '#64748b';
                ctx.font = 'italic 12px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText("(Source Removed)", SOURCE_X, CENTER_Y + 20);
            }

            // 2. Barrier
            if (currBarrier !== 'none') {
                if (currBarrier === 'paper') ctx.fillStyle = '#fefce8';
                else if (currBarrier === 'aluminium') ctx.fillStyle = '#94a3b8';
                else if (currBarrier === 'lead') ctx.fillStyle = '#475569';
                
                ctx.fillRect(BARRIER_X - thickness, CENTER_Y - 100, thickness * 2, 200);
                
                ctx.fillStyle = '#fff';
                ctx.textAlign = 'center';
                ctx.fillText(currBarrier.charAt(0).toUpperCase() + currBarrier.slice(1), BARRIER_X, CENTER_Y - 110);
            }

            // 3. Detector
            ctx.fillStyle = '#1e293b';
            ctx.fillRect(DETECTOR_X, CENTER_Y - 40, 60, 80);
            ctx.strokeStyle = '#64748b';
            ctx.lineWidth = 2;
            ctx.strokeRect(DETECTOR_X, CENTER_Y - 40, 10, 80); // Front Mesh
            ctx.beginPath(); ctx.moveTo(DETECTOR_X + 60, CENTER_Y); ctx.lineTo(CANVAS_WIDTH, CENTER_Y); ctx.stroke(); // Cable

            // 4. Particles
            particlesRef.current.forEach(p => {
                ctx.beginPath();
                
                if (p.type === 'bg') {
                    // Background: faint white dots
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                    ctx.arc(p.x, p.y, 1.5, 0, Math.PI*2);
                } else if (p.type === 'alpha') {
                    ctx.fillStyle = '#ef4444';
                    ctx.arc(p.x, p.y, 4, 0, Math.PI*2);
                } else if (p.type === 'beta') {
                    ctx.fillStyle = '#3b82f6';
                    ctx.arc(p.x, p.y, 2, 0, Math.PI*2);
                } else {
                    // Gamma
                    ctx.strokeStyle = '#facc15';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(p.x - 5, p.y);
                    ctx.quadraticCurveTo(p.x, p.y - 3, p.x + 5, p.y);
                    ctx.stroke();
                    return; 
                }
                ctx.fill();
            });
        };

        // Redraw when not running to update UI changes
        useEffect(() => {
            if (!isCounting) {
                draw();
            }
        }, [mode, sourceType, barrierType]); // Redraw on setup change

        useEffect(() => {
            if (window.lucide) window.lucide.createIcons();
        });

        return (
            <div className="min-h-screen bg-slate-900 text-slate-200 font-sans pb-12">
                <nav className="bg-slate-800 border-b border-slate-700 px-6 py-4 flex items-center justify-between sticky top-0 z-10">
                    <div className="flex items-center space-x-3">
                        <div className="bg-yellow-500/20 p-2 rounded-lg">
                            <i data-lucide="radio" className="w-6 h-6 text-yellow-400"></i>
                        </div>
                        <h1 className="text-xl font-bold text-white tracking-wide">Background Radiation Lab</h1>
                    </div>
                    <div className="text-xs text-slate-400 font-mono bg-slate-900 px-3 py-1 rounded-full border border-slate-700">
                        Topic: Nuclear Physics
                    </div>
                </nav>

                <main className="max-w-6xl mx-auto p-4 md:p-6 grid grid-cols-1 lg:grid-cols-12 gap-8">
                    
                    {/* Left: Simulation Canvas */}
                    <div className="lg:col-span-8 flex flex-col gap-6">
                        <div className="bg-slate-950 rounded-2xl border border-slate-700 p-1 shadow-2xl relative overflow-hidden h-[400px]">
                            <canvas 
                                ref={canvasRef} 
                                width={CANVAS_WIDTH} 
                                height={CANVAS_HEIGHT}
                                className="w-full h-full object-contain bg-slate-950 rounded-xl"
                            />
                            
                            {/* Counter Overlay */}
                            <div className="absolute top-[295px] left-[510px] w-[120px] text-right font-mono text-emerald-400 font-bold text-2xl tracking-widest digital-font">
                                {totalCounts.toString().padStart(4, '0')}
                            </div>
                            
                            <div className="absolute top-4 left-4 bg-slate-900/80 px-4 py-2 rounded-lg border border-slate-700 text-xs shadow-lg space-y-1">
                                <div className="flex justify-between gap-4">
                                    <span className="text-slate-400">Timer</span>
                                    <span className="text-white font-mono">{timer.toFixed(1)}s</span>
                                </div>
                                <div className="flex justify-between gap-4">
                                    <span className="text-slate-400">Current Rate</span>
                                    <span className="text-yellow-400 font-mono">{currentCpm} CPM</span>
                                </div>
                            </div>
                        </div>

                        {/* Controls */}
                        <div className="bg-slate-800 p-6 rounded-2xl border border-slate-700 flex flex-wrap gap-8 items-center justify-between">
                            
                            {/* Mode Select */}
                            <div className="flex bg-slate-900 p-1 rounded-lg border border-slate-700">
                                <button 
                                    onClick={() => { setMode('background'); reset(); }}
                                    disabled={isCounting}
                                    className={`px-4 py-2 rounded-md text-xs font-bold transition-all ${mode === 'background' ? 'bg-blue-600 text-white shadow-lg' : 'text-slate-400 hover:text-white'}`}
                                >
                                    Measure Background
                                </button>
                                <button 
                                    onClick={() => { setMode('source'); reset(); }}
                                    disabled={isCounting}
                                    className={`px-4 py-2 rounded-md text-xs font-bold transition-all ${mode === 'source' ? 'bg-red-600 text-white shadow-lg' : 'text-slate-400 hover:text-white'}`}
                                >
                                    Measure Source
                                </button>
                            </div>
                            
                            {/* Only show source controls in Source Mode */}
                            {mode === 'source' && (
                                <div className="flex gap-2">
                                     <button onClick={() => setSourceType('alpha')} className={`px-3 py-1 rounded text-xs border ${sourceType==='alpha'?'bg-red-600 border-red-400':'bg-slate-700 border-slate-600'}`}>Alpha</button>
                                     <button onClick={() => setSourceType('beta')} className={`px-3 py-1 rounded text-xs border ${sourceType==='beta'?'bg-blue-600 border-blue-400':'bg-slate-700 border-slate-600'}`}>Beta</button>
                                     <button onClick={() => setSourceType('gamma')} className={`px-3 py-1 rounded text-xs border ${sourceType==='gamma'?'bg-yellow-600 border-yellow-400':'bg-slate-700 border-slate-600'}`}>Gamma</button>
                                </div>
                            )}

                            <div className="flex gap-3">
                                <button 
                                    onClick={isCounting ? stopCount : startCount}
                                    className={`px-8 py-3 rounded-xl font-bold flex items-center gap-2 transition-all shadow-lg ${isCounting ? 'bg-slate-700 text-slate-300' : 'bg-emerald-600 hover:bg-emerald-500 text-white'}`}
                                >
                                    <i data-lucide={isCounting ? "square" : "play"} className="w-5 h-5"></i>
                                    {isCounting ? "Stop" : "Start Count"}
                                </button>
                                <button onClick={reset} className="px-4 py-3 bg-slate-700 hover:bg-slate-600 rounded-xl text-white font-bold transition-colors">
                                    <i data-lucide="rotate-ccw" className="w-5 h-5"></i>
                                </button>
                            </div>

                        </div>
                    </div>

                    {/* Right: Data Analysis */}
                    <div className="lg:col-span-4 space-y-6">
                        
                        <div className="bg-slate-800 p-6 rounded-2xl border border-slate-700">
                            <h2 className="text-white font-bold mb-6 flex items-center">
                                <i data-lucide="clipboard-list" className="w-5 h-5 mr-2 text-indigo-400"></i>
                                Lab Results
                            </h2>
                            
                            <div className="space-y-4">
                                <div className="p-4 rounded-xl bg-blue-900/10 border border-blue-500/20">
                                    <div className="text-xs text-blue-400 uppercase tracking-widest mb-1">Background Rate</div>
                                    <div className="text-2xl font-mono font-bold text-white">
                                        {bgRate !== null ? bgRate : '--'} <span className="text-sm text-slate-500">CPM</span>
                                    </div>
                                    <div className="text-[10px] text-slate-500 mt-1">
                                        Radiation from environment (must be subtracted!)
                                    </div>
                                </div>

                                <div className="p-4 rounded-xl bg-red-900/10 border border-red-500/20">
                                    <div className="text-xs text-red-400 uppercase tracking-widest mb-1">Source + Background</div>
                                    <div className="text-2xl font-mono font-bold text-white">
                                        {sourceRate !== null ? sourceRate : '--'} <span className="text-sm text-slate-500">CPM</span>
                                    </div>
                                    <div className="text-[10px] text-slate-500 mt-1">
                                        Total reading with source present
                                    </div>
                                </div>

                                <div className="border-t border-slate-700 my-4"></div>

                                <button 
                                    onClick={calculateCorrection}
                                    disabled={bgRate === null || sourceRate === null}
                                    className="w-full py-3 bg-indigo-600 hover:bg-indigo-500 disabled:bg-slate-700 disabled:text-slate-500 text-white rounded-xl font-bold transition-colors"
                                >
                                    Calculate Corrected Rate
                                </button>

                                <div className="p-4 rounded-xl bg-emerald-900/20 border border-emerald-500/50 text-center">
                                    <div className="text-xs text-emerald-400 uppercase tracking-widest mb-1">True Source Rate</div>
                                    <div className="text-3xl font-mono font-bold text-white">
                                        {correctedRate !== null ? correctedRate : '--'} <span className="text-lg text-slate-500">CPM</span>
                                    </div>
                                    <div className="text-[10px] text-slate-400 mt-2 font-mono">
                                        = {sourceRate || 'Total'} - {bgRate || 'Background'}
                                    </div>
                                </div>
                            </div>
                        </div>

                    </div>

                </main>
            </div>
        );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
</script>
</body>
</html>
