<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Diffraction Grating Lab | Luminous Learner</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@0.263.1"></script>

    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;700;900&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">

    <style>
        body { font-family: 'Inter', sans-serif; background-color: #0f172a; color: #e2e8f0; }
        .slider-thumb::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none; width: 16px; height: 16px;
            border-radius: 50%; cursor: pointer; border: 2px solid #ffffff;
        }
        canvas { image-rendering: pixelated; }
    </style>
</head>
<body>

<div id="root"></div>

<script type="text/babel">
    const { useState, useEffect, useRef } = React;

    const CANVAS_WIDTH = 800;
    const GEOM_HEIGHT = 250;
    const SCREEN_HEIGHT = 150;
    const TOTAL_HEIGHT = GEOM_HEIGHT + SCREEN_HEIGHT;
    
    const SCREEN_DIST_PX = 600; // Pixel distance to screen in Geom view

    const App = () => {
        // --- State ---
        const [mode, setMode] = useState('monochromatic'); // 'monochromatic' or 'white'
        const [wavelength, setWavelength] = useState(532); // nm (Green)
        const [linesPerMm, setLinesPerMm] = useState(300); // N (lines/mm)
        const [screenDist, setScreenDist] = useState(1.0); // meters (Physical L)
        
        // Calculated
        const [orders, setOrders] = useState([]);

        const canvasRef = useRef(null);

        // --- Color Helper ---
        const nmToRGB = (wavelength) => {
            let r, g, b;
            if (wavelength >= 380 && wavelength < 440) {
                r = -(wavelength - 440) / (440 - 380); g = 0; b = 1;
            } else if (wavelength >= 440 && wavelength < 490) {
                r = 0; g = (wavelength - 440) / (490 - 440); b = 1;
            } else if (wavelength >= 490 && wavelength < 510) {
                r = 0; g = 1; b = -(wavelength - 510) / (510 - 490);
            } else if (wavelength >= 510 && wavelength < 580) {
                r = (wavelength - 510) / (580 - 510); g = 1; b = 0;
            } else if (wavelength >= 580 && wavelength < 645) {
                r = 1; g = -(wavelength - 645) / (645 - 580); b = 0;
            } else if (wavelength >= 645 && wavelength <= 750) {
                r = 1; g = 0; b = 0;
            } else {
                r = 0; g = 0; b = 0;
            }
            // Intensity falloff
            let factor;
            if (wavelength >= 380 && wavelength < 420) factor = 0.3 + 0.7 * (wavelength - 380) / (420 - 380);
            else if (wavelength >= 420 && wavelength < 700) factor = 1.0;
            else if (wavelength >= 700 && wavelength <= 750) factor = 0.3 + 0.7 * (750 - wavelength) / (750 - 700);
            else factor = 0.0;

            const R = Math.floor(r * factor * 255);
            const G = Math.floor(g * factor * 255);
            const B = Math.floor(b * factor * 255);
            return `rgb(${R},${G},${B})`;
        };

        // --- Physics Logic ---
        useEffect(() => {
            const d = 1e-3 / linesPerMm; // Grating spacing in meters
            const newOrders = [];

            // Calculate max order
            // n * lambda = d * sin(theta) -> n_max = d / lambda
            // Use 400nm (shortest) to find max possible n for white light container
            const maxLambda = mode === 'white' ? 750e-9 : wavelength * 1e-9;
            const maxN = Math.floor(d / maxLambda);

            // We only simulate up to n=3 for visual clarity usually
            const limitN = Math.min(maxN, 3);

            for (let n = 1; n <= limitN; n++) {
                // Calculate angles
                if (mode === 'monochromatic') {
                    const lambda = wavelength * 1e-9;
                    const sinTheta = (n * lambda) / d;
                    if (sinTheta <= 1) {
                        const theta = Math.asin(sinTheta);
                        newOrders.push({ n, theta, color: nmToRGB(wavelength), type: 'line' });
                    }
                } else {
                    // White light: Spectrum from 400nm to 700nm
                    // Start (Violet)
                    const lamV = 400e-9;
                    const sinV = (n * lamV) / d;
                    const thetaV = Math.asin(sinV);
                    
                    // End (Red)
                    const lamR = 700e-9;
                    const sinR = (n * lamR) / d;
                    
                    if (sinR <= 1) { // Only add if whole spectrum fits (or part)
                        const thetaR = Math.asin(sinR);
                        newOrders.push({ n, thetaStart: thetaV, thetaEnd: thetaR, type: 'spectrum' });
                    }
                }
            }
            setOrders(newOrders);
            draw();
        }, [mode, wavelength, linesPerMm, screenDist]);

        // --- Rendering ---
        const draw = () => {
            const ctx = canvasRef.current?.getContext('2d');
            if (!ctx) return;

            const w = CANVAS_WIDTH;
            const h = TOTAL_HEIGHT;
            const cy = GEOM_HEIGHT / 2;
            const gratingX = 50;
            const screenX = gratingX + SCREEN_DIST_PX;

            ctx.clearRect(0, 0, w, h);

            // --- 1. Top View (Geometry) ---
            
            // Background
            ctx.fillStyle = '#0f172a';
            ctx.fillRect(0, 0, w, GEOM_HEIGHT);
            
            // Optical Axis
            ctx.strokeStyle = '#334155';
            ctx.setLineDash([5, 5]);
            ctx.beginPath(); ctx.moveTo(0, cy); ctx.lineTo(w, cy); ctx.stroke();
            ctx.setLineDash([]);

            // Grating
            ctx.strokeStyle = '#94a3b8';
            ctx.lineWidth = 4;
            ctx.beginPath(); ctx.moveTo(gratingX, cy - 80); ctx.lineTo(gratingX, cy + 80); ctx.stroke();
            // Slits visual
            ctx.strokeStyle = '#0f172a';
            ctx.lineWidth = 2;
            for(let i=-75; i<75; i+=10) {
                ctx.beginPath(); ctx.moveTo(gratingX-2, cy+i); ctx.lineTo(gratingX+2, cy+i); ctx.stroke();
            }

            // Screen Line (Geometry View)
            ctx.strokeStyle = '#64748b';
            ctx.lineWidth = 4;
            ctx.beginPath(); ctx.moveTo(screenX, 20); ctx.lineTo(screenX, GEOM_HEIGHT-20); ctx.stroke();

            // Rays
            const drawRay = (angle, color, label) => {
                const dx = Math.cos(angle) * SCREEN_DIST_PX;
                const dy = Math.sin(angle) * SCREEN_DIST_PX;
                
                // Only draw if hits screen area
                const hitY = cy + dy;
                
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.6;
                ctx.beginPath();
                ctx.moveTo(gratingX, cy);
                ctx.lineTo(gratingX + dx, hitY);
                ctx.stroke();
                ctx.globalAlpha = 1.0;

                // Label Angle
                if (label && Math.abs(angle) > 0.05) {
                    ctx.fillStyle = color;
                    ctx.font = '10px Inter';
                    const midX = gratingX + dx * 0.3;
                    const midY = cy + dy * 0.3;
                    ctx.fillText(label, midX, midY);
                }
            };

            // Central Max (n=0)
            const centerColor = mode === 'white' ? '#ffffff' : nmToRGB(wavelength);
            drawRay(0, centerColor, '');

            // Orders
            if (mode === 'monochromatic') {
                orders.forEach(o => {
                    drawRay(o.theta, o.color, `n=${o.n}`);
                    drawRay(-o.theta, o.color, `n=${o.n}`);
                });
            } else {
                orders.forEach(o => {
                    // Draw bounding rays for spectrum
                    drawRay(o.thetaStart, '#a855f7', ''); // Violet
                    drawRay(o.thetaEnd, '#ef4444', `n=${o.n}`);   // Red
                    drawRay(-o.thetaStart, '#a855f7', '');
                    drawRay(-o.thetaEnd, '#ef4444', `n=${o.n}`);
                });
            }


            // --- 2. Screen View (Bottom) ---
            const screenTop = GEOM_HEIGHT;
            const screenCenterY = screenTop + SCREEN_HEIGHT/2;
            
            // Background
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, screenTop, w, SCREEN_HEIGHT);
            
            // Screen Frame
            ctx.strokeStyle = '#334155';
            ctx.lineWidth = 4;
            ctx.strokeRect(0, screenTop, w, SCREEN_HEIGHT);
            
            // Ruler
            ctx.fillStyle = '#64748b';
            ctx.font = '10px monospace';
            ctx.textAlign = 'center';
            for (let x = 0; x <= w; x += 100) {
                const distFromCenterM = ((x - screenX) / SCREEN_DIST_PX) * screenDist * Math.tan(45 * Math.PI/180); // Roughly map px to meters?
                // Visual mapping: The screenX in geom view corresponds to center of screen view
                // Let's align them physically. 
                // In Geom view, screen is a vertical line at screenX. 
                // In Screen view, we are looking AT that line.
                // Center of Screen View corresponds to y=cy in Geom View.
                // Vertical pos in Geom View (y) maps to Horizontal pos in Screen View (x)? No, let's keep orientation.
                // Geom View is Top-Down. Screen is Side View strip? 
                // Standard: Geometry is Top-Down. Screen shows horizontal spread.
                // Let's map Geom Y-displacement (dy) to Screen X-displacement.
                
                // y_geom = cy + tan(theta)*D_px. 
                // Screen View X center = w/2.
                // Deviation from center = y_geom - cy.
                
                // Tick marks
                ctx.fillRect(x, screenTop + SCREEN_HEIGHT - 5, 1, 5);
            }

            const drawSpectralLine = (theta, color, intensity, width = 4) => {
                const tanTheta = Math.tan(theta);
                const dyPixels = tanTheta * SCREEN_DIST_PX; 
                // This dyPixels is vertical displacement in Geom view.
                // Map this to horizontal displacement in Screen view centered at w/2
                
                const screenXPos = (w / 2) + dyPixels;
                
                if (screenXPos > 0 && screenXPos < w) {
                    // Glow
                    const gradient = ctx.createLinearGradient(screenXPos - width, 0, screenXPos + width, 0);
                    gradient.addColorStop(0, 'rgba(0,0,0,0)');
                    gradient.addColorStop(0.5, color);
                    gradient.addColorStop(1, 'rgba(0,0,0,0)');
                    
                    ctx.fillStyle = gradient;
                    ctx.globalAlpha = intensity;
                    ctx.fillRect(screenXPos - width, screenTop, width*2, SCREEN_HEIGHT);
                    ctx.globalAlpha = 1.0;
                }
            };

            // Central Maximum
            drawSpectralLine(0, centerColor, 1.0, 10);

            // Orders
            if (mode === 'monochromatic') {
                orders.forEach(o => {
                    drawSpectralLine(o.theta, o.color, 0.8 / (o.n * 0.5)); // Fainter higher orders
                    drawSpectralLine(-o.theta, o.color, 0.8 / (o.n * 0.5));
                });
            } else {
                orders.forEach(o => {
                    // Draw full spectrum gradient for each order
                    // Loop from 400 to 700 nm
                    const steps = 30;
                    const d_m = 1e-3 / linesPerMm;
                    
                    for (let lam = 400; lam <= 700; lam += 10) {
                        const lambda = lam * 1e-9;
                        const sinT = (o.n * lambda) / d_m;
                        if (sinT <= 1) {
                            const theta = Math.asin(sinT);
                            const col = nmToRGB(lam);
                            // Draw thin line
                            drawSpectralLine(theta, col, 0.5 / o.n, 3);
                            drawSpectralLine(-theta, col, 0.5 / o.n, 3);
                        }
                    }
                });
            }
        };

        useEffect(() => {
            // Recalculate orders when inputs change (handled in logic effect)
            // Just trigger draw
            draw(); // Draw whenever renders
        }, [orders]); // Redraw when orders updated

        // Init icons
        useEffect(() => {
            if (window.lucide) window.lucide.createIcons();
        });

        // Current d calculation for display
        const d_microns = 1000 / linesPerMm;

        return (
            <div className="min-h-screen bg-slate-900 text-slate-200 font-sans pb-12">
                <nav className="bg-slate-800 border-b border-slate-700 px-6 py-4 flex items-center justify-between sticky top-0 z-10">
                    <div className="flex items-center space-x-3">
                        <div className="bg-indigo-500/20 p-2 rounded-lg">
                            <i data-lucide="rainbow" className="w-6 h-6 text-indigo-400"></i>
                        </div>
                        <h1 className="text-xl font-bold text-white tracking-wide">Diffraction Grating Lab</h1>
                    </div>
                    <div className="text-xs text-slate-400 font-mono bg-slate-900 px-3 py-1 rounded-full border border-slate-700">
                        Topic: Wave Optics
                    </div>
                </nav>

                <main className="max-w-6xl mx-auto p-4 md:p-6 grid grid-cols-1 lg:grid-cols-12 gap-8">
                    
                    {/* Left: Simulation Canvas */}
                    <div className="lg:col-span-8 flex flex-col gap-6">
                        <div className="bg-slate-950 rounded-2xl border border-slate-700 relative overflow-hidden shadow-2xl">
                            <canvas 
                                ref={canvasRef} 
                                width={CANVAS_WIDTH} 
                                height={TOTAL_HEIGHT}
                                className="w-full h-auto"
                            />
                            
                            <div className="absolute top-4 left-4 bg-slate-900/80 px-3 py-1 rounded border border-slate-700 text-xs text-slate-400 font-bold uppercase pointer-events-none">
                                Top View (Geometry)
                            </div>
                            <div className="absolute top-[260px] left-4 bg-slate-900/80 px-3 py-1 rounded border border-slate-700 text-xs text-slate-400 font-bold uppercase pointer-events-none">
                                Screen View
                            </div>
                        </div>
                    </div>

                    {/* Right: Controls & Data */}
                    <div className="lg:col-span-4 space-y-6">
                        
                        <div className="bg-slate-800 p-6 rounded-2xl border border-slate-700 space-y-6">
                            <h2 className="text-white font-bold mb-2 flex items-center">
                                <i data-lucide="sliders" className="w-5 h-5 mr-2 text-indigo-400"></i>
                                Setup
                            </h2>

                            {/* Light Source Mode */}
                            <div className="flex p-1 bg-slate-900 rounded-lg border border-slate-700">
                                <button 
                                    onClick={() => setMode('monochromatic')}
                                    className={`flex-1 py-2 rounded text-xs font-bold transition-all ${mode === 'monochromatic' ? 'bg-indigo-600 text-white' : 'text-slate-400 hover:text-white'}`}
                                >
                                    Laser (Mono)
                                </button>
                                <button 
                                    onClick={() => setMode('white')}
                                    className={`flex-1 py-2 rounded text-xs font-bold transition-all ${mode === 'white' ? 'bg-indigo-600 text-white' : 'text-slate-400 hover:text-white'}`}
                                >
                                    White Light
                                </button>
                            </div>

                            {/* Wavelength Slider (Only if Mono) */}
                            {mode === 'monochromatic' && (
                                <div className="animate-in fade-in slide-in-from-top-2">
                                    <label className="flex justify-between text-xs font-bold mb-2" style={{color: nmToRGB(wavelength)}}>
                                        <span>Wavelength (λ)</span>
                                        <span>{wavelength} nm</span>
                                    </label>
                                    <div className="h-2 w-full rounded-lg mb-2" style={{background: 'linear-gradient(to right, #4b0082, #0000ff, #00ff00, #ffff00, #ff7f00, #ff0000)'}}></div>
                                    <input 
                                        type="range" min="400" max="700" step="1" 
                                        value={wavelength} onChange={(e) => setWavelength(Number(e.target.value))}
                                        className="w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer slider-thumb" 
                                    />
                                </div>
                            )}

                            {/* Grating Density */}
                            <div>
                                <label className="flex justify-between text-xs font-bold text-slate-300 mb-2">
                                    <span>Grating Density (N)</span>
                                    <span className="text-white">{linesPerMm} lines/mm</span>
                                </label>
                                <input 
                                    type="range" min="100" max="1000" step="50" 
                                    value={linesPerMm} onChange={(e) => setLinesPerMm(Number(e.target.value))}
                                    className="w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer slider-thumb" 
                                />
                                <div className="flex justify-between text-[10px] text-slate-500 mt-1">
                                    <span>Coarse</span>
                                    <span>Fine</span>
                                </div>
                            </div>
                        </div>

                        {/* Analysis Card */}
                        <div className="bg-indigo-900/10 border border-indigo-500/20 p-5 rounded-2xl">
                            <h3 className="text-indigo-300 font-bold text-sm mb-3 flex items-center">
                                <i data-lucide="calculator" className="w-4 h-4 mr-2"></i> Grating Formula
                            </h3>
                            
                            <div className="space-y-3 font-mono text-sm">
                                <div className="flex justify-between border-b border-indigo-500/20 pb-2">
                                    <span className="text-slate-400">d = 1/N</span>
                                    <span className="text-white">{d_microns.toFixed(2)} μm</span>
                                </div>
                                
                                {orders.length > 0 && mode === 'monochromatic' && (
                                    <div className="bg-slate-900/50 p-3 rounded-lg border border-slate-700/50">
                                        <div className="text-[10px] text-slate-500 uppercase mb-2">1st Order Angle (n=1)</div>
                                        <div className="flex justify-between items-baseline">
                                            <span className="text-xs text-indigo-300">θ = asin(λ/d)</span>
                                            <span className="text-xl font-bold text-white">
                                                {((Math.asin((wavelength*1e-9)/(1e-3/linesPerMm)) * 180/Math.PI) || 0).toFixed(1)}°
                                            </span>
                                        </div>
                                    </div>
                                )}
                            </div>

                            <p className="text-xs text-slate-300 leading-relaxed border-t border-indigo-500/30 pt-3 mt-3">
                                <strong>Observation:</strong> Higher line density ($N$) means smaller slit spacing ($d$). This causes the diffraction angle ($\theta$) to increase, spreading the spectrum wider!
                            </p>
                        </div>

                    </div>

                </main>
            </div>
        );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
</script>
</body>
</html>
