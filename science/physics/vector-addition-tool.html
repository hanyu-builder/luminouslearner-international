import React, { useState, useEffect, useRef } from 'react';
import { Plus, Trash2, ArrowRight, Settings, Grid, Maximize, RotateCcw } from 'lucide-react';

const VectorAdditionTool = () => {
  // --- State ---
  const [vectors, setVectors] = useState([
    { id: 1, x: 50, y: 300, dx: 100, dy: -100, color: '#3b82f6', label: 'A' },
    { id: 2, x: 200, y: 300, dx: 150, dy: 0, color: '#10b981', label: 'B' }
  ]);
  const [mode, setMode] = useState('free'); // 'free' or 'chain'
  const [showResultant, setShowResultant] = useState(true);
  const [showComponents, setShowComponents] = useState(false);
  const [showGrid, setShowGrid] = useState(true);
  const [dragging, setDragging] = useState(null); // { id, type: 'head'|'body', startX, startY, originalX, originalY, originalDx, originalDy }

  const canvasRef = useRef(null);
  const containerRef = useRef(null);

  // --- Constants ---
  const GRID_SIZE = 40;
  const HEAD_SIZE = 10;
  const SNAP_DIST = 15;

  // --- Helpers ---
  const getMousePos = (e) => {
    const rect = canvasRef.current.getBoundingClientRect();
    return {
      x: e.clientX - rect.left,
      y: e.clientY - rect.top
    };
  };

  const getMagnitude = (dx, dy) => Math.sqrt(dx * dx + dy * dy);
  const getAngle = (dx, dy) => {
    let angle = Math.atan2(-dy, dx) * (180 / Math.PI); // -dy because canvas Y is inverted
    if (angle < 0) angle += 360;
    return angle;
  };

  // --- Interaction Handlers ---
  const handleMouseDown = (e) => {
    const { x, y } = getMousePos(e);
    
    // Check if clicking on any vector head or body
    // Reverse order to check top-most first
    for (let i = vectors.length - 1; i >= 0; i--) {
      const v = vectors[i];
      const headX = v.x + v.dx;
      const headY = v.y + v.dy;

      // Check Head
      if (Math.hypot(x - headX, y - headY) < 15) {
        setDragging({ id: v.id, type: 'head', offsetX: x - headX, offsetY: y - headY });
        return;
      }

      // Check Body (Tail)
      if (Math.hypot(x - v.x, y - v.y) < 15) {
        setDragging({ id: v.id, type: 'body', offsetX: x - v.x, offsetY: y - v.y });
        return;
      }
    }
  };

  const handleMouseMove = (e) => {
    if (!dragging) return;
    const { x, y } = getMousePos(e);

    setVectors(prev => prev.map(v => {
      if (v.id !== dragging.id) return v;

      if (dragging.type === 'body') {
        // Moving the whole vector
        if (mode === 'chain' && v.id !== prev[0].id) return v; // In chain mode, only move first vector
        
        let newX = x - dragging.offsetX;
        let newY = y - dragging.offsetY;
        
        // Grid Snap for tail
        if (Math.abs(newX % GRID_SIZE) < SNAP_DIST) newX = Math.round(newX / GRID_SIZE) * GRID_SIZE;
        if (Math.abs(newY % GRID_SIZE) < SNAP_DIST) newY = Math.round(newY / GRID_SIZE) * GRID_SIZE;

        return { ...v, x: newX, y: newY };
      } else {
        // Moving the head (changing magnitude/direction)
        let newDx = x - dragging.offsetX - v.x;
        let newDy = y - dragging.offsetY - v.y;
        
        // Grid Snap for head relative to tail
        const absHeadX = v.x + newDx;
        const absHeadY = v.y + newDy;
        
        if (Math.abs(absHeadX % GRID_SIZE) < SNAP_DIST) newDx = Math.round(absHeadX / GRID_SIZE) * GRID_SIZE - v.x;
        if (Math.abs(absHeadY % GRID_SIZE) < SNAP_DIST) newDy = Math.round(absHeadY / GRID_SIZE) * GRID_SIZE - v.y;

        return { ...v, dx: newDx, dy: newDy };
      }
    }));
  };

  const handleMouseUp = () => {
    setDragging(null);
  };

  const addVector = () => {
    const id = Date.now();
    const colors = ['#8b5cf6', '#f59e0b', '#ec4899', '#6366f1'];
    const color = colors[vectors.length % colors.length];
    setVectors([...vectors, { 
      id, 
      x: 50 + vectors.length * 20, 
      y: 350 - vectors.length * 20, 
      dx: 80, 
      dy: -80, 
      color, 
      label: String.fromCharCode(67 + vectors.length) // C, D, E...
    }]);
  };

  const removeVector = (id) => {
    setVectors(vectors.filter(v => v.id !== id));
  };

  // --- Rendering ---
  useEffect(() => {
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    const width = canvas.width;
    const height = canvas.height;

    // Clear
    ctx.clearRect(0, 0, width, height);

    // 1. Draw Grid
    if (showGrid) {
      ctx.strokeStyle = '#1e293b';
      ctx.lineWidth = 1;
      ctx.beginPath();
      for (let x = 0; x <= width; x += GRID_SIZE) { ctx.moveTo(x, 0); ctx.lineTo(x, height); }
      for (let y = 0; y <= height; y += GRID_SIZE) { ctx.moveTo(0, y); ctx.lineTo(width, y); }
      ctx.stroke();
    }

    // Prepare Vectors based on Mode
    let renderVectors = [...vectors];
    
    if (mode === 'chain' && renderVectors.length > 0) {
      // In chain mode, force positions
      let currentX = renderVectors[0].x;
      let currentY = renderVectors[0].y;
      
      renderVectors = renderVectors.map((v, i) => {
        if (i === 0) return v;
        const chainedV = { ...v, x: currentX, y: currentY };
        currentX += v.dx;
        currentY += v.dy;
        return chainedV;
      });
    }

    // 2. Draw Vectors
    const drawArrow = (fromX, fromY, dx, dy, color, label, isResultant = false) => {
      const toX = fromX + dx;
      const toY = fromY + dy;
      const angle = Math.atan2(dy, dx);
      const len = Math.sqrt(dx*dx + dy*dy);

      ctx.save();
      ctx.strokeStyle = color;
      ctx.fillStyle = color;
      ctx.lineWidth = isResultant ? 4 : 3;
      if (isResultant) ctx.setLineDash([10, 5]);

      // Shaft
      ctx.beginPath();
      ctx.moveTo(fromX, fromY);
      ctx.lineTo(toX, toY);
      ctx.stroke();

      // Head
      ctx.beginPath();
      ctx.moveTo(toX, toY);
      ctx.lineTo(toX - HEAD_SIZE * Math.cos(angle - Math.PI / 6), toY - HEAD_SIZE * Math.sin(angle - Math.PI / 6));
      ctx.lineTo(toX - HEAD_SIZE * Math.cos(angle + Math.PI / 6), toY - HEAD_SIZE * Math.sin(angle + Math.PI / 6));
      ctx.fill();

      // Label
      if (label) {
        ctx.font = 'bold 14px Inter';
        ctx.fillStyle = '#fff';
        ctx.strokeStyle = '#0f172a';
        ctx.lineWidth = 3;
        const midX = fromX + dx / 2;
        const midY = fromY + dy / 2;
        ctx.strokeText(label, midX + 10, midY - 10);
        ctx.fillText(label, midX + 10, midY - 10);
      }

      // Components
      if (showComponents && !isResultant) {
        ctx.setLineDash([4, 4]);
        ctx.lineWidth = 1;
        ctx.strokeStyle = `${color}80`; // transparent
        
        // X component
        ctx.beginPath(); ctx.moveTo(fromX, fromY); ctx.lineTo(fromX + dx, fromY); ctx.stroke();
        // Y component
        ctx.beginPath(); ctx.moveTo(fromX + dx, fromY); ctx.lineTo(toX, toY); ctx.stroke();
      }

      ctx.restore();
    };

    renderVectors.forEach(v => {
      drawArrow(v.x, v.y, v.dx, v.dy, v.color, v.label);
    });

    // 3. Draw Resultant
    if (showResultant && renderVectors.length > 0) {
      // Calculate total Rx, Ry
      let totalDx = 0;
      let totalDy = 0;
      renderVectors.forEach(v => {
        totalDx += v.dx;
        totalDy += v.dy;
      });

      // Start point depends on mode
      let startX = 0;
      let startY = 0;

      if (mode === 'chain') {
        startX = renderVectors[0].x;
        startY = renderVectors[0].y;
        // In chain mode, Resultant is from First Tail to Last Head
        drawArrow(startX, startY, totalDx, totalDy, '#ef4444', 'R', true);
      } else {
        // In free mode, where to draw resultant? 
        // Maybe just sum components from origin? Or average position?
        // Let's stick to: If Free Mode, calculate sum but draw it at a fixed place or near the center
        // Or better, force Chain Mode visually for Resultant?
        // Let's draw it ghosted from the first vector's tail just to show what it WOULD be
        startX = renderVectors[0].x;
        startY = renderVectors[0].y;
        
        // Only draw if vectors form a chain? No, just draw vector sum from origin of first vector
        // to show "If you added them up"
        drawArrow(startX, startY, totalDx, totalDy, '#ef4444', 'R', true);
      }
    }

  }, [vectors, mode, showResultant, showComponents, showGrid]);

  return (
    <div className="min-h-screen bg-slate-900 text-slate-200 font-sans">
      {/* Header */}
      <nav className="bg-slate-800 border-b border-slate-700 px-6 py-4 flex items-center justify-between sticky top-0 z-10">
        <div className="flex items-center space-x-3">
          <div className="bg-indigo-500/20 p-2 rounded-lg">
            <ArrowRight className="w-6 h-6 text-indigo-400" />
          </div>
          <h1 className="text-xl font-bold text-white tracking-wide">Vector Addition Tool</h1>
        </div>
        <div className="flex items-center gap-4">
           <div className="text-xs text-slate-400 font-mono bg-slate-900 px-3 py-1 rounded-full border border-slate-700 hidden sm:block">
            Topic: Mechanics
          </div>
        </div>
      </nav>

      <main className="max-w-7xl mx-auto p-4 md:p-6 grid grid-cols-1 lg:grid-cols-12 gap-6 h-[calc(100vh-80px)]">
        
        {/* Canvas Area */}
        <div className="lg:col-span-8 flex flex-col h-full">
          <div 
            ref={containerRef}
            className="bg-slate-950 rounded-xl border border-slate-700 flex-1 relative overflow-hidden shadow-2xl cursor-crosshair"
          >
            <div className="absolute top-4 left-4 flex gap-2 pointer-events-none">
                <span className={`px-2 py-1 rounded text-xs font-bold ${mode === 'chain' ? 'bg-indigo-600 text-white' : 'bg-slate-800 text-slate-400'}`}>
                    {mode === 'chain' ? 'ðŸ”— Head-to-Tail Mode' : 'ðŸ”“ Free Mode'}
                </span>
            </div>
            <canvas
              ref={canvasRef}
              width={800}
              height={600}
              onMouseDown={handleMouseDown}
              onMouseMove={handleMouseMove}
              onMouseUp={handleMouseUp}
              onMouseLeave={handleMouseUp}
              className="w-full h-full touch-none"
            />
          </div>
          <div className="mt-4 flex flex-wrap gap-4 items-center justify-between bg-slate-800 p-4 rounded-xl border border-slate-700">
             <div className="flex gap-2">
                <button 
                    onClick={() => setMode(mode === 'free' ? 'chain' : 'free')}
                    className={`flex items-center px-4 py-2 rounded-lg text-sm font-bold transition-colors ${mode === 'chain' ? 'bg-indigo-600 text-white' : 'bg-slate-700 text-slate-300 hover:bg-slate-600'}`}
                >
                    {mode === 'free' ? 'Snap to Chain' : 'Unlink Vectors'}
                </button>
                <button 
                    onClick={() => setShowResultant(!showResultant)}
                    className={`flex items-center px-4 py-2 rounded-lg text-sm font-bold transition-colors ${showResultant ? 'bg-red-500/20 text-red-400 border border-red-500/50' : 'bg-slate-700 text-slate-300 hover:bg-slate-600'}`}
                >
                    Resultant (R)
                </button>
                <button 
                    onClick={() => setShowComponents(!showComponents)}
                    className={`flex items-center px-4 py-2 rounded-lg text-sm font-bold transition-colors ${showComponents ? 'bg-emerald-500/20 text-emerald-400 border border-emerald-500/50' : 'bg-slate-700 text-slate-300 hover:bg-slate-600'}`}
                >
                    Components (x,y)
                </button>
             </div>
             <button 
                onClick={addVector}
                className="flex items-center px-4 py-2 rounded-lg text-sm font-bold bg-blue-600 text-white hover:bg-blue-500 transition-colors"
             >
                <Plus className="w-4 h-4 mr-2" /> Add Vector
             </button>
          </div>
        </div>

        {/* Sidebar Controls */}
        <div className="lg:col-span-4 flex flex-col gap-4 h-full overflow-y-auto">
            
            {/* Vector List */}
            <div className="bg-slate-800 rounded-xl border border-slate-700 p-4 flex-1">
                <h2 className="text-white font-bold mb-4 flex items-center">
                    <Settings className="w-4 h-4 mr-2 text-slate-400" /> Vector Data
                </h2>
                <div className="space-y-3">
                    {vectors.map((v, i) => (
                        <div key={v.id} className="bg-slate-900/50 p-3 rounded-lg border border-slate-700/50 hover:border-slate-600 transition-colors">
                            <div className="flex justify-between items-center mb-2">
                                <div className="flex items-center">
                                    <div className="w-3 h-3 rounded-full mr-2" style={{backgroundColor: v.color}}></div>
                                    <span className="font-bold text-white">Vector {v.label}</span>
                                </div>
                                {vectors.length > 1 && (
                                    <button onClick={() => removeVector(v.id)} className="text-slate-500 hover:text-red-400">
                                        <Trash2 className="w-4 h-4" />
                                    </button>
                                )}
                            </div>
                            <div className="grid grid-cols-2 gap-4 text-xs font-mono text-slate-400">
                                <div>
                                    <span className="block text-slate-500 text-[10px] uppercase">Magnitude</span>
                                    <span className="text-white text-sm">{getMagnitude(v.dx, v.dy).toFixed(1)}</span>
                                </div>
                                <div>
                                    <span className="block text-slate-500 text-[10px] uppercase">Angle</span>
                                    <span className="text-white text-sm">{getAngle(v.dx, v.dy).toFixed(1)}Â°</span>
                                </div>
                                <div>
                                    <span className="block text-slate-500 text-[10px] uppercase">X-Comp</span>
                                    <span className="text-blue-300">{v.dx.toFixed(0)}</span>
                                </div>
                                <div>
                                    <span className="block text-slate-500 text-[10px] uppercase">Y-Comp</span>
                                    <span className="text-blue-300">{(-v.dy).toFixed(0)}</span>
                                </div>
                            </div>
                        </div>
                    ))}
                </div>
            </div>

            {/* Total Resultant Info */}
            {showResultant && (
                <div className="bg-red-900/10 border border-red-500/20 p-4 rounded-xl">
                    <h3 className="text-red-400 font-bold mb-3 text-sm flex items-center">
                        <Maximize className="w-4 h-4 mr-2" /> Total Resultant (R)
                    </h3>
                    {(() => {
                        let rx = 0;
                        let ry = 0;
                        vectors.forEach(v => { rx += v.dx; ry += v.dy; });
                        const rMag = getMagnitude(rx, ry);
                        const rAng = getAngle(rx, ry);
                        
                        return (
                            <div className="grid grid-cols-2 gap-4 font-mono text-sm">
                                <div>
                                    <span className="block text-red-500/70 text-xs">Magnitude |R|</span>
                                    <span className="text-white text-xl font-bold">{rMag.toFixed(1)}</span>
                                </div>
                                <div>
                                    <span className="block text-red-500/70 text-xs">Direction Î¸</span>
                                    <span className="text-white text-xl font-bold">{rAng.toFixed(1)}Â°</span>
                                </div>
                                <div className="col-span-2 pt-2 border-t border-red-500/20 text-xs text-red-300">
                                    R = ({rx.toFixed(0)}, {(-ry).toFixed(0)})
                                </div>
                            </div>
                        );
                    })()}
                </div>
            )}

            <div className="bg-slate-800 p-4 rounded-xl border border-slate-700 text-xs text-slate-400">
                <p><strong>Instructions:</strong></p>
                <ul className="list-disc pl-4 space-y-1 mt-1">
                    <li>Drag the <strong>Tail</strong> to move a vector.</li>
                    <li>Drag the <strong>Head</strong> (Arrow) to change size & direction.</li>
                    <li>Use <strong>Snap to Chain</strong> to automatically connect vectors Head-to-Tail.</li>
                </ul>
            </div>

        </div>

      </main>
    </div>
  );
};

export default VectorAdditionTool;
