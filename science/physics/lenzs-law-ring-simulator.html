<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lenz's Law Lab | Luminous Learner</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@0.263.1"></script>

    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;700;900&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">

    <style>
        body { font-family: 'Inter', sans-serif; background-color: #0f172a; color: #e2e8f0; }
        .canvas-container { cursor: grab; }
        .canvas-container:active { cursor: grabbing; }
        .meter-bg {
            background: linear-gradient(90deg, #ef4444 0%, #1e293b 50%, #10b981 100%);
        }
    </style>
</head>
<body>

<div id="root"></div>

<script type="text/babel">
    const { useState, useEffect, useRef } = React;

    const CANVAS_WIDTH = 800;
    const CANVAS_HEIGHT = 500;
    const CENTER_X = CANVAS_WIDTH / 2;
    const COIL_Y = CANVAS_HEIGHT / 2;
    const COIL_RADIUS = 100;
    const MAGNET_W = 60;
    const MAGNET_H = 140;

    const App = () => {
        // --- State ---
        const [magnetY, setMagnetY] = useState(100); // Top
        const [polarity, setPolarity] = useState('N_DOWN'); // 'N_DOWN' or 'S_DOWN'
        const [isDropping, setIsDropping] = useState(false);
        const [showField, setShowField] = useState(true);
        const [showForces, setShowForces] = useState(true);
        
        // Physics Realtime
        const [inducedCurrent, setInducedCurrent] = useState(0); // + (CCW) or - (CW)
        const [magnetVel, setMagnetVel] = useState(0);

        const canvasRef = useRef(null);
        const requestRef = useRef();
        const physicsRef = useRef({
            y: 100,
            v: 0,
            dragging: false
        });

        // --- Physics Logic ---
        const calculateInduction = (y, v) => {
            const dy = y - COIL_Y;
            // Gaussian derivative for flux change rate approximation
            const dist = (dy / 100);
            const rateOfChange = -dist * Math.exp(-(dist * dist)) * 5; 
            
            // EMF ~ - rate * v
            let emf = -rateOfChange * v;
            
            // Adjust for polarity
            if (polarity === 'S_DOWN') emf = -emf;
            
            return emf;
        };

        const resetSim = () => {
            setIsDropping(false);
            physicsRef.current = { y: 100, v: 0, dragging: false };
            setMagnetY(100);
            setMagnetVel(0);
            setInducedCurrent(0);
        };

        const dropMagnet = () => {
            if (isDropping) return;
            setIsDropping(true);
            physicsRef.current.v = 0; 
        };

        const loop = () => {
            const state = physicsRef.current;
            
            if (isDropping) {
                const G = 0.5; // Gravity
                
                // Induction damping
                const dy = state.y - COIL_Y;
                const sensitivity = (dy/100) * Math.exp(-(dy*dy)/(100*100));
                const brakingForce = 2.0 * (sensitivity * sensitivity) * state.v;
                
                state.v += G - brakingForce; 
                state.y += state.v;

                // Stop if fell off screen
                if (state.y > CANVAS_HEIGHT + 200) {
                    setIsDropping(false);
                    resetSim();
                    return;
                }
            }
            
            // Update Current Visualization
            const current = calculateInduction(state.y, state.v);
            
            // Sync to React State (Triggers Render)
            setMagnetY(state.y);
            setMagnetVel(state.v);
            setInducedCurrent(current);

            requestRef.current = requestAnimationFrame(loop);
        };

        // Handle Drag Velocity Calculation
        const prevYRef = useRef(100);
        useEffect(() => {
            if (!isDropping) {
                const dy = physicsRef.current.y - prevYRef.current;
                physicsRef.current.v = dy; 
                prevYRef.current = physicsRef.current.y;
            }
        });

        // Start/Stop Loop
        useEffect(() => {
            requestRef.current = requestAnimationFrame(loop);
            return () => cancelAnimationFrame(requestRef.current);
        }, [isDropping, polarity]);

        // --- Interaction ---
        const handleMouseDown = (e) => {
            if (isDropping) return;
            const rect = canvasRef.current.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Hit test magnet
            if (Math.abs(x - CENTER_X) < MAGNET_W/2 + 20 && Math.abs(y - physicsRef.current.y) < MAGNET_H/2 + 20) {
                physicsRef.current.dragging = true;
            }
        };

        const handleMouseMove = (e) => {
            if (physicsRef.current.dragging) {
                const rect = canvasRef.current.getBoundingClientRect();
                const y = e.clientY - rect.top;
                physicsRef.current.y = y;
            }
        };

        const handleMouseUp = () => {
            physicsRef.current.dragging = false;
        };

        // --- Rendering Helpers ---
        const drawArrowHead = (ctx, px, py, vx, vy) => {
            ctx.beginPath();
            ctx.moveTo(px + vx, py + vy); // Tip
            ctx.lineTo(px - vy*0.5, py + vx*0.5); // Back 1
            ctx.lineTo(px + vy*0.5, py - vx*0.5); // Back 2
            ctx.fill();
        };

        const drawCurrentArrows = (ctx, x, y, rx, ry, dir, color) => {
            ctx.fillStyle = color;
            for (let i = 1; i <= 3; i++) {
                const angle = Math.PI * (i/4); // 45, 90, 135
                const px = x + rx * Math.cos(angle);
                const py = y + ry * Math.sin(angle);
                
                let tx = -rx * Math.sin(angle);
                let ty = ry * Math.cos(angle);
                
                const len = Math.sqrt(tx*tx + ty*ty);
                tx = (tx/len) * 15 * dir;
                ty = (ty/len) * 15 * dir;

                drawArrowHead(ctx, px, py, tx, ty);
            }
        };

        const drawArrow = (ctx, x, y, dx, dy, color, label) => {
            ctx.strokeStyle = color;
            ctx.fillStyle = color;
            ctx.lineWidth = 3;
            
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x + dx, y + dy);
            ctx.stroke();
            
            const angle = Math.atan2(dy, dx);
            ctx.beginPath();
            ctx.moveTo(x + dx, y + dy);
            ctx.lineTo(x + dx - 10 * Math.cos(angle - Math.PI/6), y + dy - 10 * Math.sin(angle - Math.PI/6));
            ctx.lineTo(x + dx - 10 * Math.cos(angle + Math.PI/6), y + dy - 10 * Math.sin(angle + Math.PI/6));
            ctx.fill();
            
            if (label) {
                ctx.font = 'bold 12px sans-serif';
                ctx.fillText(label, x + dx + 10, y + dy);
            }
        };

        const drawFieldLines = (ctx, x, y, pol) => {
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 2;
            const numLines = 6;
            const w = MAGNET_W;
            const h = MAGNET_H;
            const isNDown = pol === 'N_DOWN';
            
            for(let i=1; i<=numLines/2; i++) {
                const offset = i * 40;
                
                ctx.beginPath();
                ctx.moveTo(x + w/4, y - h/2 + 5);
                ctx.bezierCurveTo(x + w + offset, y - h, x + w + offset, y + h, x + w/4, y + h/2 - 5);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(x - w/4, y - h/2 + 5);
                ctx.bezierCurveTo(x - w - offset, y - h, x - w - offset, y + h, x - w/4, y + h/2 - 5);
                ctx.stroke();
                
                const midY = y;
                const midX = x + w + offset*0.75;
                const arrowDir = isNDown ? -1 : 1; 
                
                ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                drawArrowHead(ctx, midX, midY, 0, arrowDir * 10);
                drawArrowHead(ctx, x - (midX-x), midY, 0, arrowDir * 10);
            }
        };

        const drawBulb = (ctx, x, y, intensity) => {
            ctx.strokeStyle = '#b45309';
            ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(x - 40, y); ctx.lineTo(x, y); ctx.stroke();
            
            const alpha = Math.min(1, intensity);
            const r = 20;
            
            if (alpha > 0) {
                const grad = ctx.createRadialGradient(x, y, r*0.5, x, y, r*3);
                grad.addColorStop(0, `rgba(250, 204, 21, ${alpha})`);
                grad.addColorStop(1, 'rgba(250, 204, 21, 0)');
                ctx.fillStyle = grad;
                ctx.beginPath(); ctx.arc(x, y, r*3, 0, Math.PI*2); ctx.fill();
            }
            
            ctx.fillStyle = `rgba(255, 255, 255, 0.3)`;
            ctx.strokeStyle = '#fff';
            ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill(); ctx.stroke();
            
            ctx.strokeStyle = alpha > 0.1 ? '#fef08a' : '#57534e';
            ctx.beginPath(); ctx.moveTo(x-5, y+10); ctx.lineTo(x-5, y-5); ctx.lineTo(x+5, y-5); ctx.lineTo(x+5, y+10); ctx.stroke();
        };

        const drawMagnet = (ctx, x, y, pol) => {
            const w = MAGNET_W;
            const h = MAGNET_H;
            const topColor = pol === 'N_DOWN' ? '#3b82f6' : '#ef4444';
            const botColor = pol === 'N_DOWN' ? '#ef4444' : '#3b82f6';
            const topText = pol === 'N_DOWN' ? 'S' : 'N';
            const botText = pol === 'N_DOWN' ? 'N' : 'S';

            ctx.fillStyle = topColor;
            ctx.fillRect(x - w/2, y - h/2, w, h/2);
            ctx.fillStyle = botColor;
            ctx.fillRect(x - w/2, y, w, h/2);
            
            ctx.fillStyle = 'white';
            ctx.font = 'bold 20px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(topText, x, y - h/4);
            ctx.fillText(botText, x, y + h/4);
            
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 1;
            ctx.strokeRect(x - w/2, y - h/2, w, h);
        };

        // --- Main Draw Function ---
        const draw = () => {
            const ctx = canvasRef.current?.getContext('2d');
            if (!ctx) return;

            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            const my = magnetY;
            const cx = CENTER_X;
            const cy = COIL_Y;

            // 1. Draw Field Lines (Behind)
            if (showField) {
                drawFieldLines(ctx, cx, my, polarity);
            }

            // 2. Draw Coil (Back part)
            ctx.beginPath();
            ctx.ellipse(cx, cy, COIL_RADIUS, COIL_RADIUS * 0.4, 0, Math.PI, 2*Math.PI);
            ctx.lineWidth = 12;
            ctx.strokeStyle = '#334155';
            ctx.stroke();
            ctx.lineWidth = 8;
            ctx.strokeStyle = '#b45309';
            ctx.stroke();

            // 3. Draw Magnet
            drawMagnet(ctx, cx, my, polarity);

            // 4. Draw Coil (Front part)
            ctx.beginPath();
            ctx.ellipse(cx, cy, COIL_RADIUS, COIL_RADIUS * 0.4, 0, 0, Math.PI);
            ctx.lineWidth = 12;
            ctx.strokeStyle = '#334155';
            ctx.stroke();
            ctx.lineWidth = 8;
            ctx.strokeStyle = '#b45309';
            ctx.stroke();

            // 5. Draw Induced Current
            if (Math.abs(inducedCurrent) > 0.5) {
                const intensity = Math.min(1, Math.abs(inducedCurrent) / 10);
                const color = 'rgba(250, 204, 21, ' + intensity + ')'; 
                const dir = inducedCurrent > 0 ? 1 : -1;
                
                drawCurrentArrows(ctx, cx, cy, COIL_RADIUS, COIL_RADIUS*0.4, dir, color);
                drawBulb(ctx, cx + COIL_RADIUS + 40, cy, intensity);
            } else {
                drawBulb(ctx, cx + COIL_RADIUS + 40, cy, 0);
            }
            
            // 6. Induced B-Field Indicator
            if (Math.abs(inducedCurrent) > 1.0) {
                const label = inducedCurrent > 0 ? "N" : "S";
                const color = inducedCurrent > 0 ? "#ef4444" : "#3b82f6";
                
                ctx.globalAlpha = Math.min(1, Math.abs(inducedCurrent)/10);
                ctx.fillStyle = color;
                ctx.font = 'bold 40px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(label, cx, cy); 
                ctx.globalAlpha = 1.0;
            }

            // 7. Force Vector
            if (showForces && Math.abs(inducedCurrent) > 1.0) {
                const fDir = -Math.sign(magnetVel);
                const fMag = Math.abs(inducedCurrent) * 5; 
                drawArrow(ctx, cx + MAGNET_W/2 + 20, my, 0, fDir * fMag, '#10b981', 'F_drag');
            }
        };

        // KEY FIX: Re-draw whenever state changes!
        useEffect(() => {
            draw();
        });

        useEffect(() => {
            if (window.lucide) window.lucide.createIcons();
        });

        return (
            <div className="min-h-screen bg-slate-900 text-slate-200 font-sans pb-12">
                <nav className="bg-slate-800 border-b border-slate-700 px-6 py-4 flex items-center justify-between sticky top-0 z-10">
                    <div className="flex items-center space-x-3">
                        <div className="bg-cyan-500/20 p-2 rounded-lg">
                            <i data-lucide="magnet" className="w-6 h-6 text-cyan-400"></i>
                        </div>
                        <h1 className="text-xl font-bold text-white tracking-wide">Lenz's Law Lab</h1>
                    </div>
                    <div className="text-xs text-slate-400 font-mono bg-slate-900 px-3 py-1 rounded-full border border-slate-700">
                        Topic: Electromagnetic Induction
                    </div>
                </nav>

                <main className="max-w-6xl mx-auto p-4 md:p-6 grid grid-cols-1 lg:grid-cols-12 gap-8">
                    
                    {/* Left: Simulation Canvas */}
                    <div className="lg:col-span-9 flex flex-col gap-6">
                        <div className="bg-slate-950 rounded-2xl border border-slate-700 p-1 shadow-2xl relative overflow-hidden h-[500px]">
                            <canvas 
                                ref={canvasRef} 
                                width={CANVAS_WIDTH} 
                                height={CANVAS_HEIGHT}
                                onMouseDown={handleMouseDown}
                                onMouseMove={handleMouseMove}
                                onMouseUp={handleMouseUp}
                                onMouseLeave={handleMouseUp}
                                className="w-full h-full object-contain bg-slate-950 rounded-xl canvas-container"
                            />
                            
                            <div className="absolute top-4 left-4 bg-slate-900/80 px-4 py-2 rounded-lg border border-slate-700 text-xs shadow-lg space-y-1">
                                <div className="text-slate-400">Induced Current</div>
                                <div className={`font-mono font-bold text-xl ${Math.abs(inducedCurrent) > 1 ? 'text-yellow-400' : 'text-white'}`}>
                                    {inducedCurrent > 1 ? "Counter-Clockwise" : inducedCurrent < -1 ? "Clockwise" : "None"}
                                </div>
                            </div>
                        </div>

                        {/* Controls */}
                        <div className="bg-slate-800 p-6 rounded-2xl border border-slate-700 flex flex-wrap gap-8 items-center justify-between">
                            
                            <div className="flex gap-4">
                                <button 
                                    onClick={() => setPolarity(p => p === 'N_DOWN' ? 'S_DOWN' : 'N_DOWN')}
                                    className="px-6 py-3 rounded-xl font-bold text-sm bg-slate-700 hover:bg-slate-600 transition-colors border border-slate-500 flex items-center gap-2"
                                >
                                    <i data-lucide="refresh-cw" className="w-4 h-4"></i>
                                    Flip Magnet ({polarity === 'N_DOWN' ? 'N-Down' : 'S-Down'})
                                </button>
                            </div>

                            <div className="flex gap-4">
                                <label className="flex items-center gap-2 cursor-pointer bg-slate-700/50 px-3 py-2 rounded-lg border border-slate-600 hover:bg-slate-700 transition">
                                    <input type="checkbox" checked={showField} onChange={() => setShowField(!showField)} className="rounded text-cyan-500 focus:ring-0 bg-slate-800 border-slate-500" />
                                    <span className="text-xs font-bold text-slate-300">Show Field</span>
                                </label>
                                <label className="flex items-center gap-2 cursor-pointer bg-slate-700/50 px-3 py-2 rounded-lg border border-slate-600 hover:bg-slate-700 transition">
                                    <input type="checkbox" checked={showForces} onChange={() => setShowForces(!showForces)} className="rounded text-emerald-500 focus:ring-0 bg-slate-800 border-slate-500" />
                                    <span className="text-xs font-bold text-slate-300">Show Forces</span>
                                </label>
                            </div>

                            <div className="flex gap-3">
                                <button 
                                    onClick={dropMagnet}
                                    disabled={isDropping}
                                    className={`px-8 py-3 rounded-xl font-bold flex items-center gap-2 transition-all shadow-lg ${isDropping ? 'bg-slate-700 text-slate-500 cursor-not-allowed' : 'bg-emerald-600 hover:bg-emerald-500 text-white'}`}
                                >
                                    <i data-lucide="arrow-down" className="w-5 h-5"></i> Drop
                                </button>
                                <button onClick={resetSim} className="px-4 py-3 bg-slate-700 hover:bg-slate-600 rounded-xl text-white font-bold transition-colors">
                                    <i data-lucide="rotate-ccw" className="w-5 h-5"></i>
                                </button>
                            </div>
                        </div>
                    </div>

                    {/* Right: Galvanometer & Info */}
                    <div className="lg:col-span-3 space-y-6">
                        
                        <div className="bg-slate-800 p-6 rounded-2xl border border-slate-700 flex flex-col items-center">
                            <h2 className="text-white font-bold mb-4 flex items-center w-full">
                                <i data-lucide="gauge" className="w-5 h-5 mr-2 text-indigo-400"></i>
                                Galvanometer
                            </h2>
                            
                            {/* Gauge Visual */}
                            <div className="relative w-full h-32 mb-2">
                                <div className="absolute bottom-0 w-full h-24 rounded-t-full border-t-8 border-slate-600 overflow-hidden bg-slate-900">
                                    {/* Tick Marks */}
                                    {[...Array(11)].map((_, i) => (
                                        <div key={i} className="absolute bottom-0 left-1/2 w-0.5 h-full bg-slate-600 origin-bottom" 
                                             style={{transform: `rotate(${(i-5)*15}deg)`}}>
                                        </div>
                                    ))}
                                    {/* Needle */}
                                    <div className="absolute bottom-0 left-1/2 w-1 h-20 bg-red-500 origin-bottom transition-transform duration-75 ease-linear"
                                         style={{transform: `rotate(${Math.max(-75, Math.min(75, inducedCurrent * 5))}deg)`}}>
                                    </div>
                                </div>
                                <div className="absolute bottom-0 left-1/2 -translate-x-1/2 translate-y-1/2 w-4 h-4 bg-slate-400 rounded-full border-2 border-slate-600"></div>
                            </div>
                            
                            <div className="flex justify-between w-full text-xs text-slate-500 font-mono px-4">
                                <span>-ve</span>
                                <span>0</span>
                                <span>+ve</span>
                            </div>
                        </div>

                        <div className="bg-emerald-900/10 border border-emerald-500/20 p-5 rounded-2xl">
                            <h3 className="text-emerald-300 font-bold text-sm mb-3 flex items-center">
                                <i data-lucide="lightbulb" className="w-4 h-4 mr-2"></i> How it works
                            </h3>
                            <div className="text-xs text-slate-300 leading-relaxed space-y-2">
                                <p>
                                    <strong>Approaching:</strong> As the N-pole falls towards the coil, magnetic flux increases. The coil creates an N-pole on top to <strong>repel</strong> it. (Current CCW)
                                </p>
                                <p>
                                    <strong>Leaving:</strong> As the N-pole falls away, flux decreases. The coil creates an S-pole on bottom to <strong>attract</strong> it back. (Current CW)
                                </p>
                                <p className="pt-2 border-t border-emerald-500/30 text-emerald-200 italic">
                                    Result: The magnet falls slower than gravity! (Magnetic Braking)
                                </p>
                            </div>
                        </div>

                    </div>

                </main>
            </div>
        );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
</script>
</body>
</html>
