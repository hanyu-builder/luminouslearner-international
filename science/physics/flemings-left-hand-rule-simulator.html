<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fleming's Left-Hand Rule Lab | Luminous Learner</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@0.263.1"></script>

    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;700;900&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">

    <style>
        body { font-family: 'Inter', sans-serif; background-color: #0f172a; color: #e2e8f0; }
        .canvas-container { cursor: move; }
        /* Custom scrollbar for controls */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #1e293b; }
        ::-webkit-scrollbar-thumb { background: #475569; border-radius: 3px; }
    </style>
</head>
<body>

<div id="root"></div>

<script type="text/babel">
    const { useState, useEffect, useRef } = React;

    const App = () => {
        // State
        const [mode, setMode] = useState('wire'); // 'wire' or 'solenoid'
        const [currentDir, setCurrentDir] = useState(1); // 1 = Out/Right, -1 = In/Left
        const [fieldDir, setFieldDir] = useState(1);   // 1 = N->S (Down/Back), -1 = S->N (Up/Forward)
        
        const [showHand, setShowHand] = useState(true);
        const [showVectors, setShowVectors] = useState(true);
        const [wireKick, setWireKick] = useState(0); // Animation state for wire jumping

        const mountRef = useRef(null);
        const sceneRef = useRef(null);
        const cameraRef = useRef(null);
        const rendererRef = useRef(null);
        const objectsRef = useRef({});
        const animationRef = useRef();

        // --- Three.js Setup ---
        useEffect(() => {
            const mount = mountRef.current;
            let width = mount.clientWidth;
            let height = mount.clientHeight;

            // Scene
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0f172a);
            scene.fog = new THREE.Fog(0x0f172a, 10, 60);
            sceneRef.current = scene;

            // Camera
            const camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 100);
            camera.position.set(8, 6, 12);
            camera.lookAt(0, 0, 0);
            cameraRef.current = camera;

            // Renderer
            const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(width, height);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            
            // CSS Fix
            renderer.domElement.style.width = '100%';
            renderer.domElement.style.height = '100%';
            renderer.domElement.style.display = 'block';
            
            mount.appendChild(renderer.domElement);
            rendererRef.current = renderer;

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(5, 10, 5);
            dirLight.castShadow = true;
            scene.add(dirLight);

            // Orbit Controls Logic
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };
            
            const onMouseDown = (e) => { isDragging = true; };
            const onMouseUp = (e) => { isDragging = false; };
            const onMouseMove = (e) => {
                if (isDragging) {
                    const deltaMove = {
                        x: e.offsetX - previousMousePosition.x,
                        y: e.offsetY - previousMousePosition.y
                    };
                    
                    const radius = camera.position.length();
                    let theta = Math.atan2(camera.position.x, camera.position.z);
                    let phi = Math.acos(camera.position.y / radius);
                    
                    theta -= deltaMove.x * 0.01;
                    phi -= deltaMove.y * 0.01;
                    phi = Math.max(0.1, Math.min(Math.PI - 0.1, phi));

                    camera.position.x = radius * Math.sin(phi) * Math.sin(theta);
                    camera.position.y = radius * Math.cos(phi);
                    camera.position.z = radius * Math.sin(phi) * Math.cos(theta);
                    camera.lookAt(0, 0, 0);
                }
                previousMousePosition = { x: e.offsetX, y: e.offsetY };
            };

            const canvas = renderer.domElement;
            canvas.addEventListener('mousedown', onMouseDown);
            canvas.addEventListener('mouseup', onMouseUp);
            canvas.addEventListener('mousemove', onMouseMove);
            canvas.addEventListener('mouseleave', onMouseUp);

            // Objects Init
            initSceneObjects();

            // Animation Loop
            const animate = () => {
                animationRef.current = requestAnimationFrame(animate);
                
                // Wire Kick Animation
                if (objectsRef.current.wireGroup) {
                    // Simple spring physics
                }

                renderer.render(scene, camera);
            };
            animate();

            // Resize Observer
            const resizeObserver = new ResizeObserver(() => {
                if (!mount) return;
                const newWidth = mount.clientWidth;
                const newHeight = mount.clientHeight;
                if (newWidth === 0 || newHeight === 0) return;
                camera.aspect = newWidth / newHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(newWidth, newHeight);
            });
            resizeObserver.observe(mount);

            return () => {
                resizeObserver.disconnect();
                cancelAnimationFrame(animationRef.current);
                if (mount && renderer.domElement) mount.removeChild(renderer.domElement);
            };
        }, []); // Only run once on mount

        // --- Scene Logic ---
        // This function needs to be outside useEffect or memoized to access 'mode' if called later
        // But here we call it from useEffect dependancy on 'mode'.
        
        // We need a separate useEffect to handle scene updates when state changes
        useEffect(() => {
             initSceneObjects();
        }, [mode]); // Re-init objects when mode changes

        const initSceneObjects = () => {
            const scene = sceneRef.current;
            if (!scene) return;
            
            // Clear
            while(scene.children.length > 0){ 
                const obj = scene.children[0];
                scene.remove(obj); 
            }
            // Re-add lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(5, 10, 5);
            scene.add(dirLight);

            // Container Group
            const content = new THREE.Group();
            scene.add(content);
            objectsRef.current.content = content;

            // 1. Magnets
            const magnetGeo = new THREE.BoxGeometry(4, 4, 1);
            
            // Front Magnet
            const frontMat = new THREE.MeshStandardMaterial({ color: 0xef4444 }); 
            const frontMag = new THREE.Mesh(magnetGeo, frontMat);
            frontMag.position.set(0, 0, 3.5);
            content.add(frontMag);
            
            // Back Magnet
            const backMat = new THREE.MeshStandardMaterial({ color: 0x3b82f6 }); 
            const backMag = new THREE.Mesh(magnetGeo, backMat);
            backMag.position.set(0, 0, -3.5);
            content.add(backMag);

            objectsRef.current.frontMag = frontMag;
            objectsRef.current.backMag = backMag;

            // 2. Wire Group
            const wireGroup = new THREE.Group();
            content.add(wireGroup);
            objectsRef.current.wireGroup = wireGroup;

            // The Wire (X-axis)
            const wireGeo = new THREE.CylinderGeometry(0.15, 0.15, 10, 16);
            const wireMat = new THREE.MeshStandardMaterial({ color: 0xf59e0b });
            const wire = new THREE.Mesh(wireGeo, wireMat);
            wire.rotation.z = Math.PI / 2;
            wireGroup.add(wire);

            // 3. Hand Model Placeholder
            const handGroup = new THREE.Group();
            content.add(handGroup);
            objectsRef.current.handGroup = handGroup;
            
            // Construct Hand
            const skinMat = new THREE.MeshStandardMaterial({ color: 0xfca5a5 });
            const palm = new THREE.Mesh(new THREE.BoxGeometry(1.5, 1.5, 0.5), skinMat);
            handGroup.add(palm);
            
            // Fingers
            // Thumb (Force) - Y axis
            const thumb = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 2, 16), skinMat);
            thumb.position.set(0, 1, 0);
            handGroup.add(thumb);
            
            // Index (Field) - Z axis
            const index = new THREE.Mesh(new THREE.CylinderGeometry(0.18, 0.18, 2), skinMat);
            index.rotation.x = Math.PI / 2;
            index.position.set(0, 0, 1); 
            handGroup.add(index);
            
            // Middle (Current) - X axis
            const middle = new THREE.Mesh(new THREE.CylinderGeometry(0.18, 0.18, 2), skinMat);
            middle.rotation.z = Math.PI / 2;
            middle.position.set(1, 0, 0); 
            handGroup.add(middle);
        };

        // --- Update Scene based on State ---
        useEffect(() => {
            const objs = objectsRef.current;
            if (!objs.content) return;

            // 1. Update Magnet Colors
            if (fieldDir === 1) {
                if(objs.backMag) objs.backMag.material.color.setHex(0xef4444); // Red N
                if(objs.frontMag) objs.frontMag.material.color.setHex(0x3b82f6); // Blue S
            } else {
                if(objs.backMag) objs.backMag.material.color.setHex(0x3b82f6);
                if(objs.frontMag) objs.frontMag.material.color.setHex(0xef4444);
            }

            // 2. Calculate Force Direction
            const forceY = -(currentDir * fieldDir);
            
            // 3. Update Wire Position (Kick effect)
            setWireKick(forceY);

            // 4. Update Vectors (Arrows)
            const wireG = objs.wireGroup;
            for (let i = wireG.children.length - 1; i >= 0; i--) {
                if (wireG.children[i].type === 'ArrowHelper') wireG.remove(wireG.children[i]);
            }

            if (showVectors) {
                // I Arrow (Yellow)
                const iDir = new THREE.Vector3(currentDir, 0, 0);
                const iOrigin = new THREE.Vector3(-currentDir * 3, 0, 0);
                const iArrow = new THREE.ArrowHelper(iDir, iOrigin, 2, 0xfacc15, 0.5, 0.3);
                wireG.add(iArrow);

                // B Field Arrows (Blue)
                const bDir = new THREE.Vector3(0, 0, fieldDir);
                const bOrigin = new THREE.Vector3(0, 0, -fieldDir * 3);
                const bArrow = new THREE.ArrowHelper(bDir, bOrigin, 6, 0x3b82f6, 0.5, 0.3);
                wireG.add(bArrow);

                // Force Arrow (Green)
                const fDir = new THREE.Vector3(0, forceY, 0);
                const fOrigin = new THREE.Vector3(0, 0, 0);
                const fArrow = new THREE.ArrowHelper(fDir, fOrigin, 3, 0x10b981, 0.6, 0.4);
                wireG.add(fArrow);
            }

            // 5. Update Hand Orientation
            const hand = objs.handGroup;
            if (hand) {
                hand.visible = showHand;
                
                const matrix = new THREE.Matrix4();
                
                matrix.makeBasis(
                    new THREE.Vector3(currentDir, 0, 0), 
                    new THREE.Vector3(0, forceY, 0),     
                    new THREE.Vector3(0, 0, fieldDir)    
                );
                
                hand.quaternion.setFromRotationMatrix(matrix);
            }

        }, [currentDir, fieldDir, showHand, showVectors, mode]);

        // Wire Kick Animation
        useEffect(() => {
            const wire = objectsRef.current.wireGroup;
            if (!wire) return;
            
            let frameId;
            const animateKick = () => {
                const targetY = wireKick * 1.5;
                wire.position.y += (targetY - wire.position.y) * 0.1;
                frameId = requestAnimationFrame(animateKick);
            };
            animateKick();
            return () => cancelAnimationFrame(frameId);
        }, [wireKick]);

        // Init icons
        useEffect(() => {
            if (window.lucide) window.lucide.createIcons();
        });

        const toggleDirection = () => {
            setCurrentDirection(prev => prev * -1);
        };

        return (
            <div className="min-h-screen bg-slate-900 text-slate-200 font-sans pb-12">
                <nav className="bg-slate-800 border-b border-slate-700 px-6 py-4 flex items-center justify-between sticky top-0 z-10">
                    <div className="flex items-center space-x-3">
                        <div className="bg-emerald-500/20 p-2 rounded-lg">
                            <i data-lucide="hand-metal" className="w-6 h-6 text-emerald-400"></i>
                        </div>
                        <h1 className="text-xl font-bold text-white tracking-wide">Fleming's Left-Hand Rule</h1>
                    </div>
                    <div className="text-xs text-slate-400 font-mono bg-slate-900 px-3 py-1 rounded-full border border-slate-700">
                        Topic: Electromagnetism
                    </div>
                </nav>

                <main className="max-w-6xl mx-auto p-4 md:p-6 grid grid-cols-1 lg:grid-cols-12 gap-8">
                    
                    {/* Left: 3D Simulation */}
                    <div className="lg:col-span-9 flex flex-col gap-6">
                        <div className="bg-slate-950 rounded-2xl border border-slate-700 p-1 shadow-2xl relative overflow-hidden h-[500px]" ref={mountRef}>
                            
                            {/* Overlay UI */}
                            <div className="absolute top-4 left-4 flex flex-col gap-2 pointer-events-none">
                                <div className="flex items-center gap-2">
                                    <span className="w-3 h-3 rounded-full bg-emerald-500"></span> 
                                    <span className="text-xs font-bold text-emerald-400">Force (Thumb)</span>
                                </div>
                                <div className="flex items-center gap-2">
                                    <span className="w-3 h-3 rounded-full bg-blue-500"></span> 
                                    <span className="text-xs font-bold text-blue-400">Field (First Finger)</span>
                                </div>
                                <div className="flex items-center gap-2">
                                    <span className="w-3 h-3 rounded-full bg-yellow-500"></span> 
                                    <span className="text-xs font-bold text-yellow-400">Current (Second Finger)</span>
                                </div>
                            </div>
                            
                            <div className="absolute bottom-4 left-4 bg-slate-900/80 px-4 py-2 rounded-lg border border-slate-700 text-xs text-slate-300 pointer-events-none">
                                Left Click + Drag to <strong>Rotate</strong> View
                            </div>
                        </div>
                    </div>

                    {/* Right: Controls */}
                    <div className="lg:col-span-3 space-y-6">
                        
                        <div className="bg-slate-800 p-6 rounded-2xl border border-slate-700 space-y-6">
                            <h2 className="text-white font-bold mb-4 flex items-center">
                                <i data-lucide="settings-2" className="w-5 h-5 mr-2 text-emerald-400"></i>
                                Controls
                            </h2>

                            {/* Current Control */}
                            <div>
                                <label className="text-xs font-bold text-yellow-400 mb-2 block flex justify-between">
                                    Current ($I$) Direction
                                    <span>{currentDirection > 0 ? "Right" : "Left"}</span>
                                </label>
                                <button 
                                    onClick={toggleDirection}
                                    className="w-full py-3 rounded-xl font-bold flex items-center justify-center gap-2 transition-all bg-yellow-600 hover:bg-yellow-500 text-white shadow-lg"
                                >
                                    <i data-lucide="arrow-left-right" className="w-5 h-5"></i> Flip Current
                                </button>
                            </div>

                            {/* Field Control */}
                            <div>
                                <label className="text-xs font-bold text-blue-400 mb-2 block flex justify-between">
                                    Field ($B$) Direction
                                    <span>{fieldDir > 0 ? "Out (Front)" : "In (Back)"}</span>
                                </label>
                                <button 
                                    onClick={() => setFieldDir(p => p * -1)}
                                    className="w-full py-3 rounded-xl font-bold flex items-center justify-center gap-2 transition-all bg-blue-600 hover:bg-blue-500 text-white shadow-lg"
                                >
                                    <i data-lucide="refresh-cw" className="w-5 h-5"></i> Flip Magnets
                                </button>
                            </div>

                            {/* Toggles */}
                            <div className="space-y-3 pt-4 border-t border-slate-700">
                                <label className="flex items-center justify-between p-3 rounded-lg bg-slate-700/50 cursor-pointer hover:bg-slate-700 transition-colors">
                                    <span className="text-sm font-bold text-slate-300">Show Hand</span>
                                    <input type="checkbox" checked={showHand} onChange={() => setShowHand(!showHand)} className="w-5 h-5 rounded text-emerald-500 focus:ring-0" />
                                </label>
                                <label className="flex items-center justify-between p-3 rounded-lg bg-slate-700/50 cursor-pointer hover:bg-slate-700 transition-colors">
                                    <span className="text-sm font-bold text-slate-300">Show Vectors</span>
                                    <input type="checkbox" checked={showVectors} onChange={() => setShowVectors(!showVectors)} className="w-5 h-5 rounded text-blue-500 focus:ring-0" />
                                </label>
                            </div>
                        </div>

                        <div className="bg-emerald-900/10 border border-emerald-500/20 p-5 rounded-2xl">
                            <h3 className="text-emerald-300 font-bold text-sm mb-3 flex items-center">
                                <i data-lucide="info" className="w-4 h-4 mr-2"></i> Mnemonic
                            </h3>
                            <ul className="text-xs text-slate-300 leading-relaxed space-y-2 font-mono">
                                <li><strong>ThuMb</strong> = <strong>M</strong>otion (Force)</li>
                                <li><strong>First</strong> Finger = <strong>F</strong>ield</li>
                                <li><strong>SeCond</strong> Finger = <strong>C</strong>urrent</li>
                            </ul>
                        </div>

                    </div>

                </main>
            </div>
        );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
</script>
</body>
</html>
