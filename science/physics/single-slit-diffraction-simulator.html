<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Single Slit Diffraction Lab | Luminous Learner</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@0.263.1"></script>

    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;700;900&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">

    <style>
        body { font-family: 'Inter', sans-serif; background-color: #0f172a; color: #e2e8f0; }
        .slider-thumb::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none; width: 16px; height: 16px;
            border-radius: 50%; cursor: pointer; border: 2px solid #ffffff;
        }
        canvas { image-rendering: pixelated; }
    </style>
</head>
<body>

<div id="root"></div>

<script type="text/babel">
    const { useState, useEffect, useRef } = React;

    const CANVAS_WIDTH = 600;
    const WAVE_HEIGHT = 250;
    const SCREEN_HEIGHT = 100;
    const GRAPH_HEIGHT = 150;
    
    // Physics scale
    const DISTANCE_TO_SCREEN = 1.0; // meters (L)

    const App = () => {
        // --- State ---
        const [wavelength, setWavelength] = useState(532); // nm (Green)
        const [slitWidth, setSlitWidth] = useState(2000); // nm (2 microns)
        const [intensityScale, setIntensityScale] = useState(1.0); 

        const waveCanvasRef = useRef(null);
        const screenCanvasRef = useRef(null);
        const graphCanvasRef = useRef(null);
        const requestRef = useRef();
        const timeRef = useRef(0);

        // --- Color Helper ---
        const nmToRGB = (wavelength) => {
            let r, g, b;
            if (wavelength >= 380 && wavelength < 440) {
                r = -(wavelength - 440) / (440 - 380); g = 0; b = 1;
            } else if (wavelength >= 440 && wavelength < 490) {
                r = 0; g = (wavelength - 440) / (490 - 440); b = 1;
            } else if (wavelength >= 490 && wavelength < 510) {
                r = 0; g = 1; b = -(wavelength - 510) / (510 - 490);
            } else if (wavelength >= 510 && wavelength < 580) {
                r = (wavelength - 510) / (580 - 510); g = 1; b = 0;
            } else if (wavelength >= 580 && wavelength < 645) {
                r = 1; g = -(wavelength - 645) / (645 - 580); b = 0;
            } else if (wavelength >= 645 && wavelength <= 750) {
                r = 1; g = 0; b = 0;
            } else {
                r = 0; g = 0; b = 0;
            }
            // Intensity drop off at edges
            let factor;
            if (wavelength >= 380 && wavelength < 420) factor = 0.3 + 0.7 * (wavelength - 380) / (420 - 380);
            else if (wavelength >= 420 && wavelength < 700) factor = 1.0;
            else if (wavelength >= 700 && wavelength <= 750) factor = 0.3 + 0.7 * (750 - wavelength) / (750 - 700);
            else factor = 0.0;

            const R = Math.floor(r * factor * 255);
            const G = Math.floor(g * factor * 255);
            const B = Math.floor(b * factor * 255);
            return { r: R, g: G, b: B, css: `rgb(${R},${G},${B})` };
        };

        const color = nmToRGB(wavelength);

        // --- Rendering Loop ---
        const loop = (timestamp) => {
            timeRef.current += 0.05;
            drawWaveView();
            requestRef.current = requestAnimationFrame(loop);
        };

        // 1. Draw Wave View (Top) - Animated Huygens
        const drawWaveView = () => {
            const ctx = waveCanvasRef.current?.getContext('2d');
            if (!ctx) return;

            const w = CANVAS_WIDTH;
            const h = WAVE_HEIGHT;
            const cx = w / 2;
            const cy = h / 2;
            const slitX = 100; // Position of barrier

            ctx.clearRect(0, 0, w, h);
            
            // Background
            ctx.fillStyle = '#020617';
            ctx.fillRect(0, 0, w, h);

            // Draw Barrier
            ctx.fillStyle = '#334155';
            const gapPixels = (slitWidth / 5000) * 40; // Scale visual gap (not to scale physically)
            ctx.fillRect(slitX, 0, 10, cy - gapPixels/2);
            ctx.fillRect(slitX, cy + gapPixels/2, 10, h - (cy + gapPixels/2));

            // Draw Waves
            ctx.lineWidth = 2;
            const waveSpacing = (wavelength / 700) * 20; // Visual wavelength scale
            const t = timeRef.current;

            // Incoming Plane Waves
            ctx.strokeStyle = `rgba(${color.r}, ${color.g}, ${color.b}, 0.5)`;
            for (let x = 0; x < slitX; x += waveSpacing) {
                const waveX = (x + t * 5) % slitX; // Move right
                ctx.beginPath();
                ctx.moveTo(waveX, 0);
                ctx.lineTo(waveX, h);
                ctx.stroke();
            }

            // Diffracted Waves
            // Ideally: Intensity varies with angle.
            // Simplified visual: Arcs coming from slit
            for (let r = 0; r < w - slitX; r += waveSpacing) {
                const radius = (r + t * 5) % (w - slitX);
                
                // We draw multiple arcs to simulate intensity pattern? 
                // Or just concentric circles that fade at edges?
                // Let's draw arcs but change opacity based on angle to mimic diffraction
                
                // We need to draw the arc pixel by pixel or segment by segment to vary opacity?
                // Too heavy. Let's just draw standard arcs for concept.
                
                ctx.beginPath();
                ctx.arc(slitX, cy, radius, -Math.PI/2, Math.PI/2);
                ctx.strokeStyle = `rgba(${color.r}, ${color.g}, ${color.b}, ${1 - radius/(w-slitX)})`;
                ctx.stroke();
            }
            
            // Draw Rays to First Minima (Visual Guide)
            // sin(theta) = lambda / a
            const ratio = wavelength / slitWidth;
            if (ratio <= 1) {
                const theta = Math.asin(ratio);
                const len = 600;
                
                ctx.strokeStyle = '#ef4444'; // Red guides
                ctx.setLineDash([5, 5]);
                ctx.lineWidth = 1;
                
                // Top Minima
                ctx.beginPath();
                ctx.moveTo(slitX, cy);
                ctx.lineTo(slitX + len * Math.cos(theta), cy - len * Math.sin(theta));
                ctx.stroke();

                // Bottom Minima
                ctx.beginPath();
                ctx.moveTo(slitX, cy);
                ctx.lineTo(slitX + len * Math.cos(theta), cy + len * Math.sin(theta));
                ctx.stroke();
                
                ctx.setLineDash([]);
            }
        };

        // 2. Draw Intensity Graph & Screen (Bottom)
        const updateCalculations = () => {
            const screenCtx = screenCanvasRef.current?.getContext('2d');
            const graphCtx = graphCanvasRef.current?.getContext('2d');
            if (!screenCtx || !graphCtx) return;

            const w = CANVAS_WIDTH;
            const sh = SCREEN_HEIGHT;
            const gh = GRAPH_HEIGHT;
            const cy = sh / 2;

            // Clear
            screenCtx.clearRect(0, 0, w, sh);
            graphCtx.clearRect(0, 0, w, gh);

            // Fill Backgrounds
            screenCtx.fillStyle = '#000000';
            screenCtx.fillRect(0, 0, w, sh);
            graphCtx.fillStyle = '#1e293b';
            graphCtx.fillRect(0, 0, w, gh);

            // Draw Intensity Graph Axis
            graphCtx.strokeStyle = '#64748b';
            graphCtx.lineWidth = 1;
            graphCtx.beginPath();
            graphCtx.moveTo(0, gh - 20);
            graphCtx.lineTo(w, gh - 20); // X axis
            graphCtx.stroke();
            
            // Center Line
            graphCtx.setLineDash([2, 4]);
            graphCtx.beginPath();
            graphCtx.moveTo(w/2, 0); graphCtx.lineTo(w/2, gh);
            graphCtx.stroke();
            graphCtx.setLineDash([]);

            // Physics Calculation Loop
            // Screen covers range of angles. Let's say screen is at distance L.
            // y on screen = L * tan(theta).
            // We map x pixel on canvas to y position on screen.
            // Let's assume Screen width represents +/- 0.1 meters or so?
            // Scale factor: how zoomed in are we?
            
            // To make it look good, let's say the canvas width covers the central peak and a few orders.
            // Width of central peak: y = L * lambda / a * 2 approx.
            // Let's map pixels to angle directly for simplicity.
            // max theta = 0.05 rad (small angle approx)
            
            const maxTheta = 0.05 * (5000 / slitWidth); // Auto-zoom based on slit width to keep pattern visible
            
            graphCtx.beginPath();
            graphCtx.strokeStyle = color.css;
            graphCtx.lineWidth = 2;
            // Fill for graph
            graphCtx.fillStyle = `rgba(${color.r}, ${color.g}, ${color.b}, 0.2)`;

            // ImageData for Screen View (Photorealistic)
            const screenImg = screenCtx.createImageData(w, sh);
            const sData = screenImg.data;

            for (let x = 0; x < w; x++) {
                // Map x (0 to width) to theta (-maxTheta to maxTheta)
                const theta = -maxTheta + (x / w) * (2 * maxTheta);
                
                // Calculate Alpha (Phase difference)
                // alpha = (pi * a * sin(theta)) / lambda
                // Units need to match. wavelength in nm, slitWidth in nm.
                const alpha = (Math.PI * slitWidth * Math.sin(theta)) / wavelength;
                
                // Intensity I = I0 * (sin(alpha) / alpha)^2
                let intensity = 1.0;
                if (Math.abs(alpha) < 1e-6) {
                    intensity = 1.0; // Limit at 0
                } else {
                    const sinc = Math.sin(alpha) / alpha;
                    intensity = sinc * sinc;
                }

                // Plot on Graph
                const plotY = (gh - 20) - intensity * (gh - 40);
                if (x === 0) graphCtx.moveTo(x, plotY);
                else graphCtx.lineTo(x, plotY);

                // Draw on Screen (Vertical bands)
                // Intensity determines brightness
                const brightness = Math.floor(intensity * 255);
                
                for (let y = 0; y < sh; y++) {
                    const idx = (y * w + x) * 4;
                    sData[idx] = color.r;     // R
                    sData[idx+1] = color.g;   // G
                    sData[idx+2] = color.b;   // B
                    // Alpha falloff towards top/bottom to simulate beam height? Or just flat.
                    // Let's do flat band like a real screen
                    sData[idx+3] = brightness; 
                }
            }

            // Finish Graph
            graphCtx.stroke();
            graphCtx.lineTo(w, gh-20);
            graphCtx.lineTo(0, gh-20);
            graphCtx.fill();

            // Put Screen Image
            screenCtx.putImageData(screenImg, 0, 0);

            // Draw Labels (First Minima)
            // lambda / a = sin(theta) approx theta
            const thetaMin = wavelength / slitWidth;
            // Map theta back to x pixel
            // theta = -maxTheta + (x/w)*2maxTheta -> x = ((theta + maxTheta) / 2maxTheta) * w
            const minX_R = ((thetaMin + maxTheta) / (2 * maxTheta)) * w;
            const minX_L = ((-thetaMin + maxTheta) / (2 * maxTheta)) * w;

            // Draw markers on Graph
            if (minX_R < w) {
                graphCtx.fillStyle = '#ef4444';
                graphCtx.fillText('Min', minX_R - 10, gh - 5);
                graphCtx.fillRect(minX_R, gh - 25, 2, 10);
            }
            if (minX_L > 0) {
                graphCtx.fillStyle = '#ef4444';
                graphCtx.fillText('Min', minX_L - 10, gh - 5);
                graphCtx.fillRect(minX_L, gh - 25, 2, 10);
            }
        };

        useEffect(() => {
            requestRef.current = requestAnimationFrame(loop);
            return () => cancelAnimationFrame(requestRef.current);
        }, [wavelength, slitWidth]); // Loop needs color update

        useEffect(() => {
            updateCalculations();
        }, [wavelength, slitWidth]);

        useEffect(() => {
            if (window.lucide) window.lucide.createIcons();
        });

        // Reset
        const resetSim = () => {
            setWavelength(532);
            setSlitWidth(2000);
        };

        return (
            <div className="min-h-screen bg-slate-900 text-slate-200 font-sans pb-12">
                <nav className="bg-slate-800 border-b border-slate-700 px-6 py-4 flex items-center justify-between sticky top-0 z-10">
                    <div className="flex items-center space-x-3">
                        <div className="bg-indigo-500/20 p-2 rounded-lg">
                            <i data-lucide="aperture" className="w-6 h-6 text-indigo-400"></i>
                        </div>
                        <h1 className="text-xl font-bold text-white tracking-wide">Single Slit Diffraction</h1>
                    </div>
                    <div className="text-xs text-slate-400 font-mono bg-slate-900 px-3 py-1 rounded-full border border-slate-700">
                        Topic: Wave Optics
                    </div>
                </nav>

                <main className="max-w-6xl mx-auto p-4 md:p-6 grid grid-cols-1 lg:grid-cols-12 gap-8">
                    
                    {/* Left: Simulation Views */}
                    <div className="lg:col-span-8 flex flex-col gap-4">
                        
                        {/* 1. Wave View */}
                        <div className="bg-slate-950 rounded-2xl border border-slate-700 relative overflow-hidden">
                            <div className="absolute top-2 left-2 bg-slate-900/80 px-2 py-1 rounded text-[10px] text-slate-400 font-bold border border-slate-700">TOP VIEW (WAVES)</div>
                            <canvas ref={waveCanvasRef} width={CANVAS_WIDTH} height={WAVE_HEIGHT} className="w-full h-auto" />
                        </div>

                        {/* 2. Intensity Graph */}
                        <div className="bg-slate-900 rounded-2xl border border-slate-700 relative overflow-hidden p-4">
                            <div className="absolute top-2 left-2 text-[10px] text-slate-400 font-bold uppercase">Intensity Profile</div>
                            <canvas ref={graphCanvasRef} width={CANVAS_WIDTH} height={GRAPH_HEIGHT} className="w-full h-auto" />
                        </div>

                        {/* 3. Screen View */}
                        <div className="bg-black rounded-2xl border-4 border-slate-700 relative overflow-hidden h-24 shadow-2xl">
                            <div className="absolute top-2 left-2 text-[10px] text-white/50 font-bold uppercase">Screen View (What you see)</div>
                            <canvas ref={screenCanvasRef} width={CANVAS_WIDTH} height={SCREEN_HEIGHT} className="w-full h-full" />
                        </div>

                    </div>

                    {/* Right: Controls & Data */}
                    <div className="lg:col-span-4 space-y-6">
                        
                        <div className="bg-slate-800 p-6 rounded-2xl border border-slate-700 space-y-8">
                            <h2 className="text-white font-bold mb-4 flex items-center">
                                <i data-lucide="sliders" className="w-5 h-5 mr-2 text-indigo-400"></i>
                                Parameters
                            </h2>

                            {/* Wavelength Slider */}
                            <div>
                                <label className="flex justify-between text-xs font-bold mb-2" style={{color: color.css}}>
                                    <span>Wavelength (λ)</span>
                                    <span>{wavelength} nm</span>
                                </label>
                                <div className="h-2 w-full rounded-lg mb-2" style={{background: 'linear-gradient(to right, #4b0082, #0000ff, #00ff00, #ffff00, #ff7f00, #ff0000)'}}></div>
                                <input 
                                    type="range" min="400" max="700" step="1" 
                                    value={wavelength} onChange={(e) => setWavelength(Number(e.target.value))}
                                    className="w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer slider-thumb" 
                                />
                            </div>

                            {/* Slit Width Slider */}
                            <div>
                                <label className="flex justify-between text-xs font-bold text-slate-300 mb-2">
                                    <span>Slit Width (a)</span>
                                    <span>{(slitWidth/1000).toFixed(1)} μm</span>
                                </label>
                                <input 
                                    type="range" min="500" max="5000" step="100" 
                                    value={slitWidth} onChange={(e) => setSlitWidth(Number(e.target.value))}
                                    className="w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer slider-thumb" 
                                />
                                <div className="flex justify-between text-[10px] text-slate-500 mt-1">
                                    <span>Narrow (Diffracts More)</span>
                                    <span>Wide (Diffracts Less)</span>
                                </div>
                            </div>

                            <button onClick={resetSim} className="w-full py-3 bg-slate-700 hover:bg-slate-600 rounded-xl text-white font-bold transition-colors flex items-center justify-center gap-2">
                                <i data-lucide="rotate-ccw" className="w-4 h-4"></i> Reset
                            </button>
                        </div>

                        {/* Analysis Card */}
                        <div className="bg-indigo-900/10 border border-indigo-500/20 p-5 rounded-2xl">
                            <h3 className="text-indigo-300 font-bold text-sm mb-3 flex items-center">
                                <i data-lucide="calculator" className="w-4 h-4 mr-2"></i> Diffraction Ratio
                            </h3>
                            <div className="text-center mb-4">
                                <div className="text-3xl font-mono font-bold text-white">
                                    λ / a = {(wavelength / slitWidth).toFixed(3)}
                                </div>
                            </div>
                            <p className="text-xs text-slate-300 leading-relaxed border-t border-indigo-500/30 pt-3">
                                <strong>Rule of Thumb:</strong>
                                <br/>
                                If <strong>λ ≈ a</strong> (Ratio ≈ 1), diffraction is maximum (very wide spread).
                                <br/>
                                If <strong>λ &lt;&lt; a</strong> (Ratio small), diffraction is minimal (sharp shadow).
                            </p>
                        </div>

                    </div>

                </main>
            </div>
        );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
</script>
</body>
</html>
