<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Photoelectric Effect Lab | Luminous Learner</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Prop Types (Required for Recharts) -->
    <script src="https://unpkg.com/prop-types/prop-types.min.js"></script>
    
    <!-- Recharts (Stable Version) -->
    <script src="https://unpkg.com/recharts@2.12.7/umd/Recharts.js"></script>
    
    <!-- Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@0.263.1"></script>

    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;700;900&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">

    <style>
        body { font-family: 'Inter', sans-serif; background-color: #0f172a; color: #e2e8f0; overflow-y: hidden; }
        .slider-thumb::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none; width: 16px; height: 16px;
            border-radius: 50%; cursor: pointer; border: 2px solid #ffffff;
        }
        .thumb-color::-webkit-slider-thumb { background: currentColor; border-color: white; }
        .custom-scroll::-webkit-scrollbar { width: 6px; }
        .custom-scroll::-webkit-scrollbar-track { background: #1e293b; }
        .custom-scroll::-webkit-scrollbar-thumb { background: #475569; border-radius: 3px; }
    </style>
</head>
<body>

<div id="root"></div>

<script type="text/babel">
    const { useState, useEffect, useRef, useMemo } = React;
    const { LineChart, Line, XAxis, YAxis, Tooltip, ResponsiveContainer, ReferenceDot } = Recharts;

    const CANVAS_WIDTH = 800;
    const CANVAS_HEIGHT = 550;
    
    // Constants
    const HC = 1240; // eV * nm
    const MATERIALS = {
        Sodium: { wf: 2.36, label: "Sodium (2.36 eV)", color: "#fbbf24" },
        Zinc: { wf: 4.30, label: "Zinc (4.30 eV)", color: "#94a3b8" },
        Platinum: { wf: 6.35, label: "Platinum (6.35 eV)", color: "#cbd5e1" },
        Unknown: { wf: 3.00, label: "Unknown (?.?? eV)", color: "#a8a29e" }
    };

    const App = () => {
        // --- State ---
        const [wavelength, setWavelength] = useState(400); // nm
        const [intensity, setIntensity] = useState(50); // %
        const [voltage, setVoltage] = useState(0); // V
        const [material, setMaterial] = useState("Sodium");
        
        // Stats
        const [current, setCurrent] = useState(0);
        const [photonEnergy, setPhotonEnergy] = useState(0);
        const [maxKE, setMaxKE] = useState(0);
        
        const canvasRef = useRef(null);
        const requestRef = useRef();
        
        // Physics Objects
        const objectsRef = useRef({
            photons: [],
            electrons: [],
            detectedCurrent: 0,
            lastSpawn: 0
        });

        // --- Derived Values ---
        const wf = MATERIALS[material].wf;
        const color = useMemo(() => getWavelengthColor(wavelength), [wavelength]);
        
        // --- Physics Loop ---
        const updatePhysics = () => {
            const dt = 1; 
            const now = performance.now();
            const state = objectsRef.current;
            
            // Calculate Energies
            const E_ph = HC / wavelength; // eV
            const K_max = E_ph - wf; // eV
            
            // 1. Spawn Photons
            // Rate depends on intensity
            const spawnRate = 200 - (intensity * 1.8); // lower is faster
            if (now - state.lastSpawn > spawnRate) {
                state.photons.push({
                    x: 120, // Light source X
                    y: 40,  // Light source Y
                    vx: 2.5,  // Moving towards plate
                    vy: 3.5,
                    targetX: 240 + Math.random() * 20, // Plate surface
                    targetY: 280 + Math.random() * 100
                });
                state.lastSpawn = now;
            }

            // 2. Update Photons
            state.photons.forEach(p => {
                p.x += p.vx;
                p.y += p.vy;
                
                // Hit Plate?
                if (p.y >= p.targetY) {
                    p.dead = true;
                    // Spawn Electron?
                    if (K_max > 0) {
                        // Quantum Efficiency simulation
                        if (Math.random() > 0.3) {
                            spawnElectron(p.x, p.y, K_max);
                        }
                    }
                }
            });
            state.photons = state.photons.filter(p => !p.dead);

            // 3. Update Electrons
            let flowCount = 0;
            state.electrons.forEach(e => {
                // Electric Field Force
                // Voltage > 0: Accelerates towards Anode (Right) -> Force +
                // Voltage < 0: Retards (Push back to Left) -> Force -
                // Force scale factor tuned for visuals
                const force = (voltage * 0.08); 
                e.vx += force * dt;
                
                e.x += e.vx;
                e.y += e.vy;

                // Hit Anode (Right side ~ 550px)
                if (e.x > 550) {
                    e.dead = true;
                    flowCount++;
                }
                // Hit Cathode again (Turned back)
                if (e.x < 240) {
                    e.dead = true;
                }
                // Off screen Y
                if (e.y < 0 || e.y > CANVAS_HEIGHT) e.dead = true;
            });
            state.electrons = state.electrons.filter(e => !e.dead);

            // Smooth Current Reading
            // Real current is 0 if V < -StoppingPotential
            // But we simulate by counting particles reaching anode
            state.detectedCurrent = state.detectedCurrent * 0.95 + flowCount * 0.05;

            // Sync React State
            setPhotonEnergy(E_ph);
            setMaxKE(K_max);
            // Visual current scaling
            setCurrent(state.detectedCurrent * (intensity/10)); 
        };

        const spawnElectron = (x, y, kMax) => {
            // Initial velocity based on KE
            // v ~ sqrt(KE). 
            const speed = Math.sqrt(kMax) * 2.5; 
            
            objectsRef.current.electrons.push({
                x: x,
                y: y - 5,
                vx: speed * (0.8 + Math.random()*0.2), // Initial X velocity
                vy: (Math.random() - 0.5) * speed * 0.5, // Slight Y spread
                dead: false
            });
        };

        const loop = () => {
            updatePhysics();
            draw();
            requestRef.current = requestAnimationFrame(loop);
        };

        // --- Rendering ---
        const draw = () => {
            const ctx = canvasRef.current?.getContext('2d');
            if (!ctx) return;

            // Clear
            ctx.fillStyle = '#0f172a';
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            // 1. Draw Vacuum Chamber
            ctx.strokeStyle = '#334155';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.ellipse(400, 300, 220, 140, 0, 0, Math.PI * 2);
            ctx.stroke();
            ctx.fillStyle = 'rgba(255, 255, 255, 0.02)';
            ctx.fill();

            // 2. Draw Plates
            // Cathode (Emitter - Left)
            ctx.fillStyle = MATERIALS[material].color;
            ctx.fillRect(230, 240, 15, 120);
            ctx.fillStyle = '#fff'; ctx.font = '10px sans-serif'; ctx.fillText(material, 230, 230);
            
            // Anode (Collector - Right)
            ctx.fillStyle = '#94a3b8';
            ctx.fillRect(550, 240, 5, 120);

            // 3. Draw Circuit
            ctx.strokeStyle = '#475569';
            ctx.lineWidth = 2;
            ctx.beginPath();
            // From Cathode down
            ctx.moveTo(237, 360); ctx.lineTo(237, 500); 
            // To Power Supply
            ctx.lineTo(350, 500);
            // From Anode down
            ctx.moveTo(552, 360); ctx.lineTo(552, 500);
            // To Ammeter
            ctx.lineTo(450, 500);
            ctx.stroke();

            // Draw Variable Battery
            ctx.fillStyle = '#1e293b';
            ctx.fillRect(350, 480, 100, 40);
            ctx.fillStyle = voltage >= 0 ? '#10b981' : '#ef4444';
            ctx.font = 'bold 12px monospace';
            ctx.textAlign = 'center';
            ctx.fillText(voltage.toFixed(1) + " V", 400, 505);

            // Draw Ammeter
            ctx.beginPath(); ctx.arc(500, 500, 20, 0, Math.PI*2); 
            ctx.fillStyle = '#0f172a'; ctx.fill(); ctx.stroke();
            ctx.fillStyle = '#38bdf8'; ctx.fillText("A", 500, 505);

            // 4. Draw Photons
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            objectsRef.current.photons.forEach(p => {
                ctx.beginPath();
                ctx.moveTo(p.x, p.y);
                ctx.lineTo(p.x - p.vx*3, p.y - p.vy*3); // Trail
                ctx.stroke();
                
                // Head
                ctx.fillStyle = color;
                ctx.beginPath(); ctx.arc(p.x, p.y, 2, 0, Math.PI*2); ctx.fill();
            });

            // 5. Draw Electrons
            ctx.fillStyle = '#38bdf8'; // Cyan
            objectsRef.current.electrons.forEach(e => {
                ctx.beginPath(); ctx.arc(e.x, e.y, 3, 0, Math.PI*2); ctx.fill();
                // Glow
                ctx.shadowColor = '#38bdf8'; ctx.shadowBlur = 5;
                ctx.stroke(); ctx.shadowBlur = 0;
            });

            // 6. Light Source
            ctx.fillStyle = '#334155';
            ctx.fillRect(90, 10, 60, 40);
            // Cone
            ctx.beginPath();
            ctx.moveTo(120, 50); ctx.lineTo(240, 280); ctx.lineTo(100, 280);
            const rgb = hexToRgb(color);
            ctx.fillStyle = `rgba(${rgb}, ${intensity/400})`; // Light beam
            ctx.fill();
        };

        useEffect(() => {
            requestRef.current = requestAnimationFrame(loop);
            return () => cancelAnimationFrame(requestRef.current);
        }, [wavelength, intensity, voltage, material]);

        useEffect(() => {
            if (window.lucide) window.lucide.createIcons();
        });

        // Helper: Wavelength to Color
        function getWavelengthColor(nm) {
            if (nm < 400) return "#a855f7"; // UV
            if (nm < 450) return "#6366f1"; 
            if (nm < 490) return "#3b82f6"; 
            if (nm < 560) return "#22c55e"; 
            if (nm < 590) return "#eab308"; 
            if (nm < 635) return "#f97316"; 
            return "#ef4444"; 
        }

        function hexToRgb(hex) {
            var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
            hex = hex.replace(shorthandRegex, function(m, r, g, b) { return r + r + g + g + b + b; });
            var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? `${parseInt(result[1], 16)}, ${parseInt(result[2], 16)}, ${parseInt(result[3], 16)}` : "255,255,255";
        }

        // Generate I-V Curve Data
        const graphData = useMemo(() => {
            const data = [];
            const Vs = (HC / wavelength) - wf; // Stopping Potential magnitude
            const saturation = intensity * 0.1;

            for (let v = -3; v <= 3; v += 0.2) {
                let i_val = 0;
                if (Vs > 0) { 
                    if (v < -Vs) i_val = 0;
                    else if (v > 0) i_val = saturation; 
                    else {
                        // Rising region
                        i_val = saturation * (1 - Math.abs(v)/Vs); 
                        if (i_val < 0) i_val = 0;
                    }
                }
                data.push({ v: v, i: i_val });
            }
            return data;
        }, [wavelength, intensity, wf]);

        return (
            <div className="h-screen bg-slate-900 text-slate-200 font-sans overflow-hidden flex flex-col">
                <nav className="bg-slate-800 border-b border-slate-700 px-4 py-2 flex items-center justify-between shrink-0 h-14">
                    <div className="flex items-center space-x-3">
                        <div className="bg-blue-500/20 p-1.5 rounded-lg">
                            <i data-lucide="zap" className="w-5 h-5 text-blue-400"></i>
                        </div>
                        <h1 className="text-lg font-bold text-white tracking-wide">Photoelectric Effect</h1>
                    </div>
                    <div className="text-[10px] text-slate-400 font-mono bg-slate-900 px-2 py-1 rounded-full border border-slate-700">
                        Topic: Quantum Physics
                    </div>
                </nav>

                <main className="flex-1 overflow-hidden">
                    <div className="h-full max-w-[1200px] mx-auto grid grid-cols-1 lg:grid-cols-4">
                        
                        {/* LEFT: Canvas */}
                        <div className="lg:col-span-3 bg-slate-950 relative border-r border-slate-700">
                            <canvas 
                                ref={canvasRef} 
                                width={CANVAS_WIDTH} 
                                height={CANVAS_HEIGHT}
                                className="w-full h-full object-contain"
                            />
                        </div>

                        {/* RIGHT: Controls */}
                        <div className="lg:col-span-1 bg-slate-900 border-l border-slate-700 flex flex-col h-full overflow-y-auto custom-scroll">
                            
                            {/* Stats */}
                            <div className="p-4 bg-slate-800/50 border-b border-slate-700 grid grid-cols-2 gap-2">
                                <div className="bg-slate-900 p-2 rounded border border-slate-700">
                                    <div className="text-[10px] text-slate-500">Current (I)</div>
                                    <div className="text-emerald-400 font-mono font-bold">{current.toFixed(2)} mA</div>
                                </div>
                                <div className="bg-slate-900 p-2 rounded border border-slate-700">
                                    <div className="text-[10px] text-slate-500">Max KE (K<sub>max</sub>)</div>
                                    <div className={`font-mono font-bold ${maxKE > 0 ? 'text-blue-400' : 'text-slate-500'}`}>
                                        {maxKE > 0 ? maxKE.toFixed(2) : "0.00"} eV
                                    </div>
                                </div>
                                <div className="col-span-2 bg-slate-900 p-2 rounded border border-slate-700 flex justify-between">
                                    <div className="text-[10px] text-slate-500">Photon Energy (hf)</div>
                                    <div className="text-white font-mono font-bold">{photonEnergy.toFixed(2)} eV</div>
                                </div>
                            </div>

                            {/* Controls */}
                            <div className="p-5 space-y-5 flex-1">
                                
                                {/* Wavelength */}
                                <div>
                                    <label className="flex justify-between text-xs font-bold mb-1" style={{color: color}}>
                                        Wavelength
                                        <span>{wavelength} nm</span>
                                    </label>
                                    <input 
                                        type="range" min="200" max="800" step="10" 
                                        value={wavelength} onChange={(e) => setWavelength(Number(e.target.value))}
                                        className="w-full h-2 rounded-lg slider-thumb thumb-color"
                                        style={{background: `linear-gradient(to right, #a855f7, #3b82f6, #22c55e, #eab308, #ef4444)`, color: color}}
                                    />
                                </div>

                                {/* Intensity */}
                                <div>
                                    <label className="flex justify-between text-xs font-bold text-slate-300 mb-1">
                                        Intensity
                                        <span>{intensity}%</span>
                                    </label>
                                    <input 
                                        type="range" min="0" max="100" step="1" 
                                        value={intensity} onChange={(e) => setIntensity(Number(e.target.value))}
                                        className="w-full h-2 bg-slate-700 rounded-lg slider-thumb" 
                                    />
                                </div>

                                {/* Voltage */}
                                <div>
                                    <label className="flex justify-between text-xs font-bold text-slate-300 mb-1">
                                        Voltage (V)
                                        <span className={voltage < 0 ? 'text-red-400' : 'text-emerald-400'}>{voltage.toFixed(1)} V</span>
                                    </label>
                                    <input 
                                        type="range" min="-3" max="3" step="0.1" 
                                        value={voltage} onChange={(e) => setVoltage(Number(e.target.value))}
                                        className="w-full h-2 bg-slate-700 rounded-lg slider-thumb" 
                                    />
                                    <div className="flex justify-between text-[10px] text-slate-500 mt-1">
                                        <span>Retarding</span>
                                        <span>Forward</span>
                                    </div>
                                </div>

                                {/* Material */}
                                <div>
                                    <label className="text-xs font-bold text-slate-300 mb-1 block">Metal Plate</label>
                                    <select 
                                        value={material} 
                                        onChange={(e) => setMaterial(e.target.value)}
                                        className="w-full bg-slate-800 border border-slate-600 text-slate-200 text-xs rounded p-2 outline-none"
                                    >
                                        {Object.keys(MATERIALS).map(m => (
                                            <option key={m} value={m}>{MATERIALS[m].label}</option>
                                        ))}
                                    </select>
                                </div>

                                {/* I-V Graph */}
                                <div className="h-32 w-full bg-slate-950 border border-slate-700 rounded-lg p-2 relative">
                                    <div className="text-[9px] text-slate-500 absolute top-1 left-2">I-V Curve</div>
                                    <ResponsiveContainer width="100%" height="100%">
                                        <LineChart data={graphData}>
                                            <XAxis dataKey="v" hide type="number" domain={[-3, 3]} />
                                            <YAxis hide type="number" domain={[0, 'auto']} />
                                            <Line type="monotone" dataKey="i" stroke="#38bdf8" strokeWidth={2} dot={false} isAnimationActive={false} />
                                            <ReferenceDot x={voltage} y={current} r={3} fill={voltage < 0 ? "#ef4444" : "#10b981"} stroke="white" />
                                        </LineChart>
                                    </ResponsiveContainer>
                                </div>

                            </div>
                        </div>

                    </div>
                </main>
            </div>
        );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
</script>
</body>
</html>
