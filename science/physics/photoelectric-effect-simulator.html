<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Photoelectric Effect Lab | Luminous Learner</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM (Load these first) -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Prop Types (Required for Recharts UMD) -->
    <script src="https://unpkg.com/prop-types/prop-types.min.js"></script>
    
    <!-- Recharts (Fixed Version) -->
    <script src="https://unpkg.com/recharts@2.8.0/umd/Recharts.js"></script>
    
    <!-- Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@0.263.1"></script>

    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;700;900&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">

    <style>
        body { font-family: 'Inter', sans-serif; background-color: #0f172a; color: #e2e8f0; overflow-y: hidden; }
        .slider-thumb::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none; width: 16px; height: 16px;
            border-radius: 50%; cursor: pointer; border: 2px solid #ffffff;
        }
        .thumb-color::-webkit-slider-thumb { background: currentColor; border-color: white; }
        .custom-scroll::-webkit-scrollbar { width: 6px; }
        .custom-scroll::-webkit-scrollbar-track { background: #1e293b; }
        .custom-scroll::-webkit-scrollbar-thumb { background: #475569; border-radius: 3px; }
    </style>
</head>
<body>

<div id="root"></div>

<script type="text/babel">
    const { useState, useEffect, useRef, useMemo } = React;
    const { LineChart, Line, XAxis, YAxis, Tooltip, ResponsiveContainer } = Recharts;

    const CANVAS_WIDTH = 800;
    const CANVAS_HEIGHT = 550;
    
    // Constants
    const HC = 1240; // eV * nm
    const MATERIALS = {
        Sodium: { wf: 2.36, label: "Sodium (2.36 eV)", color: "#fbbf24" },
        Zinc: { wf: 4.30, label: "Zinc (4.30 eV)", color: "#94a3b8" },
        Platinum: { wf: 6.35, label: "Platinum (6.35 eV)", color: "#cbd5e1" },
        Unknown: { wf: 3.00, label: "Unknown (?.?? eV)", color: "#a8a29e" }
    };

    const App = () => {
        // --- State ---
        const [wavelength, setWavelength] = useState(400); // nm
        const [intensity, setIntensity] = useState(50); // %
        const [voltage, setVoltage] = useState(0); // V
        const [material, setMaterial] = useState("Sodium");
        
        // Stats
        const [current, setCurrent] = useState(0);
        const [photonEnergy, setPhotonEnergy] = useState(0);
        const [maxKE, setMaxKE] = useState(0);
        
        const canvasRef = useRef(null);
        const requestRef = useRef();
        
        // Physics Objects
        const objectsRef = useRef({
            photons: [],
            electrons: [],
            detectedCurrent: 0,
            lastSpawn: 0
        });

        // --- Derived Values ---
        const wf = MATERIALS[material].wf;
        const color = useMemo(() => getWavelengthColor(wavelength), [wavelength]);
        
        // --- Physics Loop ---
        const updatePhysics = () => {
            const dt = 1; 
            const now = performance.now();
            const state = objectsRef.current;
            
            // Calculate Energies
            const E_ph = HC / wavelength; // eV
            const K_max = E_ph - wf; // eV
            
            // 1. Spawn Photons
            // Rate depends on intensity
            const spawnRate = 200 - (intensity * 1.5); // lower is faster
            if (now - state.lastSpawn > spawnRate) {
                state.photons.push({
                    x: 150, // Light source X
                    y: 50,  // Light source Y
                    vx: 2,  // Moving towards plate
                    vy: 3,
                    targetX: 250 + Math.random() * 20, // Plate surface
                    targetY: 300 + Math.random() * 100
                });
                state.lastSpawn = now;
            }

            // 2. Update Photons
            state.photons.forEach(p => {
                p.x += p.vx;
                p.y += p.vy;
                
                // Hit Plate?
                if (p.y >= p.targetY) {
                    p.dead = true;
                    // Spawn Electron?
                    if (K_max > 0) {
                        // Quantum Efficiency simulation (not every photon ejects an electron)
                        if (Math.random() > 0.3) {
                            spawnElectron(p.x, p.y, K_max);
                        }
                    }
                }
            });
            state.photons = state.photons.filter(p => !p.dead);

            // 3. Update Electrons
            let flowCount = 0;
            state.electrons.forEach(e => {
                // Electric Field Force
                // Voltage > 0: Accelerates towards Anode (Right)
                // Voltage < 0: Retards (Push back to Left)
                // F = qE. We simulate velocity change directly.
                // Simple kinematic: v^2 = u^2 + 2as
                // Work done by field = V * e.
                // If moving from Plate (Left) to Anode (Right)
                
                // Simulation: Apply force to vx
                const force = (voltage * 0.05); // Scale factor
                e.vx += force * dt;
                
                e.x += e.vx;
                e.y += e.vy;

                // Hit Anode (Right side ~ 600px)
                if (e.x > 550) {
                    e.dead = true;
                    flowCount++;
                }
                // Hit Cathode again (Turned back)
                if (e.x < 250) {
                    e.dead = true;
                }
            });
            state.electrons = state.electrons.filter(e => !e.dead);

            // Smooth Current Reading
            state.detectedCurrent = state.detectedCurrent * 0.9 + flowCount * 0.1;

            // Sync React State (Throttled slightly usually, but ok here)
            setPhotonEnergy(E_ph);
            setMaxKE(K_max);
            // Current is proportional to electrons reaching anode * intensity factor scaling
            setCurrent(state.detectedCurrent * (intensity/10)); 
        };

        const spawnElectron = (x, y, kMax) => {
            // Initial velocity based on KE
            // KE = 1/2 m v^2 -> v = sqrt(2*KE/m)
            // Use scale factor for visual speed
            const speed = Math.sqrt(kMax) * 3; 
            
            objectsRef.current.electrons.push({
                x: x,
                y: y - 5, // Just above plate
                vx: speed * (0.8 + Math.random()*0.4), // Mostly horizontal towards anode
                vy: (Math.random() - 0.5) * speed, // Slight vertical spread
                dead: false
            });
        };

        const loop = () => {
            updatePhysics();
            draw();
            requestRef.current = requestAnimationFrame(loop);
        };

        // --- Rendering ---
        const draw = () => {
            const ctx = canvasRef.current?.getContext('2d');
            if (!ctx) return;

            // Clear
            ctx.fillStyle = '#0f172a';
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            // 1. Draw Vacuum Chamber (Glass Tube)
            ctx.strokeStyle = '#334155';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.ellipse(400, 300, 200, 120, 0, 0, Math.PI * 2);
            ctx.stroke();
            ctx.fillStyle = 'rgba(255, 255, 255, 0.02)';
            ctx.fill();

            // 2. Draw Plates
            // Cathode (Emitter - Left)
            ctx.fillStyle = MATERIALS[material].color;
            ctx.fillRect(240, 250, 10, 100);
            
            // Anode (Collector - Right)
            ctx.fillStyle = '#94a3b8';
            ctx.fillRect(550, 250, 5, 100); // Thin wire mesh

            // 3. Draw Circuit
            ctx.strokeStyle = '#475569';
            ctx.lineWidth = 2;
            ctx.beginPath();
            // From Cathode down
            ctx.moveTo(245, 350); ctx.lineTo(245, 500); 
            // To Power Supply
            ctx.lineTo(350, 500);
            // From Anode down
            ctx.moveTo(552, 350); ctx.lineTo(552, 500);
            // To Ammeter
            ctx.lineTo(450, 500);
            ctx.stroke();

            // Draw Variable Battery
            ctx.fillStyle = '#1e293b';
            ctx.fillRect(350, 480, 100, 40);
            ctx.fillStyle = voltage >= 0 ? '#10b981' : '#ef4444';
            ctx.font = 'bold 12px monospace';
            ctx.textAlign = 'center';
            ctx.fillText(voltage.toFixed(1) + " V", 400, 505);

            // Draw Ammeter
            ctx.beginPath(); ctx.arc(500, 500, 20, 0, Math.PI*2); 
            ctx.fillStyle = '#0f172a'; ctx.fill(); ctx.stroke();
            ctx.fillStyle = '#38bdf8'; ctx.fillText("A", 500, 505);

            // 4. Draw Photons (Wavy lines?)
            // Simple dots/lines for now
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            objectsRef.current.photons.forEach(p => {
                ctx.beginPath();
                ctx.moveTo(p.x, p.y);
                ctx.lineTo(p.x - p.vx*2, p.y - p.vy*2); // Trail
                ctx.stroke();
                
                // Head
                ctx.fillStyle = color;
                ctx.beginPath(); ctx.arc(p.x, p.y, 2, 0, Math.PI*2); ctx.fill();
            });

            // 5. Draw Electrons
            ctx.fillStyle = '#38bdf8'; // Cyan
            objectsRef.current.electrons.forEach(e => {
                ctx.beginPath(); ctx.arc(e.x, e.y, 3, 0, Math.PI*2); ctx.fill();
                // Speed aura
                ctx.strokeStyle = 'rgba(56, 189, 248, 0.3)';
                ctx.beginPath(); ctx.arc(e.x, e.y, 5, 0, Math.PI*2); ctx.stroke();
            });

            // 6. Light Source
            ctx.fillStyle = '#1e293b';
            ctx.fillRect(120, 20, 60, 40); // Lamp body
            // Bulb
            ctx.beginPath();
            ctx.moveTo(150, 60); ctx.lineTo(200, 120); ctx.lineTo(100, 120); 
            ctx.fillStyle = `rgba(${hexToRgb(color)}, ${intensity/100})`;
            ctx.fill();
        };

        useEffect(() => {
            requestRef.current = requestAnimationFrame(loop);
            return () => cancelAnimationFrame(requestRef.current);
        }, [wavelength, intensity, voltage, material]); // Re-bind simulation params

        useEffect(() => {
            if (window.lucide) window.lucide.createIcons();
        });

        // Helper: Wavelength to Color
        function getWavelengthColor(nm) {
            if (nm < 400) return "#a855f7"; // UV (Purple)
            if (nm < 450) return "#6366f1"; // Violet/Indigo
            if (nm < 490) return "#3b82f6"; // Blue
            if (nm < 560) return "#22c55e"; // Green
            if (nm < 590) return "#eab308"; // Yellow
            if (nm < 635) return "#f97316"; // Orange
            return "#ef4444"; // Red
        }

        function hexToRgb(hex) {
            // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
            var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
            hex = hex.replace(shorthandRegex, function(m, r, g, b) {
                return r + r + g + g + b + b;
            });
            var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? `${parseInt(result[1], 16)}, ${parseInt(result[2], 16)}, ${parseInt(result[3], 16)}` : "255,255,255";
        }

        // I-V Data Generator for Chart
        const graphData = useMemo(() => {
            const data = [];
            // Simulate typical Photoelectric Curve
            // I = 0 if V < -StoppingPotential
            // I saturates as V increases
            const Vs = K_max_calc(wavelength, wf); // Stopping Potential magnitude
            const saturation = intensity * 0.1;

            for (let v = -5; v <= 5; v += 1) {
                let i_val = 0;
                if (Vs > 0) { // If emission is possible
                    if (v < -Vs) i_val = 0;
                    else if (v > 0) i_val = saturation; // Saturation region
                    else {
                        // Rising region (simplified linear/curve)
                        i_val = saturation * (1 - Math.abs(v)/Vs); 
                        if (i_val < 0) i_val = 0;
                    }
                }
                data.push({ v: v, i: i_val });
            }
            return data;
        }, [wavelength, intensity, wf]);

        function K_max_calc(lam, workFunc) {
            return (HC / lam) - workFunc;
        }

        return (
            <div className="h-screen bg-slate-900 text-slate-200 font-sans overflow-hidden flex flex-col">
                <nav className="bg-slate-800 border-b border-slate-700 px-4 py-2 flex items-center justify-between shrink-0 h-14">
                    <div className="flex items-center space-x-3">
                        <div className="bg-blue-500/20 p-1.5 rounded-lg">
                            <i data-lucide="zap" className="w-5 h-5 text-blue-400"></i>
                        </div>
                        <h1 className="text-lg font-bold text-white tracking-wide">Photoelectric Effect Lab</h1>
                    </div>
                    <div className="text-[10px] text-slate-400 font-mono bg-slate-900 px-2 py-1 rounded-full border border-slate-700">
                        Topic: Quantum Mechanics
                    </div>
                </nav>

                <main className="flex-1 overflow-hidden">
                    <div className="h-full max-w-[1200px] mx-auto grid grid-cols-1 lg:grid-cols-4">
                        
                        {/* LEFT: Canvas */}
                        <div className="lg:col-span-3 bg-slate-950 relative border-r border-slate-700">
                            <canvas 
                                ref={canvasRef} 
                                width={CANVAS_WIDTH} 
                                height={CANVAS_HEIGHT}
                                className="w-full h-full object-contain"
                            />
                        </div>

                        {/* RIGHT: Controls */}
                        <div className="lg:col-span-1 bg-slate-900 border-l border-slate-700 flex flex-col h-full overflow-y-auto custom-scroll">
                            
                            {/* Stats */}
                            <div className="p-4 bg-slate-800/50 border-b border-slate-700 grid grid-cols-2 gap-2">
                                <div className="bg-slate-900 p-2 rounded border border-slate-700">
                                    <div className="text-[10px] text-slate-500">Current (I)</div>
                                    <div className="text-emerald-400 font-mono font-bold">{current.toFixed(2)} mA</div>
                                </div>
                                <div className="bg-slate-900 p-2 rounded border border-slate-700">
                                    <div className="text-[10px] text-slate-500">Max KE ($K_{max}$)</div>
                                    <div className={`font-mono font-bold ${maxKE > 0 ? 'text-blue-400' : 'text-slate-500'}`}>
                                        {maxKE > 0 ? maxKE.toFixed(2) : "0.00"} eV
                                    </div>
                                </div>
                                <div className="col-span-2 bg-slate-900 p-2 rounded border border-slate-700 flex justify-between">
                                    <div className="text-[10px] text-slate-500">Photon Energy ($hf$)</div>
                                    <div className="text-white font-mono font-bold">{photonEnergy.toFixed(2)} eV</div>
                                </div>
                            </div>

                            {/* Controls */}
                            <div className="p-5 space-y-5">
                                
                                {/* Wavelength */}
                                <div>
                                    <label className="flex justify-between text-xs font-bold mb-1" style={{color: color}}>
                                        Wavelength
                                        <span>{wavelength} nm</span>
                                    </label>
                                    <input 
                                        type="range" min="200" max="800" step="10" 
                                        value={wavelength} onChange={(e) => setWavelength(Number(e.target.value))}
                                        className="w-full h-2 rounded-lg slider-thumb thumb-color"
                                        style={{background: `linear-gradient(to right, #a855f7, #3b82f6, #22c55e, #eab308, #ef4444)`, color: color}}
                                    />
                                </div>

                                {/* Intensity */}
                                <div>
                                    <label className="flex justify-between text-xs font-bold text-slate-300 mb-1">
                                        Intensity
                                        <span>{intensity}%</span>
                                    </label>
                                    <input 
                                        type="range" min="0" max="100" step="1" 
                                        value={intensity} onChange={(e) => setIntensity(Number(e.target.value))}
                                        className="w-full h-2 bg-slate-700 rounded-lg slider-thumb" 
                                    />
                                </div>

                                {/* Voltage */}
                                <div>
                                    <label className="flex justify-between text-xs font-bold text-slate-300 mb-1">
                                        Battery Voltage
                                        <span className={voltage < 0 ? 'text-red-400' : 'text-emerald-400'}>{voltage.toFixed(1)} V</span>
                                    </label>
                                    <input 
                                        type="range" min="-5" max="5" step="0.1" 
                                        value={voltage} onChange={(e) => setVoltage(Number(e.target.value))}
                                        className="w-full h-2 bg-slate-700 rounded-lg slider-thumb" 
                                    />
                                    <div className="flex justify-between text-[10px] text-slate-500 mt-1">
                                        <span>Reverse (Retarding)</span>
                                        <span>Forward</span>
                                    </div>
                                </div>

                                {/* Material */}
                                <div>
                                    <label className="text-xs font-bold text-slate-300 mb-1 block">Target Material</label>
                                    <select 
                                        value={material} 
                                        onChange={(e) => setMaterial(e.target.value)}
                                        className="w-full bg-slate-800 border border-slate-600 text-slate-200 text-xs rounded p-2 focus:ring-1 focus:ring-blue-500 outline-none"
                                    >
                                        {Object.keys(MATERIALS).map(m => (
                                            <option key={m} value={m}>{MATERIALS[m].label}</option>
                                        ))}
                                    </select>
                                </div>

                                {/* Mini I-V Graph */}
                                <div className="h-32 w-full bg-slate-900 border border-slate-700 rounded-lg p-2 relative">
                                    <div className="text-[9px] text-slate-500 absolute top-1 left-2">Expected I-V Curve</div>
                                    <ResponsiveContainer width="100%" height="100%">
                                        <LineChart data={graphData}>
                                            <XAxis dataKey="v" hide type="number" domain={[-5, 5]} />
                                            <YAxis hide type="number" domain={[0, 'auto']} />
                                            <Tooltip 
                                                contentStyle={{backgroundColor: '#1e293b', border: '1px solid #475569', fontSize: '10px'}}
                                                labelFormatter={(v) => `V: ${v}V`}
                                                itemStyle={{color: '#38bdf8'}}
                                            />
                                            <Line type="monotone" dataKey="i" stroke="#38bdf8" strokeWidth={2} dot={false} />
                                            {/* Current operating point */}
                                            {/* We can't easily draw a dot at current V without complex composition, but the curve shows the theory */}
                                        </LineChart>
                                    </ResponsiveContainer>
                                </div>

                            </div>
                        </div>

                    </div>
                </main>
            </div>
        );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
</script>
</body>
</html>
