<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Equipotential Mapper 3D | Luminous Learner</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@0.263.1"></script>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;700;900&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">

    <style>
        body { font-family: 'Inter', sans-serif; background-color: #0f172a; color: #e2e8f0; overflow-y: hidden; }
        .custom-scroll::-webkit-scrollbar { width: 6px; }
        .custom-scroll::-webkit-scrollbar-track { background: #1e293b; }
        .custom-scroll::-webkit-scrollbar-thumb { background: #475569; border-radius: 3px; }
    </style>
</head>
<body>

<div id="root"></div>

<script type="text/babel">
    const { useState, useEffect, useRef, useMemo } = React;

    const App = () => {
        // --- State ---
        const [charges, setCharges] = useState([
            { x: -2, z: 0, q: 1, id: 1 }, // Initial Dipole
            { x: 2, z: 0, q: -1, id: 2 }
        ]);
        const [showMesh, setShowMesh] = useState(true);
        const [showContours, setShowContours] = useState(true);
        const [autoRotate, setAutoRotate] = useState(true);

        const mountRef = useRef(null);
        const sceneRef = useRef(null);
        const rendererRef = useRef(null);
        const cameraRef = useRef(null);
        const meshRef = useRef(null);
        const contoursRef = useRef(null);
        const chargesGroupRef = useRef(null);
        
        // --- 3D Scene Setup ---
        useEffect(() => {
            const width = mountRef.current.clientWidth;
            const height = mountRef.current.clientHeight;

            // Scene
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x020617); // Dark slate
            sceneRef.current = scene;

            // Camera
            const camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);
            camera.position.set(0, 15, 15);
            camera.lookAt(0, 0, 0);
            cameraRef.current = camera;

            // Renderer
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(width, height);
            mountRef.current.appendChild(renderer.domElement);
            rendererRef.current = renderer;

            // Lights
            const ambientLight = new THREE.AmbientLight(0x404040);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(5, 10, 5);
            scene.add(dirLight);

            // Grid Helper
            const gridHelper = new THREE.GridHelper(20, 20, 0x334155, 0x1e293b);
            scene.add(gridHelper);

            // Initialize Geometry
            updatePotentialMap();

            // Animation Loop
            let frameId;
            const animate = () => {
                if (autoRotate && sceneRef.current) {
                    sceneRef.current.rotation.y += 0.002;
                }
                renderer.render(scene, camera);
                frameId = requestAnimationFrame(animate);
            };
            animate();

            // Cleanup
            return () => {
                cancelAnimationFrame(frameId);
                if (mountRef.current && renderer.domElement) {
                    mountRef.current.removeChild(renderer.domElement);
                }
                // Dispose geometries/materials to prevent leak
            };
        }, []); // Run once on mount

        // --- Physics & Geometry Update ---
        useEffect(() => {
            updatePotentialMap();
        }, [charges, showMesh, showContours]);

        const updatePotentialMap = () => {
            if (!sceneRef.current) return;

            // 1. Clear old meshes
            if (meshRef.current) sceneRef.current.remove(meshRef.current);
            if (contoursRef.current) sceneRef.current.remove(contoursRef.current);
            if (chargesGroupRef.current) sceneRef.current.remove(chargesGroupRef.current);

            // 2. Add Charge Markers
            const chargeGroup = new THREE.Group();
            charges.forEach(c => {
                const geometry = new THREE.SphereGeometry(0.4, 32, 32);
                const material = new THREE.MeshPhongMaterial({ 
                    color: c.q > 0 ? 0xff4444 : 0x4444ff,
                    emissive: c.q > 0 ? 0x550000 : 0x000055
                });
                const sphere = new THREE.Mesh(geometry, material);
                sphere.position.set(c.x, 0, c.z); // Charges on Y=0 plane
                chargeGroup.add(sphere);
                
                // Pole/Stand
                const poleGeo = new THREE.CylinderGeometry(0.05, 0.05, 0.5, 8);
                const poleMat = new THREE.MeshBasicMaterial({ color: 0x64748b });
                const pole = new THREE.Mesh(poleGeo, poleMat);
                pole.position.set(c.x, -0.25, c.z);
                chargeGroup.add(pole);
            });
            sceneRef.current.add(chargeGroup);
            chargesGroupRef.current = chargeGroup;

            // 3. Generate Potential Surface
            const size = 20;
            const segments = 60; // Resolution
            const geometry = new THREE.PlaneGeometry(size, size, segments, segments);
            const posAttribute = geometry.attributes.position;

            // Calculate V at each vertex
            // V = k * sum(q_i / r_i)
            // To visualize: Y (height) = V * scale
            // Clamp height to avoid infinity at r=0
            const k = 2.0; // Visual scaling factor
            
            for (let i = 0; i < posAttribute.count; i++) {
                const x = posAttribute.getX(i);
                const z = posAttribute.getY(i); // PlaneGeo is initially X-Y, we rotate it later
                
                let vTotal = 0;
                charges.forEach(c => {
                    const dx = x - c.x;
                    const dz = z - c.z;
                    const dist = Math.sqrt(dx*dx + dz*dz);
                    // Soften core to prevent infinite spike
                    const safeDist = Math.max(0.5, dist); 
                    vTotal += c.q / safeDist;
                });

                // Apply height
                let y = vTotal * k;
                // Clamp visual height
                y = Math.max(-5, Math.min(5, y));
                
                // Update Z (which is Y in our PlaneGeo before rotation)
                posAttribute.setZ(i, y);
            }
            
            geometry.computeVertexNormals();

            // Create Mesh
            if (showMesh) {
                const material = new THREE.MeshPhongMaterial({
                    color: 0x38bdf8,
                    side: THREE.DoubleSide,
                    wireframe: false,
                    flatShading: false,
                    shininess: 50,
                    transparent: true,
                    opacity: 0.8
                });
                
                // Use vertex colors for heatmap effect?
                // Let's stick to simple blue material with lighting for now for cleaner look
                
                const mesh = new THREE.Mesh(geometry, material);
                mesh.rotation.x = -Math.PI / 2; // Rotate to lie flat on X-Z
                mesh.position.y = 0; // Center
                sceneRef.current.add(mesh);
                meshRef.current = mesh;
            }

            // 4. Generate Contours (Equipotential Lines)
            if (showContours) {
                // We can cheat by creating horizontal planes that intersect the mesh?
                // Or simply draw lines on the texture?
                // Or create line segments.
                // Simpler: Draw a 2D canvas texture with calculated contours and map it to a flat plane below.
                
                const canvas = document.createElement('canvas');
                canvas.width = 512;
                canvas.height = 512;
                const ctx = canvas.getContext('2d');
                
                // Draw background
                ctx.fillStyle = '#0f172a';
                ctx.fillRect(0, 0, 512, 512);
                
                // Calculate pixels
                const imgData = ctx.getImageData(0, 0, 512, 512);
                const data = imgData.data;
                
                for (let py = 0; py < 512; py++) {
                    for (let px = 0; px < 512; px++) {
                        // Map px,py to world coordinates
                        const worldX = (px / 512 - 0.5) * size;
                        const worldZ = (py / 512 - 0.5) * size;
                        
                        let vTotal = 0;
                        charges.forEach(c => {
                            const dx = worldX - c.x;
                            const dz = worldZ - c.z;
                            const dist = Math.sqrt(dx*dx + dz*dz);
                            vTotal += c.q / Math.max(0.1, dist);
                        });
                        
                        // Check if V is close to a contour level
                        // Levels: -2, -1.5, -1, ..., 1, 1.5, 2
                        const levelStep = 0.5;
                        const vScaled = vTotal * k;
                        const rem = Math.abs(vScaled % levelStep);
                        const isContour = rem < 0.05 || (levelStep - rem) < 0.05;
                        
                        if (isContour) {
                            const index = (py * 512 + px) * 4;
                            // Color based on V
                            if (vTotal > 0) { // Reddish
                                data[index] = 255; data[index+1] = 100; data[index+2] = 100;
                            } else { // Blueish
                                data[index] = 100; data[index+1] = 100; data[index+2] = 255;
                            }
                            data[index+3] = 255; // Alpha
                        }
                    }
                }
                ctx.putImageData(imgData, 0, 0);
                
                const texture = new THREE.CanvasTexture(canvas);
                const planeGeo = new THREE.PlaneGeometry(size, size);
                const planeMat = new THREE.MeshBasicMaterial({ 
                    map: texture, 
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.6
                });
                const contourPlane = new THREE.Mesh(planeGeo, planeMat);
                contourPlane.rotation.x = -Math.PI / 2;
                contourPlane.position.y = -5.1; // Below the main graph
                sceneRef.current.add(contourPlane);
                contoursRef.current = contourPlane;
            }
        };

        // --- Interaction Handlers ---
        const addCharge = (q) => {
            const newId = Math.max(...charges.map(c => c.id), 0) + 1;
            // Place randomly but somewhat centrally
            const rx = (Math.random() - 0.5) * 6;
            const rz = (Math.random() - 0.5) * 6;
            setCharges([...charges, { x: rx, z: rz, q: q, id: newId }]);
        };

        const removeCharge = (id) => {
            setCharges(charges.filter(c => c.id !== id));
        };

        const reset = () => {
            setCharges([
                { x: -2, z: 0, q: 1, id: 1 },
                { x: 2, z: 0, q: -1, id: 2 }
            ]);
            if (sceneRef.current) sceneRef.current.rotation.y = 0;
        };

        return (
            <div className="h-screen bg-slate-900 text-slate-200 font-sans overflow-hidden flex flex-col">
                <nav className="bg-slate-800 border-b border-slate-700 px-4 py-2 flex items-center justify-between shrink-0 h-14">
                    <div className="flex items-center space-x-3">
                        <div className="bg-indigo-500/20 p-1.5 rounded-lg">
                            <i data-lucide="mountain" className="w-5 h-5 text-indigo-400"></i>
                        </div>
                        <h1 className="text-lg font-bold text-white tracking-wide">Equipotential Mapper 3D</h1>
                    </div>
                    <div className="text-[10px] text-slate-400 font-mono bg-slate-900 px-2 py-1 rounded-full border border-slate-700">
                        Topic: Electromagnetism
                    </div>
                </nav>

                <main className="flex-1 overflow-hidden">
                    <div className="h-full max-w-[1200px] mx-auto grid grid-cols-1 lg:grid-cols-4">
                        
                        {/* LEFT: 3D Viewport */}
                        <div className="lg:col-span-3 bg-slate-950 relative border-r border-slate-700">
                            <div ref={mountRef} className="w-full h-full cursor-move" />
                            
                            {/* Controls Overlay */}
                            <div className="absolute top-4 left-4 flex gap-2">
                                <button 
                                    onClick={() => setAutoRotate(!autoRotate)}
                                    className={`p-2 rounded border transition-all ${autoRotate ? 'bg-indigo-600 border-indigo-500 text-white' : 'bg-slate-800 border-slate-600 text-slate-400'}`}
                                    title="Auto Rotate"
                                >
                                    <i data-lucide="refresh-cw" className="w-4 h-4"></i>
                                </button>
                                <button 
                                    onClick={() => setShowMesh(!showMesh)}
                                    className={`p-2 rounded border transition-all ${showMesh ? 'bg-indigo-600 border-indigo-500 text-white' : 'bg-slate-800 border-slate-600 text-slate-400'}`}
                                    title="Toggle 3D Potential Surface"
                                >
                                    <i data-lucide="layers" className="w-4 h-4"></i>
                                </button>
                                <button 
                                    onClick={() => setShowContours(!showContours)}
                                    className={`p-2 rounded border transition-all ${showContours ? 'bg-indigo-600 border-indigo-500 text-white' : 'bg-slate-800 border-slate-600 text-slate-400'}`}
                                    title="Toggle 2D Contours"
                                >
                                    <i data-lucide="map" className="w-4 h-4"></i>
                                </button>
                            </div>
                            
                            <div className="absolute bottom-4 left-4 bg-slate-900/80 p-3 rounded-xl border border-slate-700 text-xs text-slate-400 backdrop-blur pointer-events-none">
                                <div className="flex items-center gap-2 mb-1">
                                    <div className="w-3 h-3 rounded-full bg-red-500"></div> 
                                    <span>Positive Charge (Mountain)</span>
                                </div>
                                <div className="flex items-center gap-2">
                                    <div className="w-3 h-3 rounded-full bg-blue-500"></div> 
                                    <span>Negative Charge (Valley)</span>
                                </div>
                            </div>
                        </div>

                        {/* RIGHT: Controls */}
                        <div className="lg:col-span-1 bg-slate-900 border-l border-slate-700 flex flex-col h-full overflow-y-auto custom-scroll">
                            
                            {/* 1. Formula Panel */}
                            <div className="p-4 bg-slate-800/50 border-b border-slate-700 backdrop-blur sticky top-0 z-10">
                                <h3 className="text-xs font-bold text-slate-400 uppercase tracking-wider mb-3">Electric Potential (V)</h3>
                                <div className="bg-slate-900 p-4 rounded-xl border border-slate-700 text-center">
                                    <div className="text-lg font-mono font-bold text-white mb-1">V = kQ / r</div>
                                    <div className="text-[10px] text-slate-500">
                                        Scalar sum of potentials from all charges.
                                    </div>
                                </div>
                            </div>

                            {/* 2. Charge Manager */}
                            <div className="p-5 space-y-6 flex-1">
                                
                                <div>
                                    <label className="text-xs font-bold text-slate-300 mb-2 block">Add Charges</label>
                                    <div className="grid grid-cols-2 gap-2">
                                        <button 
                                            onClick={() => addCharge(1)}
                                            className="py-3 rounded bg-slate-800 border border-slate-600 hover:border-red-500 text-red-400 font-bold flex items-center justify-center gap-2 transition"
                                        >
                                            <i data-lucide="plus-circle" className="w-4 h-4"></i> +Q
                                        </button>
                                        <button 
                                            onClick={() => addCharge(-1)}
                                            className="py-3 rounded bg-slate-800 border border-slate-600 hover:border-blue-500 text-blue-400 font-bold flex items-center justify-center gap-2 transition"
                                        >
                                            <i data-lucide="minus-circle" className="w-4 h-4"></i> -Q
                                        </button>
                                    </div>
                                </div>

                                <div className="space-y-2">
                                    <div className="flex justify-between items-center text-xs font-bold text-slate-400 uppercase tracking-wider">
                                        Active Charges
                                        <button onClick={reset} className="text-[10px] text-indigo-400 hover:text-white">Reset</button>
                                    </div>
                                    
                                    <div className="space-y-1">
                                        {charges.map((c, i) => (
                                            <div key={c.id} className="flex justify-between items-center bg-slate-800 p-2 rounded border border-slate-700">
                                                <div className="flex items-center gap-2">
                                                    <div className={`w-2 h-2 rounded-full ${c.q > 0 ? 'bg-red-500' : 'bg-blue-500'}`}></div>
                                                    <span className="text-xs text-white">Charge {i+1} ({c.q > 0 ? '+Q' : '-Q'})</span>
                                                </div>
                                                <button onClick={() => removeCharge(c.id)} className="text-slate-500 hover:text-red-400">
                                                    <i data-lucide="x" className="w-3 h-3"></i>
                                                </button>
                                            </div>
                                        ))}
                                        {charges.length === 0 && (
                                            <div className="text-center text-xs text-slate-600 py-4 italic">No charges. Flat space.</div>
                                        )}
                                    </div>
                                </div>

                                <div className="mt-auto p-3 bg-indigo-900/10 border border-indigo-500/20 rounded-lg">
                                    <h4 className="text-indigo-400 font-bold text-xs mb-1 flex items-center">
                                        <i data-lucide="info" className="w-3 h-3 mr-1"></i> Analogy
                                    </h4>
                                    <p className="text-[10px] text-slate-400 leading-tight">
                                        Think of Electric Potential as <strong>Height</strong>.
                                        <br/><br/>
                                        Positive charges are <strong>Hills</strong>.
                                        <br/>
                                        Negative charges are <strong>Holes</strong>.
                                        <br/>
                                        Electric Field lines point <strong>Downhill</strong> (steepest slope).
                                    </p>
                                </div>

                            </div>
                        </div>

                    </div>
                </main>
            </div>
        );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
</script>
</body>
</html>
