<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Equipotential Mapper 3D | Luminous Learner</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@0.263.1"></script>

    <!-- Three.js & OrbitControls -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js" type="module"></script>
    <!-- Note: OrbitControls is usually a module. To use in standard script, we might need a specific CDN bundle or a shim. 
         Safest for single-file without modules: Use a CDN that exposes THREE.OrbitControls globally or implement simple drag.
         Let's try to implement simple drag rotation manually to be 100% safe. -->

    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;700;900&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">

    <style>
        body { font-family: 'Inter', sans-serif; background-color: #0f172a; color: #e2e8f0; overflow-y: hidden; }
        .custom-scroll::-webkit-scrollbar { width: 6px; }
        .custom-scroll::-webkit-scrollbar-track { background: #1e293b; }
        .custom-scroll::-webkit-scrollbar-thumb { background: #475569; border-radius: 3px; }
    </style>
</head>
<body>

<div id="root"></div>

<script type="text/babel">
    const { useState, useEffect, useRef, useMemo, useCallback } = React;

    // Error Boundary
    class ErrorBoundary extends React.Component {
        constructor(props) { super(props); this.state = { hasError: false }; }
        static getDerivedStateFromError(error) { return { hasError: true }; }
        render() { if (this.state.hasError) return <div className="p-4 text-red-500">3D Engine Error. Please Refresh.</div>; return this.props.children; }
    }

    const App = () => {
        // --- State ---
        const [charges, setCharges] = useState([
            { x: -2, z: 0, q: 1, id: 1 },
            { x: 2, z: 0, q: -1, id: 2 }
        ]);
        const [showMesh, setShowMesh] = useState(true);
        const [showContours, setShowContours] = useState(true);
        const [autoRotate, setAutoRotate] = useState(true);

        const mountRef = useRef(null);
        const sceneRef = useRef(null);
        const rendererRef = useRef(null);
        const cameraRef = useRef(null);
        const rootGroupRef = useRef(null); // Group to hold everything for rotation
        
        // Refs for mutable values in animation loop
        const autoRotateRef = useRef(autoRotate);
        const isDraggingRef = useRef(false);
        const prevMouseRef = useRef({ x: 0, y: 0 });
        const rotationRef = useRef({ x: 0, y: 0 });

        // Update refs when state changes
        useEffect(() => { autoRotateRef.current = autoRotate; }, [autoRotate]);

        // --- 3D Engine Setup ---
        useEffect(() => {
            if (!mountRef.current) return;

            const width = mountRef.current.clientWidth;
            const height = mountRef.current.clientHeight;

            // Scene
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x020617);
            sceneRef.current = scene;

            // Camera
            const camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);
            camera.position.set(0, 15, 20); // High angle
            camera.lookAt(0, 0, 0);
            cameraRef.current = camera;

            // Renderer
            const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(width, height);
            mountRef.current.appendChild(renderer.domElement);
            rendererRef.current = renderer;

            // Lights
            const ambientLight = new THREE.AmbientLight(0x404040);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 1);
            dirLight.position.set(5, 10, 5);
            scene.add(dirLight);

            // Root Group (for manual rotation)
            const rootGroup = new THREE.Group();
            scene.add(rootGroup);
            rootGroupRef.current = rootGroup;

            // Grid
            const gridHelper = new THREE.GridHelper(20, 20, 0x334155, 0x1e293b);
            rootGroup.add(gridHelper);

            // Initial Render Trigger
            // We can't call updatePotentialMap here easily because it depends on state.
            // But the second useEffect will trigger it.

            // Animation Loop
            let frameId;
            const animate = () => {
                if (autoRotateRef.current && !isDraggingRef.current && rootGroupRef.current) {
                    rootGroupRef.current.rotation.y += 0.003;
                }
                // Manual Rotation Application
                if (rootGroupRef.current) {
                    // Smoothly blend manual rotation? Or just set it?
                    // For simplicity, we just add auto-rotation or let mouse control modify rotation.
                    // If not auto-rotating, we respect the current rotation.
                }

                renderer.render(scene, camera);
                frameId = requestAnimationFrame(animate);
            };
            animate();

            // Handle Resize
            const handleResize = () => {
                const w = mountRef.current.clientWidth;
                const h = mountRef.current.clientHeight;
                camera.aspect = w / h;
                camera.updateProjectionMatrix();
                renderer.setSize(w, h);
            };
            window.addEventListener('resize', handleResize);

            return () => {
                cancelAnimationFrame(frameId);
                window.removeEventListener('resize', handleResize);
                if (mountRef.current && renderer.domElement) {
                    mountRef.current.removeChild(renderer.domElement);
                }
                // Clean up Three.js resources
                renderer.dispose();
            };
        }, []);

        // --- Mouse Interaction for Rotation ---
        const handleMouseDown = (e) => {
            isDraggingRef.current = true;
            prevMouseRef.current = { x: e.clientX, y: e.clientY };
        };

        const handleMouseMove = (e) => {
            if (!isDraggingRef.current || !rootGroupRef.current) return;
            const dx = e.clientX - prevMouseRef.current.x;
            const dy = e.clientY - prevMouseRef.current.y;
            
            rootGroupRef.current.rotation.y += dx * 0.01;
            // Optional X rotation limits
            // rootGroupRef.current.rotation.x += dy * 0.01; 
            
            prevMouseRef.current = { x: e.clientX, y: e.clientY };
        };

        const handleMouseUp = () => {
            isDraggingRef.current = false;
        };

        // --- Physics & Geometry Update Logic ---
        useEffect(() => {
            if (!rootGroupRef.current) return;
            
            const group = rootGroupRef.current;

            // Clear dynamic objects (find by name or type)
            // Easier: Remove everything except Grid (which is type GridHelper)
            for (let i = group.children.length - 1; i >= 0; i--) {
                const child = group.children[i];
                if (child.type !== 'GridHelper') {
                    group.remove(child);
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        if (child.material.map) child.material.map.dispose();
                        child.material.dispose();
                    }
                }
            }

            // 1. Add Charges
            charges.forEach(c => {
                const geo = new THREE.SphereGeometry(0.3, 16, 16);
                const mat = new THREE.MeshPhongMaterial({ 
                    color: c.q > 0 ? 0xff4444 : 0x3b82f6,
                    emissive: c.q > 0 ? 0x330000 : 0x000033
                });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.set(c.x, 0, c.z);
                group.add(mesh);
                
                // Stick
                const poleGeo = new THREE.CylinderGeometry(0.05, 0.05, 0.5, 8);
                const poleMat = new THREE.MeshBasicMaterial({ color: 0x64748b });
                const pole = new THREE.Mesh(poleGeo, poleMat);
                pole.position.set(c.x, -0.25, c.z);
                group.add(pole);
            });

            // 2. Generate 3D Potential Surface
            if (showMesh) {
                const size = 16;
                const segs = 64;
                const geo = new THREE.PlaneGeometry(size, size, segs, segs);
                const pos = geo.attributes.position;
                
                // V = kQ/r
                const k_const = 1.5; // Visual height scale

                for (let i = 0; i < pos.count; i++) {
                    const x = pos.getX(i);
                    const z = pos.getY(i); // Plane is XY initially
                    
                    let v = 0;
                    charges.forEach(c => {
                        const dist = Math.sqrt((x - c.x)**2 + (z - c.z)**2);
                        const safeDist = Math.max(0.4, dist); // Avoid infinity spike
                        v += c.q / safeDist;
                    });
                    
                    // Set Height (Z in geo, will be Y in world)
                    let h = v * k_const;
                    h = Math.max(-4, Math.min(4, h)); // Clamp
                    pos.setZ(i, h);
                }
                geo.computeVertexNormals();

                const mat = new THREE.MeshPhongMaterial({
                    color: 0x38bdf8,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.7,
                    shininess: 60,
                    flatShading: false
                });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.rotation.x = -Math.PI / 2;
                group.add(mesh);
            }

            // 3. Generate 2D Contours (Texture on Floor)
            if (showContours) {
                const cvs = document.createElement('canvas');
                cvs.width = 512;
                cvs.height = 512;
                const ctx = cvs.getContext('2d');
                
                // Fill dark
                ctx.fillStyle = '#0f172a';
                ctx.fillRect(0,0,512,512);

                const imgData = ctx.getImageData(0,0,512,512);
                const data = imgData.data;
                const size = 16;
                const scale = 2.0; // Contour spacing
                
                for (let y=0; y<512; y++) {
                    for (let x=0; x<512; x++) {
                        // World coords
                        const wx = (x/512 - 0.5) * size;
                        const wz = (y/512 - 0.5) * size;
                        
                        let v = 0;
                        for (let c of charges) {
                            const d = Math.sqrt((wx-c.x)**2 + (wz-c.z)**2);
                            v += c.q / Math.max(0.2, d);
                        }
                        
                        // Contour logic
                        const val = v * 2.0; // density
                        const interval = 1.0;
                        const rem = Math.abs(val % interval);
                        const isLine = rem < 0.1 || rem > 0.9;
                        
                        if (isLine) {
                            const idx = (y*512 + x)*4;
                            if (v > 0) { // Positive: Red
                                data[idx] = 239; data[idx+1] = 68; data[idx+2] = 68; 
                            } else { // Negative: Blue
                                data[idx] = 59; data[idx+1] = 130; data[idx+2] = 246; 
                            }
                            data[idx+3] = 255;
                        }
                    }
                }
                ctx.putImageData(imgData, 0, 0);
                
                const tex = new THREE.CanvasTexture(cvs);
                const planeGeo = new THREE.PlaneGeometry(size, size);
                const planeMat = new THREE.MeshBasicMaterial({ 
                    map: tex, 
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.8 
                });
                const plane = new THREE.Mesh(planeGeo, planeMat);
                plane.rotation.x = -Math.PI / 2;
                plane.position.y = -5; // Floor
                group.add(plane);
            }

        }, [charges, showMesh, showContours]); // Re-run when state changes


        // --- UI Handlers ---
        const addCharge = (q) => {
            const id = Date.now();
            const x = (Math.random() - 0.5) * 6;
            const z = (Math.random() - 0.5) * 6;
            setCharges([...charges, { x, z, q, id }]);
        };
        const removeCharge = (id) => setCharges(charges.filter(c => c.id !== id));
        const reset = () => {
            setCharges([{ x: -2, z: 0, q: 1, id: 1 }, { x: 2, z: 0, q: -1, id: 2 }]);
            if (rootGroupRef.current) rootGroupRef.current.rotation.y = 0;
            setAutoRotate(true);
        };

        return (
            <div className="h-screen bg-slate-900 text-slate-200 font-sans overflow-hidden flex flex-col">
                <nav className="bg-slate-800 border-b border-slate-700 px-4 py-2 flex items-center justify-between shrink-0 h-14">
                    <div className="flex items-center space-x-3">
                        <div className="bg-indigo-500/20 p-1.5 rounded-lg">
                            <i data-lucide="mountain" className="w-5 h-5 text-indigo-400"></i>
                        </div>
                        <h1 className="text-lg font-bold text-white tracking-wide">Equipotential Mapper 3D</h1>
                    </div>
                    <div className="text-[10px] text-slate-400 font-mono bg-slate-900 px-2 py-1 rounded-full border border-slate-700">
                        Topic: Electromagnetism
                    </div>
                </nav>

                <main className="flex-1 overflow-hidden">
                    <div className="h-full max-w-[1200px] mx-auto grid grid-cols-1 lg:grid-cols-4">
                        
                        {/* LEFT: 3D Viewport */}
                        <div className="lg:col-span-3 bg-slate-950 relative border-r border-slate-700">
                            <div 
                                ref={mountRef} 
                                className="w-full h-full cursor-move active:cursor-grabbing"
                                onMouseDown={handleMouseDown}
                                onMouseMove={handleMouseMove}
                                onMouseUp={handleMouseUp}
                                onMouseLeave={handleMouseUp}
                            />
                            
                            {/* Controls Overlay */}
                            <div className="absolute top-4 left-4 flex gap-2">
                                <button 
                                    onClick={() => setAutoRotate(!autoRotate)}
                                    className={`p-2 rounded border transition-all ${autoRotate ? 'bg-indigo-600 border-indigo-500 text-white' : 'bg-slate-800 border-slate-600 text-slate-400'}`}
                                    title="Auto Rotate"
                                >
                                    <i data-lucide="refresh-cw" className="w-4 h-4"></i>
                                </button>
                                <button 
                                    onClick={() => setShowMesh(!showMesh)}
                                    className={`p-2 rounded border transition-all ${showMesh ? 'bg-indigo-600 border-indigo-500 text-white' : 'bg-slate-800 border-slate-600 text-slate-400'}`}
                                    title="Toggle 3D Surface"
                                >
                                    <i data-lucide="layers" className="w-4 h-4"></i>
                                </button>
                                <button 
                                    onClick={() => setShowContours(!showContours)}
                                    className={`p-2 rounded border transition-all ${showContours ? 'bg-indigo-600 border-indigo-500 text-white' : 'bg-slate-800 border-slate-600 text-slate-400'}`}
                                    title="Toggle 2D Contours"
                                >
                                    <i data-lucide="map" className="w-4 h-4"></i>
                                </button>
                            </div>
                            
                            <div className="absolute bottom-4 left-4 bg-slate-900/80 p-3 rounded-xl border border-slate-700 text-xs text-slate-400 backdrop-blur pointer-events-none">
                                <div className="flex items-center gap-2 mb-1">
                                    <div className="w-3 h-3 rounded-full bg-red-500"></div> 
                                    <span>Positive (Mountain)</span>
                                </div>
                                <div className="flex items-center gap-2">
                                    <div className="w-3 h-3 rounded-full bg-blue-500"></div> 
                                    <span>Negative (Valley)</span>
                                </div>
                            </div>
                        </div>

                        {/* RIGHT: Controls */}
                        <div className="lg:col-span-1 bg-slate-900 border-l border-slate-700 flex flex-col h-full overflow-y-auto custom-scroll">
                            
                            {/* 1. Formula Panel */}
                            <div className="p-4 bg-slate-800/50 border-b border-slate-700 backdrop-blur sticky top-0 z-10">
                                <h3 className="text-xs font-bold text-slate-400 uppercase tracking-wider mb-3">Electric Potential (V)</h3>
                                <div className="bg-slate-900 p-4 rounded-xl border border-slate-700 text-center">
                                    <div className="text-lg font-mono font-bold text-white mb-1">V = &Sigma; kQ / r</div>
                                    <div className="text-[10px] text-slate-500">
                                        Scalar Sum (Superposition)
                                    </div>
                                </div>
                            </div>

                            {/* 2. Charge Manager */}
                            <div className="p-5 space-y-6 flex-1">
                                
                                <div>
                                    <label className="text-xs font-bold text-slate-300 mb-2 block">Add Charges</label>
                                    <div className="grid grid-cols-2 gap-2">
                                        <button 
                                            onClick={() => addCharge(1)}
                                            className="py-3 rounded bg-slate-800 border border-slate-600 hover:border-red-500 text-red-400 font-bold flex items-center justify-center gap-2 transition"
                                        >
                                            <i data-lucide="plus-circle" className="w-4 h-4"></i> +Q
                                        </button>
                                        <button 
                                            onClick={() => addCharge(-1)}
                                            className="py-3 rounded bg-slate-800 border border-slate-600 hover:border-blue-500 text-blue-400 font-bold flex items-center justify-center gap-2 transition"
                                        >
                                            <i data-lucide="minus-circle" className="w-4 h-4"></i> -Q
                                        </button>
                                    </div>
                                </div>

                                <div className="space-y-2">
                                    <div className="flex justify-between items-center text-xs font-bold text-slate-400 uppercase tracking-wider">
                                        Active Charges
                                        <button onClick={reset} className="text-[10px] text-indigo-400 hover:text-white">Reset</button>
                                    </div>
                                    
                                    <div className="space-y-1">
                                        {charges.map((c, i) => (
                                            <div key={c.id} className="flex justify-between items-center bg-slate-800 p-2 rounded border border-slate-700">
                                                <div className="flex items-center gap-2">
                                                    <div className={`w-2 h-2 rounded-full ${c.q > 0 ? 'bg-red-500' : 'bg-blue-500'}`}></div>
                                                    <span className="text-xs text-white">Charge {i+1} ({c.q > 0 ? '+Q' : '-Q'})</span>
                                                </div>
                                                <button onClick={() => removeCharge(c.id)} className="text-slate-500 hover:text-red-400">
                                                    <i data-lucide="x" className="w-3 h-3"></i>
                                                </button>
                                            </div>
                                        ))}
                                        {charges.length === 0 && (
                                            <div className="text-center text-xs text-slate-600 py-4 italic">No charges. Flat space.</div>
                                        )}
                                    </div>
                                </div>

                                <div className="mt-auto p-3 bg-indigo-900/10 border border-indigo-500/20 rounded-lg">
                                    <h4 className="text-indigo-400 font-bold text-xs mb-1 flex items-center">
                                        <i data-lucide="info" className="w-3 h-3 mr-1"></i> Analogy
                                    </h4>
                                    <p className="text-[10px] text-slate-400 leading-tight">
                                        Potential (V) is <strong>Height</strong>.
                                        <br/><br/>
                                        +Q are <strong>Mountains</strong>.
                                        <br/>
                                        -Q are <strong>Valleys</strong>.
                                        <br/>
                                        Field lines run downhill.
                                    </p>
                                </div>

                            </div>
                        </div>

                    </div>
                </main>
            </div>
        );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(
        <ErrorBoundary>
            <App />
        </ErrorBoundary>
    );
</script>
</body>
</html>
