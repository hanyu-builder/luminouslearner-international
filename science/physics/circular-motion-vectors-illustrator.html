<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Circular Motion Vectors | Luminous Learner</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@0.263.1"></script>

    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;700;900&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">

    <style>
        body { font-family: 'Inter', sans-serif; background-color: #0f172a; color: #e2e8f0; }
        .slider-thumb::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none; width: 16px; height: 16px;
            border-radius: 50%; cursor: pointer; border: 2px solid #ffffff;
        }
        .thumb-green::-webkit-slider-thumb { background: #10b981; }
        .thumb-blue::-webkit-slider-thumb { background: #3b82f6; }
    </style>
</head>
<body>

<div id="root"></div>

<script type="text/babel">
    const { useState, useEffect, useRef } = React;

    const CANVAS_WIDTH = 600;
    const CANVAS_HEIGHT = 450;
    const CENTER_X = CANVAS_WIDTH / 2;
    const CENTER_Y = CANVAS_HEIGHT / 2;
    const SCALE = 50; // Pixels per meter

    const App = () => {
        // --- State ---
        const [radius, setRadius] = useState(3.0); // Meters
        const [omega, setOmega] = useState(1.0); // rad/s
        const [isRunning, setIsRunning] = useState(false);
        const [showVelocity, setShowVelocity] = useState(true);
        const [showAcceleration, setShowAcceleration] = useState(true);
        const [showComponents, setShowComponents] = useState(false);

        // Real-time Data
        const [angle, setAngle] = useState(0); // Rads
        const [time, setTime] = useState(0);

        const canvasRef = useRef(null);
        const requestRef = useRef();
        const prevTimeRef = useRef(0);
        
        // Ref to track running state in loop
        const isRunningRef = useRef(false);

        // Calculated Physics
        const velocityMag = radius * omega; // v = r * w
        const accelMag = radius * omega * omega; // a = r * w^2

        // --- Logic ---
        const resetSim = () => {
            setIsRunning(false);
            isRunningRef.current = false;
            cancelAnimationFrame(requestRef.current);
            setAngle(0);
            setTime(0);
            // Force a draw at angle 0
            setTimeout(() => draw(0), 0);
        };

        const toggleSim = () => {
            if (isRunning) {
                setIsRunning(false);
                isRunningRef.current = false;
                cancelAnimationFrame(requestRef.current);
            } else {
                setIsRunning(true);
                isRunningRef.current = true;
                prevTimeRef.current = performance.now();
                requestRef.current = requestAnimationFrame(loop);
            }
        };

        const loop = (timestamp) => {
            if (!isRunningRef.current) return;

            const dt = (timestamp - prevTimeRef.current) / 1000;
            // Prevent huge jumps if tab was inactive
            const safeDt = Math.min(dt, 0.1); 
            
            prevTimeRef.current = timestamp;

            setAngle(prev => {
                const newAngle = (prev + omega * safeDt) % (2 * Math.PI);
                // Call draw directly from loop with new angle for smoothness
                // But we need radius/omega/flags which are state...
                // React state inside requestAnimationFrame closure might be stale if not careful.
                // However, draw() uses state variables.
                // Best practice: Use refs for animation variables or pass them.
                // For this simple app, we trigger state update which triggers useEffect draw.
                return newAngle;
            });
            
            setTime(t => t + safeDt);

            requestRef.current = requestAnimationFrame(loop);
        };

        // --- Rendering ---
        const draw = (currentAngle) => {
            const ctx = canvasRef.current?.getContext('2d');
            if (!ctx) return;

            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            // 1. Draw Axes & Grid
            ctx.strokeStyle = '#334155';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(CENTER_X, 0); ctx.lineTo(CENTER_X, CANVAS_HEIGHT);
            ctx.moveTo(0, CENTER_Y); ctx.lineTo(CANVAS_WIDTH, CENTER_Y);
            ctx.stroke();
            
            // Circle Path
            ctx.beginPath();
            ctx.arc(CENTER_X, CENTER_Y, radius * SCALE, 0, 2 * Math.PI);
            ctx.strokeStyle = '#475569';
            ctx.setLineDash([5, 5]);
            ctx.stroke();
            ctx.setLineDash([]);

            // 2. Object Position
            // Canvas Y is inverted relative to standard cartesian Y for math
            // Standard math: x = r cos(theta), y = r sin(theta) (y up)
            // Canvas: x = r cos(theta), y = -r sin(theta) (y down) to match CCW visual
            const px = CENTER_X + radius * SCALE * Math.cos(currentAngle);
            const py = CENTER_Y - radius * SCALE * Math.sin(currentAngle);

            // Radius Line
            ctx.beginPath();
            ctx.moveTo(CENTER_X, CENTER_Y);
            ctx.lineTo(px, py);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 2;
            ctx.stroke();

            // The Object
            ctx.beginPath();
            ctx.arc(px, py, 12, 0, 2 * Math.PI);
            ctx.fillStyle = '#facc15'; // Yellow
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();

            // 3. Vectors
            // Velocity (Tangent) - Perpendicular to Radius
            // Tangent direction is angle + 90 deg (PI/2)
            if (showVelocity) {
                const vScale = 15; // Visual scaling
                // Direction: In canvas coords (y flipped), tangent is angle + PI/2?
                // Let's verify: at angle 0 (Right), V is Up (neg Y). 
                // x=r, y=0. V should be (0, -1). 
                // angle=0. cos(0)=1, sin(0)=0.
                // Tangent angle = PI/2? cos(PI/2)=0, -sin(PI/2)=-1. Yes.
                const vAngle = currentAngle + Math.PI / 2; 
                
                // Note: drawArrow takes angle where +Y is DOWN. 
                // Math.sin(PI/2) is 1 (Down). We want Up (-1).
                // So we need to negate the sin component for drawing?
                // Actually, drawArrow uses standard canvas logic (y down).
                // If we want UP, we need negative Y component.
                // Angle PI/2 in canvas is DOWN. -PI/2 is UP.
                // So visual angle should be -(currentAngle + PI/2)?
                
                // Let's stick to standard math angle for calc, then flip Y for draw
                const mathVAngle = currentAngle + Math.PI / 2;
                const vx = velocityMag * Math.cos(mathVAngle);
                const vy = velocityMag * Math.sin(mathVAngle); // Math Y (Up is positive)
                
                // Canvas dy needs to be inverted (-vy)
                drawArrow(ctx, px, py, vx * vScale, -vy * vScale, '#10b981', 'v');
                
                // Components
                if (showComponents) {
                    drawComponent(ctx, px, py, vx * vScale, 0, '#10b981', 'vx');
                    drawComponent(ctx, px, py, 0, -vy * vScale, '#10b981', 'vy');
                }
            }

            // Acceleration (Centripetal) - Towards Center
            // Direction: Angle + 180 deg (PI)
            if (showAcceleration) {
                const aScale = 15;
                const mathAAngle = currentAngle + Math.PI; 
                
                const ax = accelMag * Math.cos(mathAAngle);
                const ay = accelMag * Math.sin(mathAAngle);

                drawArrow(ctx, px, py, ax * aScale, -ay * aScale, '#ef4444', 'a');

                // Components
                if (showComponents) {
                    drawComponent(ctx, px, py, ax * aScale, 0, '#ef4444', 'ax');
                    drawComponent(ctx, px, py, 0, -ay * aScale, '#ef4444', 'ay');
                }
            }
        };

        const drawArrow = (ctx, x, y, dx, dy, color, label) => {
            const toX = x + dx;
            const toY = y + dy;
            const angle = Math.atan2(dy, dx);
            
            ctx.beginPath();
            ctx.strokeStyle = color;
            ctx.lineWidth = 3;
            ctx.moveTo(x, y);
            ctx.lineTo(toX, toY);
            ctx.stroke();

            // Arrowhead
            const headLen = 8;
            ctx.beginPath();
            ctx.fillStyle = color;
            ctx.moveTo(toX, toY);
            ctx.lineTo(toX - headLen * Math.cos(angle - Math.PI/6), toY - headLen * Math.sin(angle - Math.PI/6));
            ctx.lineTo(toX - headLen * Math.cos(angle + Math.PI/6), toY - headLen * Math.sin(angle + Math.PI/6));
            ctx.fill();

            // Label
            ctx.fillStyle = color;
            ctx.font = 'bold 12px sans-serif';
            ctx.fillText(label, toX + 5, toY - 5);
        };

        const drawComponent = (ctx, x, y, dx, dy, color, label) => {
            ctx.beginPath();
            ctx.strokeStyle = color;
            ctx.lineWidth = 1;
            ctx.setLineDash([3, 3]);
            ctx.moveTo(x, y);
            ctx.lineTo(x + dx, y + dy);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Tip
            ctx.beginPath();
            ctx.fillStyle = color;
            ctx.arc(x + dx, y + dy, 2, 0, Math.PI*2);
            ctx.fill();
        };

        // Redraw when angle changes (Animation loop triggers this via setAngle)
        // Also redraw when params change
        useEffect(() => {
            draw(angle);
        }, [angle, radius, omega, showVelocity, showAcceleration, showComponents]);

        useEffect(() => {
            if (window.lucide) window.lucide.createIcons();
        });

        // Graph Component (Sine Waves)
        const Graph = () => {
            const canvasRef = useRef(null);
            
            useEffect(() => {
                const ctx = canvasRef.current?.getContext('2d');
                if(!ctx) return;
                
                const w = 300;
                const h = 100;
                ctx.clearRect(0,0,w,h);
                
                // Draw background line
                ctx.strokeStyle = '#334155';
                ctx.beginPath(); ctx.moveTo(0, h/2); ctx.lineTo(w, h/2); ctx.stroke();
                
                // Draw Sin Wave (Velocity Y component ~ Cosine)
                // Draw Cos Wave (Position X component ~ Cosine)
                
                ctx.lineWidth = 2;
                
                // Vx (Green - Sinusoidal)
                ctx.beginPath();
                ctx.strokeStyle = '#10b981';
                for(let i=0; i<w; i++) {
                    const phase = angle - (w - i) * 0.05; // Trail behind
                    const val = -Math.sin(phase) * 30; // Scale amplitude
                    if (i===0) ctx.moveTo(i, h/2 + val);
                    else ctx.lineTo(i, h/2 + val);
                }
                ctx.stroke();

                // Vy (Green Dashed - Cosinusoidal)
                ctx.beginPath();
                ctx.strokeStyle = '#059669'; // Darker green
                ctx.setLineDash([2,2]);
                for(let i=0; i<w; i++) {
                    const phase = angle - (w - i) * 0.05;
                    const val = Math.cos(phase) * 30;
                    if (i===0) ctx.moveTo(i, h/2 + val);
                    else ctx.lineTo(i, h/2 + val);
                }
                ctx.stroke();
                ctx.setLineDash([]);
                
            }, [angle]);

            return <canvas ref={canvasRef} width={300} height={100} className="w-full h-full" />;
        };

        return (
            <div className="min-h-screen bg-slate-900 text-slate-200 font-sans pb-12">
                <nav className="bg-slate-800 border-b border-slate-700 px-6 py-4 flex items-center justify-between sticky top-0 z-10">
                    <div className="flex items-center space-x-3">
                        <div className="bg-emerald-500/20 p-2 rounded-lg">
                            <i data-lucide="refresh-cw" className="w-6 h-6 text-emerald-400"></i>
                        </div>
                        <h1 className="text-xl font-bold text-white tracking-wide">Circular Motion Vectors</h1>
                    </div>
                    <div className="text-xs text-slate-400 font-mono bg-slate-900 px-3 py-1 rounded-full border border-slate-700">
                        Topic: Kinematics
                    </div>
                </nav>

                <main className="max-w-6xl mx-auto p-4 md:p-6 grid grid-cols-1 lg:grid-cols-12 gap-8">
                    
                    {/* Left: Simulation Canvas */}
                    <div className="lg:col-span-8 flex flex-col gap-6">
                        <div className="bg-slate-800 rounded-2xl border border-slate-700 p-1 shadow-2xl relative overflow-hidden">
                            <canvas 
                                ref={canvasRef} 
                                width={CANVAS_WIDTH} 
                                height={CANVAS_HEIGHT}
                                className="w-full h-auto bg-slate-950 rounded-xl"
                            />
                            
                            <div className="absolute top-4 left-4 bg-slate-900/80 px-3 py-2 rounded border border-slate-700 text-xs shadow-lg">
                                <div className="text-slate-400">Time</div>
                                <div className="font-mono text-white">{time.toFixed(2)}s</div>
                            </div>
                        </div>

                        {/* Controls */}
                        <div className="bg-slate-800 p-6 rounded-2xl border border-slate-700 flex flex-col gap-6">
                            
                            <div className="flex flex-wrap gap-8 items-center">
                                {/* Radius */}
                                <div className="flex-1 min-w-[200px]">
                                    <label className="flex justify-between text-xs text-blue-400 font-bold mb-1">
                                        Radius (r) <span>{radius.toFixed(1)}m</span>
                                    </label>
                                    <input 
                                        type="range" min="1.0" max="4.5" step="0.1" 
                                        value={radius} 
                                        onChange={(e) => setRadius(Number(e.target.value))}
                                        className="w-full h-1.5 bg-slate-700 rounded-lg slider-thumb thumb-blue" 
                                    />
                                </div>

                                {/* Omega */}
                                <div className="flex-1 min-w-[200px]">
                                    <label className="flex justify-between text-xs text-emerald-400 font-bold mb-1">
                                        Angular Speed (ω) <span>{omega.toFixed(1)} rad/s</span>
                                    </label>
                                    <input 
                                        type="range" min="0.1" max="5.0" step="0.1" 
                                        value={omega} 
                                        onChange={(e) => setOmega(Number(e.target.value))}
                                        className="w-full h-1.5 bg-slate-700 rounded-lg slider-thumb thumb-green" 
                                    />
                                </div>
                            </div>

                            <div className="flex flex-wrap gap-4 items-center justify-between border-t border-slate-700 pt-4">
                                <div className="flex gap-4">
                                    <label className="flex items-center gap-2 cursor-pointer">
                                        <input type="checkbox" checked={showVelocity} onChange={() => setShowVelocity(!showVelocity)} className="rounded text-emerald-500 bg-slate-700 border-slate-600 focus:ring-0"/>
                                        <span className="text-xs font-bold text-emerald-400">Velocity (v)</span>
                                    </label>
                                    <label className="flex items-center gap-2 cursor-pointer">
                                        <input type="checkbox" checked={showAcceleration} onChange={() => setShowAcceleration(!showAcceleration)} className="rounded text-red-500 bg-slate-700 border-slate-600 focus:ring-0"/>
                                        <span className="text-xs font-bold text-red-400">Acceleration (a)</span>
                                    </label>
                                    <label className="flex items-center gap-2 cursor-pointer">
                                        <input type="checkbox" checked={showComponents} onChange={() => setShowComponents(!showComponents)} className="rounded text-slate-500 bg-slate-700 border-slate-600 focus:ring-0"/>
                                        <span className="text-xs font-bold text-slate-400">Components</span>
                                    </label>
                                </div>

                                <div className="flex gap-2">
                                    <button 
                                        onClick={toggleSim}
                                        className={`px-6 py-2 rounded-lg font-bold flex items-center shadow-lg transition-all ${isRunning ? 'bg-slate-700 text-white' : 'bg-emerald-600 hover:bg-emerald-500 text-white'}`}
                                    >
                                        <i data-lucide={isRunning ? "pause" : "play"} className="w-4 h-4 mr-2"></i>
                                        {isRunning ? 'Pause' : 'Start'}
                                    </button>
                                    <button 
                                        onClick={resetSim}
                                        className="px-4 py-2 bg-slate-700 hover:bg-slate-600 text-white rounded-lg font-bold transition-colors flex items-center"
                                    >
                                        <i data-lucide="rotate-ccw" className="w-4 h-4 mr-2"></i>
                                        Reset
                                    </button>
                                </div>
                            </div>

                        </div>
                    </div>

                    {/* Right: Data & Analysis */}
                    <div className="lg:col-span-4 space-y-6">
                        
                        {/* Data Cards */}
                        <div className="grid grid-cols-1 gap-4">
                            <div className="bg-emerald-900/10 border border-emerald-500/20 p-4 rounded-xl flex justify-between items-center">
                                <div>
                                    <div className="text-emerald-400 text-xs font-bold uppercase mb-1">Tangential Velocity ($v$)</div>
                                    <div className="text-xs text-slate-500">$v = r \omega$</div>
                                </div>
                                <div className="text-2xl font-mono font-bold text-white">{velocityMag.toFixed(2)} <span className="text-sm text-slate-500">m/s</span></div>
                            </div>

                            <div className="bg-red-900/10 border border-red-500/20 p-4 rounded-xl flex justify-between items-center">
                                <div>
                                    <div className="text-red-400 text-xs font-bold uppercase mb-1">Centripetal Accel ($a_c$)</div>
                                    <div className="text-xs text-slate-500">$a = r \omega^2 = v^2 / r$</div>
                                </div>
                                <div className="text-2xl font-mono font-bold text-white">{accelMag.toFixed(2)} <span className="text-sm text-slate-500">m/s²</span></div>
                            </div>
                        </div>

                        {/* Concept Box */}
                        <div className="bg-slate-800 p-5 rounded-2xl border border-slate-700 text-sm leading-relaxed text-slate-300">
                            <h3 className="text-white font-bold mb-2 flex items-center">
                                <i data-lucide="lightbulb" className="w-4 h-4 mr-2 text-yellow-400"></i>
                                Why is there Acceleration?
                            </h3>
                            <p className="mb-2">
                                Even though the speed ($v$) is constant, the <strong>direction</strong> is always changing.
                            </p>
                            <p>
                                Velocity is a vector (Speed + Direction). A change in direction requires a force (and acceleration) pulling towards the center. This is <strong>Centripetal Acceleration</strong>.
                            </p>
                        </div>

                        {/* Graph Preview */}
                        <div className="bg-slate-800 p-4 rounded-2xl border border-slate-700 h-32 relative flex items-center justify-center">
                            <div className="absolute top-2 left-2 text-[10px] text-slate-500 uppercase font-bold">Velocity Components (Vx, Vy)</div>
                            <Graph />
                        </div>

                    </div>

                </main>
            </div>
        );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
</script>
</body>
</html>
