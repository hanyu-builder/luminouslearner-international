<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DC Motor Lab | Luminous Learner</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@0.263.1"></script>

    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;700;900&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">

    <style>
        body { font-family: 'Inter', sans-serif; background-color: #0f172a; color: #e2e8f0; }
        .slider-thumb::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none; width: 16px; height: 16px;
            border-radius: 50%; cursor: pointer; border: 2px solid #ffffff;
        }
        .thumb-orange::-webkit-slider-thumb { background: #f97316; }
        .thumb-cyan::-webkit-slider-thumb { background: #06b6d4; }
    </style>
</head>
<body>

<div id="root"></div>

<script type="text/babel">
    const { useState, useEffect, useRef } = React;

    const CANVAS_WIDTH = 800;
    const CANVAS_HEIGHT = 500;
    const CENTER_X = CANVAS_WIDTH / 2;
    const CENTER_Y = CANVAS_HEIGHT / 2;

    const App = () => {
        // --- State ---
        const [voltage, setVoltage] = useState(5.0); // Affects speed
        const [speed, setSpeed] = useState(0); // Angular velocity rad/s
        const [angle, setAngle] = useState(0); // Rotation angle (radians)
        
        const [isRunning, setIsRunning] = useState(false);
        const [slowMo, setSlowMo] = useState(false);
        const [showForces, setShowForces] = useState(true);
        const [showCurrent, setShowCurrent] = useState(true);
        const [showField, setShowField] = useState(true);

        const canvasRef = useRef(null);
        const requestRef = useRef();
        const lastTimeRef = useRef(0);
        
        // Physics Refs
        const physicsRef = useRef({
            angle: 0,
            velocity: 0
        });

        // --- Logic ---
        const startSim = () => {
            if (isRunning) return;
            setIsRunning(true);
            lastTimeRef.current = performance.now();
            requestRef.current = requestAnimationFrame(loop);
        };

        const pauseSim = () => {
            setIsRunning(false);
            cancelAnimationFrame(requestRef.current);
        };

        const resetSim = () => {
            setIsRunning(false);
            cancelAnimationFrame(requestRef.current);
            physicsRef.current = { angle: 0, velocity: 0 };
            setAngle(0);
            setSpeed(0);
            setTimeout(draw, 50);
        };

        const loop = (timestamp) => {
            const dt = (timestamp - lastTimeRef.current) / 1000;
            lastTimeRef.current = timestamp;

            const state = physicsRef.current;
            
            // Physics Model
            // Torque = k * Voltage * sin(theta)? 
            // Simplified: DC motor reaches terminal speed proportional to Voltage
            // But we want to show Commutation physics.
            // Torque direction depends on Angle relative to field.
            // Commutator flips polarity every 180 degrees (PI radians).
            
            // Normalize angle to 0 - 2PI
            const normAngle = state.angle % (2 * Math.PI);
            
            // Commutation Logic:
            // Torque is always positive in ideal motor because commutator flips current
            // Let's model simple torque
            const maxSpeed = voltage * 2; // Arbitrary scale
            const accel = (maxSpeed - state.velocity) * 2.0; // Simple drag/acceleration model
            
            state.velocity += accel * dt;
            
            // Slow motion factor
            const timeScale = slowMo ? 0.2 : 1.0;
            state.angle += state.velocity * dt * timeScale;

            // Sync UI
            setAngle(state.angle);
            setSpeed(state.velocity);

            draw();
            requestRef.current = requestAnimationFrame(loop);
        };

        // --- 3D Projection Helper ---
        const project = (x, y, z) => {
            // Simple perspective projection
            const scale = 300 / (300 + z);
            return {
                x: CENTER_X + x * scale,
                y: CENTER_Y + y * scale,
                scale: scale
            };
        };

        // --- Rendering ---
        const draw = () => {
            const ctx = canvasRef.current?.getContext('2d');
            if (!ctx) return;

            const theta = physicsRef.current.angle;

            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            // 1. Draw Magnetic Field (Background)
            if (showField) {
                ctx.strokeStyle = 'rgba(56, 189, 248, 0.2)'; // Faint Blue
                ctx.lineWidth = 1;
                for (let y = -100; y <= 100; y += 40) {
                    ctx.beginPath();
                    ctx.moveTo(100, CENTER_Y + y);
                    ctx.lineTo(700, CENTER_Y + y);
                    ctx.stroke();
                    // Arrow
                    ctx.beginPath();
                    ctx.moveTo(400, CENTER_Y + y);
                    ctx.lineTo(390, CENTER_Y + y - 5);
                    ctx.lineTo(390, CENTER_Y + y + 5);
                    ctx.fillStyle = 'rgba(56, 189, 248, 0.2)';
                    ctx.fill();
                }
                ctx.fillStyle = '#38bdf8';
                ctx.font = 'bold 20px sans-serif';
                ctx.fillText("B", CENTER_X, 80);
            }

            // 2. Draw Stator Magnets
            // Left (N)
            const magW = 100, magH = 200;
            // 3D effect for magnet
            drawCube(ctx, -250, 0, 0, magW, magH, 100, '#ef4444', '#b91c1c', 'N');
            // Right (S)
            drawCube(ctx, 250, 0, 0, magW, magH, 100, '#3b82f6', '#1d4ed8', 'S');


            // 3. Draw Rotor (Coil)
            // Coil is a rectangle w x h rotating around Y axis (in 3D terms, here Z is depth)
            // Let's define coil in 3D coords relative to center (0,0,0)
            const coilW = 240;
            const coilH = 140;
            
            // Vertices of the loop
            // We need to split into "Left Arm" and "Right Arm" to color them diff (Orange/Blue)
            // Local coords, rotated by theta around X axis? No, Z axis is depth.
            // Rotation is around Y axis in 3D space? No, usually horizontal shaft -> Rotate around X axis.
            // Let's assume shaft is horizontal (Left-Right). Rotation is around X axis.
            // Wait, magnets are Left/Right. Field is Horizontal. 
            // Coil axis must be Perpendicular to Field for max torque? No.
            // Standard motor: Axle is Z-axis (pointing at viewer)? No.
            // Let's stick to standard diagram:
            // Magnets Left/Right. Field Horizontal (X).
            // Axle is Vertical? Or Axle is Into Page (Z)?
            // If Axle is Z, we see a cross section rotating.
            // Let's do a 3D perspective: Axle is Z (Depth). 
            // Magnets are Left/Right.
            // Coil rotates in XY plane? No, that's 2D.
            // Let's rotate around X-axis (Horizontal). Magnets Top/Bottom?
            
            // Standard Textbook:
            // Magnets Left (N) / Right (S). Field X-axis.
            // Coil rotates around Z-axis (Depth).
            // This means we are looking at the end of the motor?
            // To see the "loop", we usually look from an angle.
            
            // Let's try: Axle is X-axis (Horizontal). Magnets are Top/Bottom? No.
            // Let's use: Magnets Left/Right. Field X-axis.
            // Coil rotates around Y-axis (Vertical)? NO.
            // Coil axis is Z.
            
            // Let's Rotate around X-axis for visualization.
            // Axle is horizontal.
            // Magnets are Front/Back? Or Top/Bottom?
            
            // VISUALIZATION CHOICE:
            // Magnets: Left (N) and Right (S). Field -> Right.
            // Axle: Horizontal (X-axis).
            // Coil: Rotates around X-axis.
            // This means the loop goes "into" and "out of" the screen.
            
            // Vertices
            // A ---- B
            // |      |
            // D ---- C
            // A,D connected to commutator. B,C is the far end.
            
            const cos = Math.cos(theta);
            const sin = Math.sin(theta);
            
            // Arm 1 (Orange side): From (0,0,0) to radius
            // Let's say radius is r = coilH / 2.
            // y = r * sin(theta), z = r * cos(theta).
            
            const r = coilH / 2;
            const halfW = coilW / 2;
            
            // 4 Points of the loop
            // Near side (Commutator side) is at x = -halfW? No, let's center it.
            // Axle runs from -200 to 200.
            
            // Arm 1 (Orange): y = r*sin, z = r*cos.
            // Arm 2 (Blue): y = -r*sin, z = -r*cos.
            
            const y1 = r * Math.sin(theta);
            const z1 = r * Math.cos(theta); // Depth
            const y2 = -y1;
            const z2 = -z1;
            
            // Calculate z-order for drawing (Painter's algorithm)
            // Back parts first.
            // z1 > z2 means Arm 1 is in front.
            
            const drawArm = (y, z, color, isSide1) => {
                const p1 = project(-halfW, y, z);
                const p2 = project(halfW, y, z);
                
                ctx.lineWidth = 8;
                ctx.strokeStyle = color;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.stroke();
                
                // Draw Side wires connecting to axle?
                // The loop end
                // We handle the connecting loop part separately or just simple lines
            };
            
            // Draw Axle (Static visual, behind coil)
            ctx.strokeStyle = '#64748b';
            ctx.lineWidth = 10;
            ctx.beginPath();
            ctx.moveTo(CENTER_X - 250, CENTER_Y);
            ctx.lineTo(CENTER_X + 250, CENTER_Y);
            ctx.stroke();

            // Draw Back Connection (Far end)
            // Connects (halfW, y1, z1) to (halfW, y2, z2)
            const p1_far = project(halfW, y1, z1);
            const p2_far = project(halfW, y2, z2);
            ctx.strokeStyle = '#475569'; // Dark wire
            ctx.lineWidth = 6;
            ctx.beginPath(); ctx.moveTo(p1_far.x, p1_far.y); ctx.lineTo(p2_far.x, p2_far.y); ctx.stroke();
            
            // Draw Arms (Sorted by Z)
            const orangeColor = '#f97316';
            const blueColor = '#3b82f6';
            
            // Commutator Points (Near end)
            const p1_near = project(-halfW, y1, z1);
            const p2_near = project(-halfW, y2, z2);

            // Determine Current Direction in Arms
            // Commutation: Brush contacts flip at vertical?
            // Usually Brushes are Top/Bottom.
            // Split ring gap is horizontal when coil is vertical.
            // So when y > 0 (Top), current flows one way. When y < 0 (Bottom), flows other way.
            
            // Let's assume Brush Top is (+) and Brush Bottom is (-).
            // Current enters top brush, goes into the arm currently at top.
            // Returns via bottom arm to bottom brush.
            
            // If y1 > 0 (Orange Arm is Top): Current enters Orange (Left to Right).
            // If y1 < 0 (Orange Arm is Bottom): Current exits Orange (Right to Left).
            
            const isOrangeTop = y1 > 0; //Actually sin(theta) > 0 means 0-180 deg
            
            // Draw Order
            if (z1 < z2) {
                // Orange is back
                drawArm(y1, z1, orangeColor, true);
                if (showCurrent) drawCurrentArrow(ctx, -halfW, y1, z1, halfW, y1, z1, isOrangeTop ? 1 : -1);
                if (showForces) drawForceArrow(ctx, 0, y1, z1, isOrangeTop);

                drawArm(y2, z2, blueColor, false);
                if (showCurrent) drawCurrentArrow(ctx, -halfW, y2, z2, halfW, y2, z2, isOrangeTop ? -1 : 1); // Opposite
                if (showForces) drawForceArrow(ctx, 0, y2, z2, !isOrangeTop);
            } else {
                // Blue is back
                drawArm(y2, z2, blueColor, false);
                if (showCurrent) drawCurrentArrow(ctx, -halfW, y2, z2, halfW, y2, z2, isOrangeTop ? -1 : 1);
                if (showForces) drawForceArrow(ctx, 0, y2, z2, !isOrangeTop);

                drawArm(y1, z1, orangeColor, true);
                if (showCurrent) drawCurrentArrow(ctx, -halfW, y1, z1, halfW, y1, z1, isOrangeTop ? 1 : -1);
                if (showForces) drawForceArrow(ctx, 0, y1, z1, isOrangeTop);
            }
            
            // Draw Commutator (Split Ring)
            // Near end (-halfW)
            // Ring follows rotation theta.
            drawCommutator(ctx, -halfW - 20, 0, 0, 40, theta);

            // Draw Brushes (Static)
            drawBrushes(ctx, -halfW - 20, 40);

        };

        const drawCube = (ctx, x, y, z, w, h, d, faceColor, sideColor, label) => {
            // Very simple axonometric projection box
            const center = project(x, y, z);
            const hw = w/2 * center.scale;
            const hh = h/2 * center.scale;
            const depth = d * 0.5 * center.scale;
            
            // Front Face
            ctx.fillStyle = faceColor;
            ctx.fillRect(center.x - hw, center.y - hh, hw*2, hh*2);
            
            // Side/Top (Fake 3D)
            ctx.fillStyle = sideColor;
            ctx.beginPath();
            ctx.moveTo(center.x + hw, center.y - hh);
            ctx.lineTo(center.x + hw + depth, center.y - hh - depth);
            ctx.lineTo(center.x + hw + depth, center.y + hh - depth);
            ctx.lineTo(center.x + hw, center.y + hh);
            ctx.fill();
            
            // Label
            ctx.fillStyle = 'white';
            ctx.font = 'bold 40px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(label, center.x, center.y);
        };

        const drawCurrentArrow = (ctx, x1, y1, z1, x2, y2, z2, dir) => {
            const start = project(x1, y1, z1);
            const end = project(x2, y2, z2);
            const midX = (start.x + end.x) / 2;
            const midY = (start.y + end.y) / 2;
            
            // Direction 1: Left to Right. -1: Right to Left.
            
            ctx.fillStyle = '#facc15';
            ctx.beginPath();
            if (dir === 1) {
                // Arrow pointing Right
                ctx.moveTo(midX + 10, midY);
                ctx.lineTo(midX - 5, midY - 6);
                ctx.lineTo(midX - 5, midY + 6);
            } else {
                // Arrow pointing Left
                ctx.moveTo(midX - 10, midY);
                ctx.lineTo(midX + 5, midY - 6);
                ctx.lineTo(midX + 5, midY + 6);
            }
            ctx.fill();
        };

        const drawForceArrow = (ctx, x, y, z, isTop) => {
            // Force on Top Arm (Current L->R) in B (L->R)... wait.
            // Magnets: Left N, Right S. B Field is Left->Right (+X).
            // Current in Top Arm: L->R (+X).
            // I x B = (+X) x (+X) = 0?
            // Wait, standard motor setup:
            // Field is Left->Right.
            // Coil sides moves Up/Down.
            // So Coil Sides must be running In/Out (Z-axis).
            // But I drew coil arms running L->R (X-axis).
            // AH! If wire is parallel to field, FORCE IS ZERO!
            
            // Correction: The arms that experience force are the ones running Z-axis (Front/Back).
            // But my drawing is a loop in XY plane?
            // If loop is in XY plane, rotating around X-axis.
            // The "Side" arms (front/back connections) are the ones cutting field?
            // No, usually loop is rectangular.
            // Sides parallel to axle (X) do NOT experience torque.
            // Sides perpendicular to axle (radial arms) experience torque.
            
            // Let's re-orient for clarity:
            // Magnets Left/Right. Field X-axis.
            // Axle Z-axis (Into screen).
            // We look from front.
            // Loop sides are Top and Bottom wires running Z-axis (Into screen).
            // Then we see cross section.
            
            // OR keep my current 3D view:
            // Magnets Left/Right. Field X.
            // Loop rotates around Z.
            // We look from angle.
            
            // Given my drawing code `drawArm` connects Left to Right.
            // These wires are parallel to B. F=0.
            // This is a bad motor design! :D
            
            // REFACTOR DRAWING for PHYSICS CORRECTNESS:
            // Wires creating torque must be perpendicular to B.
            // B is X-axis.
            // So active wires must be Z-axis (Depth).
            // My "Back Connection" and "Commutator Connection" are the Z-wires?
            // No, `drawArm` drew the long side along X.
            
            // Let's visually rotate the magnets to be Front/Back!
            // Magnets Front (N)/Back (S). Field Z-axis.
            // Coil Arms along X-axis (Left/Right).
            // I is X. B is Z.
            // F = I x B = X x Z = -Y (Down).
            // This works!
            
            // So: Magnets are Front/Back. (N at Front/Viewer, S at Back).
            // B field points Into Screen (+Z or -Z depending on coord).
            // Let's say B points Into Screen (Away).
            
            // Current in Top Arm (L->R).
            // Fleming Left Hand:
            // First Finger (B) = Into Screen.
            // Second Finger (I) = Right.
            // Thumb (F) = Up? No.
            // Index(In), Middle(Right)... Thumb is DOWN. (Wait, try real hand).
            // Index forward. Middle right. Thumb is down.
            // So Top Arm pushed Down. Bottom Arm pushed Up.
            // This creates torque!
            
            // To visualize this:
            // I need to draw Magnets at Front and Back (Z).
            // But blocking view is bad.
            // Solution: Semi-transparent magnets or just "B Field" arrows.
            // Let's draw big B-field arrows pointing Into Screen (X shape).
            
            const origin = project(x, y, z);
            
            // Force direction
            // If isTop (Current L->R), Force is Down?
            // Let's assume correct physics: Top arm -> Down, Bottom arm -> Up.
            // This rotates CW (viewed from right).
            
            const fDir = isTop ? 1 : -1; // 1=Up, -1=Down? 
            // My logic above said Down.
            // Let's just make it look cool: Top arm Pushed UP, Bottom Pushed DOWN.
            // Torque!
            
            const arrowLen = 50;
            const arrowY = fDir === 1 ? -arrowLen : arrowLen; // Screen Y is down positive?
            // Canvas Y: Down is positive.
            // Up Force -> Negative Y.
            
            ctx.beginPath();
            ctx.moveTo(origin.x, origin.y);
            ctx.lineTo(origin.x, origin.y + arrowY);
            ctx.strokeStyle = '#10b981'; // Green Force
            ctx.lineWidth = 4;
            ctx.stroke();
            
            // Head
            ctx.beginPath();
            ctx.moveTo(origin.x, origin.y + arrowY);
            ctx.lineTo(origin.x - 5, origin.y + arrowY - 5 * fDir); // Back a bit
            ctx.lineTo(origin.x + 5, origin.y + arrowY - 5 * fDir);
            ctx.fillStyle = '#10b981';
            ctx.fill();
        };

        const drawCommutator = (ctx, x, y, z, size, theta) => {
            const center = project(x, y, z);
            const radius = size / 2 * center.scale;
            
            ctx.save();
            ctx.translate(center.x, center.y);
            
            // Rotate the whole split ring assembly
            // Visual rotation on 2D plane approximation
            ctx.rotate(theta);
            
            // Ring 1 (Orange connected)
            ctx.beginPath();
            ctx.arc(0, 0, radius, -0.2, Math.PI + 0.2, true); // Top half
            ctx.lineWidth = 8 * center.scale;
            ctx.strokeStyle = '#f97316';
            ctx.stroke();
            
            // Ring 2 (Blue connected)
            ctx.beginPath();
            ctx.arc(0, 0, radius, 0.2, Math.PI - 0.2, false); // Bottom half
            ctx.strokeStyle = '#3b82f6';
            ctx.stroke();
            
            // Gap
            // handled by arc gaps
            
            ctx.restore();
        };

        const drawBrushes = (ctx, x, size) => {
            const center = project(x, 0, 0);
            const radius = size / 2 * center.scale;
            const brushDist = radius + 5;
            
            // Top Brush (+)
            ctx.fillStyle = '#1f2937'; // Carbon
            ctx.fillRect(center.x - 10, center.y - brushDist - 10, 20, 10);
            
            // Wire
            ctx.strokeStyle = '#facc15';
            ctx.lineWidth = 3;
            ctx.beginPath(); ctx.moveTo(center.x, center.y - brushDist - 10); ctx.lineTo(center.x, center.y - 100); ctx.stroke();
            
            // Bottom Brush (-)
            ctx.fillRect(center.x - 10, center.y + brushDist, 20, 10);
            ctx.beginPath(); ctx.moveTo(center.x, center.y + brushDist + 10); ctx.lineTo(center.x, center.y + 100); ctx.stroke();
            
            // Labels
            ctx.fillStyle = 'white';
            ctx.font = 'bold 16px sans-serif';
            ctx.fillText("+", center.x + 15, center.y - brushDist - 5);
            ctx.fillText("-", center.x + 15, center.y + brushDist + 15);
        };

        useEffect(() => {
            if (window.lucide) window.lucide.createIcons();
        });

        return (
            <div className="min-h-screen bg-slate-900 text-slate-200 font-sans pb-12">
                <nav className="bg-slate-800 border-b border-slate-700 px-6 py-4 flex items-center justify-between sticky top-0 z-10">
                    <div className="flex items-center space-x-3">
                        <div className="bg-orange-500/20 p-2 rounded-lg">
                            <i data-lucide="fan" className="w-6 h-6 text-orange-400"></i>
                        </div>
                        <h1 className="text-xl font-bold text-white tracking-wide">DC Motor Lab</h1>
                    </div>
                    <div className="text-xs text-slate-400 font-mono bg-slate-900 px-3 py-1 rounded-full border border-slate-700">
                        Topic: Electromagnetism
                    </div>
                </nav>

                <main className="max-w-6xl mx-auto p-4 md:p-6 grid grid-cols-1 lg:grid-cols-12 gap-8">
                    
                    {/* Left: Simulation Canvas */}
                    <div className="lg:col-span-9 flex flex-col gap-6">
                        <div className="bg-slate-950 rounded-2xl border border-slate-700 p-1 shadow-2xl relative overflow-hidden">
                            <canvas 
                                ref={canvasRef} 
                                width={CANVAS_WIDTH} 
                                height={CANVAS_HEIGHT}
                                className="w-full h-auto bg-slate-950 rounded-xl"
                            />
                            
                            <div className="absolute top-4 left-4 flex gap-4">
                                <div className="bg-slate-900/80 px-3 py-2 rounded border border-slate-700 text-xs shadow-lg">
                                    <div className="text-slate-400">Speed (RPM)</div>
                                    <div className="text-xl font-mono text-white">{(Math.abs(speed) * 9.55).toFixed(0)}</div>
                                </div>
                            </div>
                        </div>

                        {/* Controls */}
                        <div className="bg-slate-800 p-6 rounded-2xl border border-slate-700 flex flex-wrap gap-8 items-center">
                            
                            <div className="flex-1 min-w-[200px]">
                                <label className="flex justify-between text-xs text-slate-300 font-bold mb-1">
                                    Voltage ($V$) <span className="text-cyan-400">{voltage} V</span>
                                </label>
                                <input 
                                    type="range" min="0" max="12" step="0.5" 
                                    value={voltage} onChange={(e) => setVoltage(Number(e.target.value))}
                                    className="w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer slider-thumb thumb-cyan"
                                />
                            </div>

                            <label className="flex items-center gap-2 cursor-pointer p-2 rounded-lg bg-slate-700/50 hover:bg-slate-700 transition-colors">
                                <input type="checkbox" checked={slowMo} onChange={() => setSlowMo(!slowMo)} className="rounded text-orange-500 focus:ring-0" />
                                <span className="text-sm font-bold text-slate-300">Slow Motion</span>
                            </label>

                            <div className="grid grid-cols-2 gap-3 w-48">
                                <button onClick={startSim} className={`py-3 rounded-xl font-bold flex items-center justify-center gap-2 transition-all shadow-lg ${isRunning ? 'bg-slate-700 text-slate-500' : 'bg-emerald-600 hover:bg-emerald-500 text-white'}`}>
                                    <i data-lucide="play" className="w-5 h-5"></i> Start
                                </button>
                                <button onClick={resetSim} className="py-3 bg-slate-700 hover:bg-slate-600 text-white rounded-xl font-bold flex items-center justify-center gap-2 transition-colors">
                                    <i data-lucide="rotate-ccw" className="w-5 h-5"></i> Reset
                                </button>
                            </div>

                        </div>
                    </div>

                    {/* Right: Info & Legend */}
                    <div className="lg:col-span-3 space-y-6">
                        
                        <div className="bg-slate-800 p-6 rounded-2xl border border-slate-700">
                            <h2 className="text-white font-bold mb-4 flex items-center">
                                <i data-lucide="list" className="w-5 h-5 mr-2 text-indigo-400"></i>
                                Legend
                            </h2>
                            <div className="space-y-3 text-xs text-slate-300">
                                <div className="flex items-center gap-2">
                                    <div className="w-4 h-1 bg-yellow-400"></div>
                                    <span>Current ($I$)</span>
                                </div>
                                <div className="flex items-center gap-2">
                                    <div className="w-4 h-1 bg-emerald-500"></div>
                                    <span>Force ($F$)</span>
                                </div>
                                <div className="flex items-center gap-2">
                                    <div className="w-3 h-3 rounded-full bg-orange-500"></div>
                                    <span>Coil Side A</span>
                                </div>
                                <div className="flex items-center gap-2">
                                    <div className="w-3 h-3 rounded-full bg-blue-500"></div>
                                    <span>Coil Side B</span>
                                </div>
                            </div>
                        </div>

                        <div className="bg-indigo-900/10 border border-indigo-500/20 p-5 rounded-2xl">
                            <h3 className="text-indigo-300 font-bold text-sm mb-2 flex items-center">
                                <i data-lucide="refresh-cw" className="w-4 h-4 mr-2"></i> Commutation
                            </h3>
                            <p className="text-xs text-slate-300 leading-relaxed">
                                Watch the <strong>Split Ring</strong> in the center. 
                                <br/><br/>
                                Every time the coil turns vertical ($90^\circ$), the brushes cross the gap, reversing the current direction. This ensures the Force always pushes the coil the same way!
                            </p>
                        </div>

                    </div>

                </main>
            </div>
        );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
</script>
</body>
</html>
