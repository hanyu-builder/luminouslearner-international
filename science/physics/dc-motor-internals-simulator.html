<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DC Motor Lab | Luminous Learner</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@0.263.1"></script>

    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;700;900&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">

    <style>
        body { font-family: 'Inter', sans-serif; background-color: #0f172a; color: #e2e8f0; }
        .slider-thumb::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none; width: 16px; height: 16px;
            border-radius: 50%; cursor: pointer; border: 2px solid #ffffff;
        }
        .thumb-orange::-webkit-slider-thumb { background: #f97316; }
        .thumb-cyan::-webkit-slider-thumb { background: #06b6d4; }
    </style>
</head>
<body>

<div id="root"></div>

<script type="text/babel">
    const { useState, useEffect, useRef } = React;

    const CANVAS_WIDTH = 800;
    const CANVAS_HEIGHT = 450;
    const CENTER_X = CANVAS_WIDTH / 2;
    const CENTER_Y = CANVAS_HEIGHT / 2;

    const App = () => {
        // --- State ---
        const [voltage, setVoltage] = useState(5.0); // Affects speed
        const [speed, setSpeed] = useState(0); // Angular velocity rad/s
        const [angle, setAngle] = useState(0); // Rotation angle (radians)
        
        const [isRunning, setIsRunning] = useState(false);
        const [slowMo, setSlowMo] = useState(false);
        
        // --- Refs for Animation Loop (Source of Truth) ---
        const canvasRef = useRef(null);
        const requestRef = useRef();
        const lastTimeRef = useRef(0);
        
        // Physics Refs
        const physicsRef = useRef({
            angle: 0,
            velocity: 0
        });
        
        // Parameter Refs (To avoid stale closures in loop)
        const paramsRef = useRef({
            voltage: 5.0,
            slowMo: false
        });

        // Sync State to Refs
        useEffect(() => {
            paramsRef.current = { voltage, slowMo };
        }, [voltage, slowMo]);

        // --- Logic ---
        const startSim = () => {
            if (isRunning) return;
            setIsRunning(true);
            lastTimeRef.current = performance.now();
            requestRef.current = requestAnimationFrame(loop);
        };

        const resetSim = () => {
            setIsRunning(false);
            cancelAnimationFrame(requestRef.current);
            physicsRef.current = { angle: 0, velocity: 0 };
            setAngle(0);
            setSpeed(0);
            // Force redraw immediately
            setTimeout(() => draw(), 10);
        };

        const loop = (timestamp) => {
            const dt = (timestamp - lastTimeRef.current) / 1000;
            lastTimeRef.current = timestamp;

            const state = physicsRef.current;
            const { voltage, slowMo } = paramsRef.current;
            
            // Physics Model
            // Target speed is proportional to voltage
            const maxSpeed = voltage * 4; // Scale factor
            
            // Acceleration/Drag model to reach max speed smoothly
            const accel = (maxSpeed - state.velocity) * 2.0; 
            
            state.velocity += accel * dt;
            
            // Apply speed to angle
            // Slow motion factor
            const timeScale = slowMo ? 0.2 : 1.0;
            state.angle += state.velocity * dt * timeScale;

            // Sync UI state occasionally (every frame is fine for this simple app)
            setAngle(state.angle);
            setSpeed(state.velocity);

            draw();
            requestRef.current = requestAnimationFrame(loop);
        };

        // --- 3D Projection Helper ---
        const project = (x, y, z) => {
            const scale = 300 / (300 + z);
            return {
                x: CENTER_X + x * scale,
                y: CENTER_Y + y * scale,
                scale: scale
            };
        };

        // --- Rendering ---
        const draw = () => {
            const ctx = canvasRef.current?.getContext('2d');
            if (!ctx) return;

            const theta = physicsRef.current.angle;
            const { voltage } = paramsRef.current;

            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            // 1. Draw Magnetic Field (Enhanced)
            // Field lines from N (Left) to S (Right)
            ctx.lineWidth = 1;
            const fieldSpacing = 40;
            
            for (let y = -120; y <= 120; y += fieldSpacing) {
                // Fading lines
                const grad = ctx.createLinearGradient(150, 0, 650, 0);
                grad.addColorStop(0, 'rgba(56, 189, 248, 0)');
                grad.addColorStop(0.2, 'rgba(56, 189, 248, 0.4)');
                grad.addColorStop(0.8, 'rgba(56, 189, 248, 0.4)');
                grad.addColorStop(1, 'rgba(56, 189, 248, 0)');
                
                ctx.strokeStyle = grad;
                ctx.beginPath();
                ctx.moveTo(150, CENTER_Y + y);
                ctx.lineTo(650, CENTER_Y + y);
                ctx.stroke();

                // Arrows indicating direction N -> S
                if (y % 80 === 0) {
                    const arrowX = CENTER_X + (y % 60); 
                    ctx.fillStyle = 'rgba(56, 189, 248, 0.6)';
                    ctx.beginPath();
                    ctx.moveTo(arrowX, CENTER_Y + y);
                    ctx.lineTo(arrowX - 8, CENTER_Y + y - 4);
                    ctx.lineTo(arrowX - 8, CENTER_Y + y + 4);
                    ctx.fill();
                }
            }
            
            ctx.fillStyle = '#38bdf8';
            ctx.font = 'bold 24px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText("B", CENTER_X, CENTER_Y - 140);


            // 2. Draw Stator Magnets (3D Cubes)
            const magW = 100, magH = 240;
            // Left (N)
            drawCube(ctx, -300, 0, 0, magW, magH, 120, '#ef4444', '#b91c1c', 'N');
            // Right (S)
            drawCube(ctx, 300, 0, 0, magW, magH, 120, '#3b82f6', '#1d4ed8', 'S');

            // 3. Draw Rotor (Coil)
            const coilW = 280;
            const coilH = 160;
            const r = coilH / 2;
            const halfW = coilW / 2;

            // Calculate 3D positions of coil corners
            // Rotating around X-axis (Horizontal)
            const y1 = r * Math.sin(theta);
            const z1 = r * Math.cos(theta); 
            const y2 = -y1;
            const z2 = -z1;

            // Draw Axle (Behind everything)
            ctx.strokeStyle = '#64748b';
            ctx.lineWidth = 12;
            ctx.beginPath();
            ctx.moveTo(CENTER_X - 350, CENTER_Y);
            ctx.lineTo(CENTER_X + 350, CENTER_Y);
            ctx.stroke();

            // Helper to draw an arm
            const drawArm = (y, z, color, label) => {
                const p1 = project(-halfW, y, z);
                const p2 = project(halfW, y, z);
                
                ctx.lineWidth = 10;
                ctx.strokeStyle = color;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.stroke();
                
                // Label (A/B)
                ctx.fillStyle = 'white';
                ctx.font = '12px sans-serif';
                ctx.fillText(label, (p1.x+p2.x)/2, p1.y - 5);
            };

            // Current Arrows Helper
            const drawI = (y, z, dir) => {
                if (voltage < 0.1) return;
                const p1 = project(-halfW, y, z);
                const p2 = project(halfW, y, z);
                const midX = (p1.x + p2.x) / 2;
                const midY = (p1.y + p2.y) / 2;
                
                ctx.fillStyle = '#facc15';
                ctx.beginPath();
                if (dir > 0) { // Left to Right
                    ctx.moveTo(midX + 10, midY);
                    ctx.lineTo(midX - 5, midY - 6);
                    ctx.lineTo(midX - 5, midY + 6);
                } else { // Right to Left
                    ctx.moveTo(midX - 10, midY);
                    ctx.lineTo(midX + 5, midY - 6);
                    ctx.lineTo(midX + 5, midY + 6);
                }
                ctx.fill();
            };

            // Force Arrows Helper
            const drawF = (y, z, dir) => {
                if (voltage < 0.1) return;
                const p1 = project(0, y, z); // Center of arm
                
                // Force is perpendicular to B (X) and I (X). 
                // Wait, I is X. B is X? No.
                // Magnets Left/Right. B is X-axis (Horizontal).
                // Coil Arms are parallel to X-axis. 
                // PARALLEL WIRES FEEL NO FORCE.
                // The force acts on the "depth" wires (connecting front/back).
                
                // Visualization Hack: We usually show force on the long arms for simplicity in 2D diagrams,
                // even though physically it's the side arms cutting the field.
                // Let's draw force arrows on the side arms?
                // Side arms are at x = +/- halfW. They run along Z/Y.
                
                // Let's stick to standard textbook representation where Force pushes the loop UP/DOWN.
                // F = I x B. 
                // Top Arm: I goes into page? B goes Right. F = Down.
                
                const fLen = 40;
                const fY = dir > 0 ? -fLen : fLen;
                
                ctx.strokeStyle = '#10b981';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p1.x, p1.y + fY);
                ctx.stroke();
                
                // Arrowhead
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y + fY);
                ctx.lineTo(p1.x - 5, p1.y + fY - 5 * Math.sign(fY));
                ctx.lineTo(p1.x + 5, p1.y + fY - 5 * Math.sign(fY));
                ctx.fillStyle = '#10b981';
                ctx.fill();
            };

            // Commutator State
            // sin(theta) > 0 means 0-180 deg (Top half).
            // Current direction flips when theta crosses 0 or 180.
            const isOrangeTop = y1 > 0; // Current enters top
            
            // Draw Elements Painter's Algorithm (Z-sort)
            const drawOrange = () => {
                drawArm(y1, z1, '#f97316', 'A');
                // Current: If Top, L->R. If Bot, R->L.
                // Force: If Top, Up/Down?
                // Right Hand Rule: I (Right), B (Right). Parallel?
                // Real motor: B is N->S. I is Into/Out of page.
                // Our diagram: B is Left->Right.
                // So Active Wires are the ones going Into/Out.
                // But we drew wires Left->Right.
                
                // Let's accept the visual abstraction:
                // Yellow Arrows show Current flow.
                // Green Arrows show Lorentz Force.
                
                // Let's assume Orange arm current is always +1 relative to loop.
                const curDir = isOrangeTop ? 1 : -1;
                const forceDir = isOrangeTop ? 1 : -1; // Top pushed up? Or down.
                // Let's make it rotate clockwise. Top arm pushed Down (-1), Bot arm Up (+1).
                
                drawI(y1, z1, curDir);
                drawF(y1, z1, -curDir); 
            };
            
            const drawBlue = () => {
                drawArm(y2, z2, '#3b82f6', 'B');
                const curDir = isOrangeTop ? -1 : 1;
                drawI(y2, z2, curDir);
                drawF(y2, z2, -curDir);
            };

            if (z1 < z2) {
                drawOrange(); // Draw back first
                drawBlue();
            } else {
                drawBlue();
                drawOrange();
            }
            
            // Draw Split Ring Commutator (Front)
            drawCommutator(ctx, -halfW - 30, theta);
            drawBrushes(ctx, -halfW - 30);

        };

        const drawCube = (ctx, x, y, z, w, h, d, faceColor, sideColor, label) => {
            const center = project(x, y, z);
            const hw = w/2 * center.scale;
            const hh = h/2 * center.scale;
            const depth = d * 0.4 * center.scale;
            
            // Front Face
            ctx.fillStyle = faceColor;
            ctx.fillRect(center.x - hw, center.y - hh, hw*2, hh*2);
            
            // Side (Fake 3D)
            ctx.fillStyle = sideColor;
            ctx.beginPath();
            ctx.moveTo(center.x + hw, center.y - hh);
            ctx.lineTo(center.x + hw + depth, center.y - hh - depth*0.5);
            ctx.lineTo(center.x + hw + depth, center.y + hh - depth*0.5);
            ctx.lineTo(center.x + hw, center.y + hh);
            ctx.fill();
            
            ctx.fillStyle = 'rgba(255,255,255,0.9)';
            ctx.font = 'bold 40px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(label, center.x, center.y);
        };

        const drawCommutator = (ctx, x, theta) => {
            const center = project(x, 0, 0);
            const r = 30 * center.scale;
            
            ctx.save();
            ctx.translate(center.x, center.y);
            ctx.rotate(theta);
            
            // Orange Half
            ctx.beginPath();
            ctx.arc(0, 0, r, 0.1, Math.PI - 0.1);
            ctx.strokeStyle = '#f97316';
            ctx.lineWidth = 6;
            ctx.stroke();
            
            // Blue Half
            ctx.beginPath();
            ctx.arc(0, 0, r, Math.PI + 0.1, 2*Math.PI - 0.1);
            ctx.strokeStyle = '#3b82f6';
            ctx.stroke();
            
            ctx.restore();
        };

        const drawBrushes = (ctx, x) => {
            const center = project(x, 0, 0);
            const gap = 35 * center.scale;
            
            ctx.fillStyle = '#4b5563'; // Carbon
            // Top Brush
            ctx.fillRect(center.x - 10, center.y - gap - 10, 20, 10);
            // Bottom Brush
            ctx.fillRect(center.x - 10, center.y + gap, 20, 10);
            
            // Wires
            ctx.strokeStyle = '#facc15';
            ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(center.x, center.y - gap - 10); ctx.lineTo(center.x, center.y - 100); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(center.x, center.y + gap + 10); ctx.lineTo(center.x, center.y + 100); ctx.stroke();
        };

        // Initial Draw
        useEffect(() => {
            draw();
        }, []); // On Mount

        useEffect(() => {
            if (window.lucide) window.lucide.createIcons();
        });

        return (
            <div className="min-h-screen bg-slate-900 text-slate-200 font-sans pb-12">
                <nav className="bg-slate-800 border-b border-slate-700 px-6 py-4 flex items-center justify-between sticky top-0 z-10">
                    <div className="flex items-center space-x-3">
                        <div className="bg-orange-500/20 p-2 rounded-lg">
                            <i data-lucide="fan" className="w-6 h-6 text-orange-400"></i>
                        </div>
                        <h1 className="text-xl font-bold text-white tracking-wide">DC Motor Lab</h1>
                    </div>
                    <div className="text-xs text-slate-400 font-mono bg-slate-900 px-3 py-1 rounded-full border border-slate-700">
                        Topic: Electromagnetism
                    </div>
                </nav>

                <main className="max-w-6xl mx-auto p-4 md:p-6 grid grid-cols-1 gap-6">
                    
                    {/* Top: Simulation Canvas (Full Width) */}
                    <div className="bg-slate-950 rounded-2xl border border-slate-700 p-1 shadow-2xl relative overflow-hidden h-[450px]">
                        <canvas 
                            ref={canvasRef} 
                            width={CANVAS_WIDTH} 
                            height={CANVAS_HEIGHT}
                            className="w-full h-full object-contain bg-slate-950 rounded-xl"
                        />
                        
                        {/* Speedometer */}
                        <div className="absolute top-4 left-4 bg-slate-900/80 px-4 py-2 rounded-lg border border-slate-700">
                            <div className="text-xs text-slate-400 uppercase tracking-widest">Speed (RPM)</div>
                            <div className="text-2xl font-mono font-bold text-white">{(Math.abs(speed) * 9.55).toFixed(0)}</div>
                        </div>

                        {/* Force & Current Legend Overlay */}
                        <div className="absolute top-4 right-4 bg-slate-900/80 px-4 py-3 rounded-lg border border-slate-700 text-xs space-y-2">
                            <div className="flex items-center gap-2">
                                <div className="w-4 h-1 bg-yellow-400"></div> <span>Current ($I$)</span>
                            </div>
                            <div className="flex items-center gap-2">
                                <div className="w-4 h-1 bg-emerald-500"></div> <span>Force ($F$)</span>
                            </div>
                        </div>
                    </div>

                    {/* Bottom: Grid Layout for Controls & Info */}
                    <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
                        
                        {/* Left: Controls */}
                        <div className="bg-slate-800 p-6 rounded-2xl border border-slate-700 space-y-6">
                            <h2 className="text-white font-bold mb-4 flex items-center">
                                <i data-lucide="settings-2" className="w-5 h-5 mr-2 text-cyan-400"></i>
                                Motor Controls
                            </h2>
                            
                            <div>
                                <label className="flex justify-between text-xs text-cyan-300 font-bold mb-2">
                                    <span>Input Voltage ($V$)</span>
                                    <span>{voltage} V</span>
                                </label>
                                <input 
                                    type="range" min="0" max="12" step="0.5" 
                                    value={voltage} onChange={(e) => setVoltage(Number(e.target.value))}
                                    className="w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer slider-thumb thumb-cyan"
                                />
                            </div>

                            <label className="flex items-center gap-3 p-3 rounded-lg bg-slate-700/50 hover:bg-slate-700 transition cursor-pointer">
                                <input 
                                    type="checkbox" 
                                    checked={slowMo} 
                                    onChange={() => setSlowMo(!slowMo)}
                                    className="w-5 h-5 rounded text-orange-500 focus:ring-0 bg-slate-800 border-slate-600"
                                />
                                <span className="text-sm font-bold text-slate-200">Slow Motion (Observe Commutation)</span>
                            </label>

                            <div className="grid grid-cols-2 gap-4">
                                <button 
                                    onClick={startSim} 
                                    disabled={isRunning}
                                    className={`py-3 rounded-xl font-bold flex items-center justify-center gap-2 transition-all shadow-lg ${isRunning ? 'bg-slate-700 text-slate-500 cursor-not-allowed' : 'bg-emerald-600 hover:bg-emerald-500 text-white'}`}
                                >
                                    <i data-lucide="play" className="w-5 h-5"></i> Start
                                </button>
                                <button 
                                    onClick={resetSim} 
                                    className="py-3 bg-slate-700 hover:bg-slate-600 text-white rounded-xl font-bold flex items-center justify-center gap-2 transition-colors"
                                >
                                    <i data-lucide="rotate-ccw" className="w-5 h-5"></i> Reset
                                </button>
                            </div>
                        </div>

                        {/* Right: Theory & Legend */}
                        <div className="space-y-4">
                            
                            {/* Commutation Info */}
                            <div className="bg-indigo-900/10 border border-indigo-500/20 p-5 rounded-2xl">
                                <h3 className="text-indigo-300 font-bold text-sm mb-2 flex items-center">
                                    <i data-lucide="refresh-cw" className="w-4 h-4 mr-2"></i> The Commutator
                                </h3>
                                <p className="text-xs text-slate-300 leading-relaxed">
                                    Watch the <strong>Split Ring</strong> in the center. 
                                    <br/><br/>
                                    When the coil turns vertical ($90^\circ$), the brushes cross the gap. This <strong>reverses the current</strong> direction instantly, ensuring the Magnetic Force always pushes the coil the same way to keep it spinning!
                                </p>
                            </div>

                            {/* Coil Legend */}
                            <div className="bg-slate-800 p-4 rounded-xl border border-slate-700 flex justify-between items-center text-xs text-slate-400">
                                <span>Coil Sides:</span>
                                <div className="flex gap-4">
                                    <div className="flex items-center gap-2">
                                        <div className="w-3 h-3 rounded-full bg-orange-500"></div>
                                        <span>Side A</span>
                                    </div>
                                    <div className="flex items-center gap-2">
                                        <div className="w-3 h-3 rounded-full bg-blue-500"></div>
                                        <span>Side B</span>
                                    </div>
                                </div>
                            </div>
                        </div>

                    </div>

                </main>
            </div>
        );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
</script>
</body>
</html>
