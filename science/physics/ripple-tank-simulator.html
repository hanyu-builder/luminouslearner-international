<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ripple Tank Simulator | Luminous Learner</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@0.263.1"></script>

    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;700;900&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">

    <style>
        body { font-family: 'Inter', sans-serif; background-color: #0f172a; color: #e2e8f0; }
        .slider-thumb::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none; width: 16px; height: 16px;
            border-radius: 50%; cursor: pointer; border: 2px solid #ffffff;
        }
        .thumb-cyan::-webkit-slider-thumb { background: #06b6d4; }
        canvas { touch-action: none; image-rendering: pixelated; }
    </style>
</head>
<body>

<div id="root"></div>

<script type="text/babel">
    const { useState, useEffect, useRef, useCallback } = React;

    // Simulation Resolution (Lower is faster)
    const SIM_WIDTH = 200;
    const SIM_HEIGHT = 150;
    const CANVAS_SCALE = 3; // Display scaling

    const SCENARIOS = {
        'reflection': { label: 'Reflection', setup: 'barrier_angle' },
        'refraction': { label: 'Refraction', setup: 'shallow_deep' },
        'diffraction': { label: 'Diffraction (Single Slit)', setup: 'slit' },
        'interference': { label: 'Interference (Two Sources)', setup: 'two_sources' },
        'doppler': { label: 'Doppler Effect', setup: 'moving_source' }
    };

    const App = () => {
        // --- State ---
        const [scenario, setScenario] = useState('reflection');
        const [frequency, setFrequency] = useState(15); // Wave generation speed
        const [damping, setDamping] = useState(0.98); // Wave decay
        const [isRunning, setIsRunning] = useState(true);
        const [mouseInteracting, setMouseInteracting] = useState(false);

        const canvasRef = useRef(null);
        const requestRef = useRef();
        
        // Physics Buffers (2D Arrays flattened)
        // buffer1: current state, buffer2: previous state
        const buffer1Ref = useRef(new Float32Array(SIM_WIDTH * SIM_HEIGHT));
        const buffer2Ref = useRef(new Float32Array(SIM_WIDTH * SIM_HEIGHT));
        const obstacleRef = useRef(new Uint8Array(SIM_WIDTH * SIM_HEIGHT)); // 0: clear, 1: wall, 2: slow medium
        const frameCountRef = useRef(0);
        const sourcePosRef = useRef({ x: 0, y: 0 }); // For doppler

        // --- Logic ---
        
        // Initialize Scenario Map
        const loadScenario = (type) => {
            const obs = obstacleRef.current;
            const buf1 = buffer1Ref.current;
            const buf2 = buffer2Ref.current;
            
            // Clear all
            obs.fill(0);
            buf1.fill(0);
            buf2.fill(0);
            frameCountRef.current = 0;
            sourcePosRef.current = { x: 20, y: SIM_HEIGHT / 2 };

            // Setup Geometry
            if (type === 'reflection') {
                // Diagonal Wall
                for (let x = 0; x < SIM_WIDTH; x++) {
                    for (let y = 0; y < SIM_HEIGHT; y++) {
                        if (x > 100 && x - 100 > y * 0.5) obs[y * SIM_WIDTH + x] = 1;
                    }
                }
            } else if (type === 'refraction') {
                // Glass Block (Shallow Water - Slow Speed)
                for (let x = 0; x < SIM_WIDTH; x++) {
                    for (let y = 0; y < SIM_HEIGHT; y++) {
                        // Slanted boundary
                        if (x > 80 + y * 0.3) obs[y * SIM_WIDTH + x] = 2; 
                    }
                }
            } else if (type === 'diffraction') {
                // Wall with Slit
                const slitSize = 8;
                for (let y = 0; y < SIM_HEIGHT; y++) {
                    if (Math.abs(y - SIM_HEIGHT/2) > slitSize) {
                        for(let x=98; x<102; x++) obs[y * SIM_WIDTH + x] = 1;
                    }
                }
            }
            // Interference is logic-based (two sources), no walls needed
        };

        useEffect(() => {
            loadScenario(scenario);
        }, [scenario]);

        // Simulation Loop
        const loop = () => {
            if (!isRunning) return;

            const width = SIM_WIDTH;
            const height = SIM_HEIGHT;
            const b1 = buffer1Ref.current;
            const b2 = buffer2Ref.current;
            const obs = obstacleRef.current;
            
            // 1. Wave Equation (Discrete)
            // New[x,y] = (Left + Right + Up + Down) / 2 - Old[x,y]
            // With damping
            
            for (let i = width; i < width * height - width; i++) {
                // Skip walls
                if (obs[i] === 1) continue;

                // Determine medium speed factor
                // Normal water = 1.0, Shallow water = 0.5
                // Formula modification for speed c:
                // u_new = 2u - u_old + c^2(neighbors - 4u)
                // Simplified "smoothing" algo used here implicitly assumes c=1.
                // To slow down, we just dampen result or interpolate?
                // Standard ripple tank algo:
                
                let val = (b1[i - 1] + b1[i + 1] + b1[i - width] + b1[i + width]) / 2 - b2[i];
                
                val = val * damping;

                if (obs[i] === 2) {
                    // Refraction hack: Slow down wave by averaging with previous state strongly
                    // or reduce amplitude propagation
                     val = val * 0.8; // Simulates energy loss/speed change roughly
                }

                b2[i] = val;
            }

            // 2. Apply Sources
            frameCountRef.current++;
            
            // Auto Sources based on scenario
            if (!mouseInteracting) {
                const period = Math.max(2, 60 - frequency);
                const amplitude = 500;
                
                if (scenario === 'interference') {
                    // Two Point Sources
                    if (frameCountRef.current % period === 0) {
                        const s1 = (SIM_HEIGHT/2 - 30) * width + 30;
                        const s2 = (SIM_HEIGHT/2 + 30) * width + 30;
                        b2[s1] = amplitude;
                        b2[s2] = amplitude;
                    }
                } else if (scenario === 'doppler') {
                    // Moving Point Source
                    if (frameCountRef.current % period === 0) {
                        // Move source
                        sourcePosRef.current.x += 1.5; 
                        if (sourcePosRef.current.x > width) sourcePosRef.current.x = 0;
                        
                        const idx = Math.floor(sourcePosRef.current.y) * width + Math.floor(sourcePosRef.current.x);
                        if (idx >= 0 && idx < width*height) b2[idx] = amplitude;
                    }
                } else {
                    // Plane Wave Generator (Left side)
                    // Or Point Source for reflection
                    if (scenario === 'reflection') {
                         // Line source at top left? Or Plane wave? Let's do Plane wave from left
                         if (frameCountRef.current % period === 0) {
                             for(let y=10; y<height-10; y++) {
                                 b2[y*width + 20] = amplitude;
                             }
                         }
                    } else if (scenario === 'diffraction' || scenario === 'refraction') {
                        // Plane wave
                        if (frameCountRef.current % period === 0) {
                             for(let y=2; y<height-2; y++) {
                                 b2[y*width + 10] = amplitude;
                             }
                        }
                    }
                }
            }

            // 3. Render
            renderToCanvas();

            // 4. Swap Buffers
            // Instead of swapping arrays (which changes refs), we swap data or logic index
            // Actually simpler to just swap array contents via a temp ref? 
            // Swapping references is fastest.
            const temp = buffer1Ref.current;
            buffer1Ref.current = buffer2Ref.current;
            buffer2Ref.current = temp;

            requestRef.current = requestAnimationFrame(loop);
        };

        const renderToCanvas = () => {
            const canvas = canvasRef.current;
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, SIM_WIDTH, SIM_HEIGHT);
            const data = imageData.data;
            const buf = buffer1Ref.current; // Current state
            const obs = obstacleRef.current;

            for (let i = 0; i < buf.length; i++) {
                const val = buf[i];
                const type = obs[i];
                
                let r, g, b;

                if (type === 1) {
                    // Wall (Yellow)
                    r = 251; g = 191; b = 36; 
                } else if (type === 2) {
                    // Slow Medium (Glass/Shallow) - Darker Tint
                    // Map wave height to color
                    // Crest = White/Cyan, Trough = Dark Blue
                    const intensity = Math.max(-255, Math.min(255, val));
                    if (intensity > 0) {
                        r = 30 + intensity; g = 58 + intensity; b = 138 + intensity; 
                    } else {
                        r = 30; g = 58; b = 138 + intensity; // Darker
                    }
                    // Overlay tint
                    r += 20; g += 20; b += 20;
                } else {
                    // Water
                    // Crest (Positive) -> Lighter Cyan
                    // Trough (Negative) -> Darker Blue
                    // Base: rgb(6, 182, 212) -> Cyan-500
                    
                    const clamp = Math.max(-127, Math.min(127, val));
                    // Base color #0ea5e9 (Sky 500) : 14, 165, 233
                    // Add clamp to RGB
                    r = 14 + clamp;
                    g = 165 + clamp;
                    b = 233 + clamp;
                }

                const pixelIdx = i * 4;
                data[pixelIdx] = r;
                data[pixelIdx + 1] = g;
                data[pixelIdx + 2] = b;
                data[pixelIdx + 3] = 255; // Alpha
            }

            ctx.putImageData(imageData, 0, 0);
        };

        // --- Interaction ---
        const handleMouseDown = (e) => {
            setMouseInteracting(true);
            disturb(e);
        };
        const handleMouseMove = (e) => {
            if (mouseInteracting) disturb(e);
        };
        const handleMouseUp = () => setMouseInteracting(false);
        const handleMouseLeave = () => setMouseInteracting(false);

        const disturb = (e) => {
            const rect = canvasRef.current.getBoundingClientRect();
            // Map display coords to sim coords
            const x = Math.floor((e.clientX - rect.left) / CANVAS_SCALE);
            const y = Math.floor((e.clientY - rect.top) / CANVAS_SCALE);
            
            if (x > 1 && x < SIM_WIDTH - 1 && y > 1 && y < SIM_HEIGHT - 1) {
                buffer2Ref.current[y * SIM_WIDTH + x] = 1000; // Splash
            }
        };

        useEffect(() => {
            requestRef.current = requestAnimationFrame(loop);
            return () => cancelAnimationFrame(requestRef.current);
        }); // Re-bind every frame? No. Dependency empty means run once?
        // But loop calls requestAnimationFrame.
        // We need to ensure state values inside loop are fresh.
        // The loop is defined inside component, so it captures closure.
        // This is inefficient. Better to use Refs for all loop variables (done).
        // Only `scenario` `isRunning` need handling.
        
        useEffect(() => {
            if (window.lucide) window.lucide.createIcons();
        });

        return (
            <div className="min-h-screen bg-slate-900 text-slate-200 font-sans pb-12">
                <nav className="bg-slate-800 border-b border-slate-700 px-6 py-4 flex items-center justify-between sticky top-0 z-10">
                    <div className="flex items-center space-x-3">
                        <div className="bg-cyan-500/20 p-2 rounded-lg">
                            <i data-lucide="waves" className="w-6 h-6 text-cyan-400"></i>
                        </div>
                        <h1 className="text-xl font-bold text-white tracking-wide">Ripple Tank Simulator</h1>
                    </div>
                    <div className="text-xs text-slate-400 font-mono bg-slate-900 px-3 py-1 rounded-full border border-slate-700">
                        Topic: Wave Physics
                    </div>
                </nav>

                <main className="max-w-6xl mx-auto p-4 md:p-6 grid grid-cols-1 lg:grid-cols-12 gap-8">
                    
                    {/* Left: Simulation Canvas */}
                    <div className="lg:col-span-8 flex flex-col gap-6">
                        <div className="bg-slate-800 rounded-2xl border border-slate-700 p-1 shadow-2xl relative flex justify-center bg-black">
                            <canvas 
                                ref={canvasRef} 
                                width={SIM_WIDTH} 
                                height={SIM_HEIGHT}
                                style={{ width: SIM_WIDTH * CANVAS_SCALE, height: SIM_HEIGHT * CANVAS_SCALE }}
                                onMouseDown={handleMouseDown}
                                onMouseMove={handleMouseMove}
                                onMouseUp={handleMouseUp}
                                onMouseLeave={handleMouseLeave}
                                className="cursor-crosshair rounded-xl"
                            />
                            <div className="absolute bottom-4 left-4 bg-slate-900/80 px-3 py-1 rounded border border-slate-700 text-xs text-cyan-300 pointer-events-none">
                                {SCENARIOS[scenario].label}
                            </div>
                        </div>

                        <div className="bg-slate-800 p-4 rounded-xl border border-slate-700 flex justify-between items-center">
                             <div className="flex gap-4">
                                <div className="flex items-center gap-2">
                                    <div className="w-3 h-3 bg-cyan-400 rounded-full"></div>
                                    <span className="text-xs text-slate-400">Water</span>
                                </div>
                                <div className="flex items-center gap-2">
                                    <div className="w-3 h-3 bg-yellow-400 rounded-full"></div>
                                    <span className="text-xs text-slate-400">Barrier</span>
                                </div>
                                <div className="flex items-center gap-2">
                                    <div className="w-3 h-3 bg-blue-800 rounded-full border border-blue-600"></div>
                                    <span className="text-xs text-slate-400">Deep/Shallow</span>
                                </div>
                             </div>
                             <div className="text-xs text-slate-500 italic">
                                 Click & Drag to make waves manually
                             </div>
                        </div>
                    </div>

                    {/* Right: Controls */}
                    <div className="lg:col-span-4 space-y-6">
                        
                        <div className="bg-slate-800 p-6 rounded-2xl border border-slate-700">
                            <h2 className="text-white font-bold mb-6 flex items-center">
                                <i data-lucide="settings-2" className="w-5 h-5 mr-2 text-indigo-400"></i>
                                Control Panel
                            </h2>

                            <div className="space-y-6">
                                {/* Scenario Selector */}
                                <div className="space-y-2">
                                    <label className="text-xs font-bold text-slate-400 uppercase tracking-widest">Scenario</label>
                                    <div className="grid grid-cols-1 gap-2">
                                        {Object.keys(SCENARIOS).map(key => (
                                            <button
                                                key={key}
                                                onClick={() => setScenario(key)}
                                                className={`text-left px-4 py-3 rounded-lg text-sm font-medium transition-all border ${scenario === key ? 'bg-cyan-600 border-cyan-500 text-white shadow-lg' : 'bg-slate-700 border-slate-600 text-slate-300 hover:bg-slate-600'}`}
                                            >
                                                {SCENARIOS[key].label}
                                            </button>
                                        ))}
                                    </div>
                                </div>

                                <div className="h-px bg-slate-700"></div>

                                {/* Frequency */}
                                <div>
                                    <label className="flex justify-between text-xs font-bold text-cyan-300 mb-2">
                                        Frequency <span>{frequency}</span>
                                    </label>
                                    <input 
                                        type="range" min="1" max="60" step="1" 
                                        value={frequency} onChange={(e) => setFrequency(Number(e.target.value))}
                                        className="w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer slider-thumb thumb-cyan" 
                                    />
                                </div>

                                {/* Damping */}
                                <div>
                                    <label className="flex justify-between text-xs font-bold text-slate-300 mb-2">
                                        Wave Damping <span>{(damping * 100).toFixed(0)}%</span>
                                    </label>
                                    <input 
                                        type="range" min="0.90" max="0.99" step="0.01" 
                                        value={damping} onChange={(e) => setDamping(Number(e.target.value))}
                                        className="w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer slider-thumb" 
                                    />
                                </div>

                                <div className="grid grid-cols-2 gap-3 pt-2">
                                    <button 
                                        onClick={() => setIsRunning(!isRunning)}
                                        className={`py-3 rounded-xl font-bold flex items-center justify-center gap-2 transition-all shadow-lg ${isRunning ? 'bg-slate-700 text-slate-300' : 'bg-emerald-600 hover:bg-emerald-500 text-white'}`}
                                    >
                                        <i data-lucide={isRunning ? "pause" : "play"} className="w-4 h-4"></i>
                                        {isRunning ? "Pause" : "Resume"}
                                    </button>
                                    <button 
                                        onClick={() => loadScenario(scenario)}
                                        className="py-3 bg-slate-700 hover:bg-slate-600 text-white rounded-xl font-bold flex items-center justify-center gap-2 transition-colors"
                                    >
                                        <i data-lucide="rotate-ccw" className="w-4 h-4"></i>
                                        Reset
                                    </button>
                                </div>
                            </div>
                        </div>

                    </div>

                </main>
            </div>
        );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
</script>
</body>
</html>
