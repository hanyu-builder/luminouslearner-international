<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Total Internal Reflection Lab | Luminous Learner</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@0.263.1"></script>

    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;700;900&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">

    <style>
        body { font-family: 'Inter', sans-serif; background-color: #0f172a; color: #e2e8f0; }
        .slider-thumb::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none; width: 16px; height: 16px;
            border-radius: 50%; cursor: pointer; border: 2px solid #ffffff;
        }
        .thumb-cyan::-webkit-slider-thumb { background: #06b6d4; }
        .thumb-blue::-webkit-slider-thumb { background: #3b82f6; }
    </style>
</head>
<body>

<div id="root"></div>

<script type="text/babel">
    const { useState, useEffect, useRef } = React;

    const CANVAS_WIDTH = 800;
    const CANVAS_HEIGHT = 500;
    const CENTER_X = CANVAS_WIDTH / 2;
    const CENTER_Y = CANVAS_HEIGHT / 2 + 50;
    const BLOCK_RADIUS = 150;

    const MATERIALS = {
        'Water': 1.33,
        'Glass': 1.50,
        'Diamond': 2.42
    };

    const App = () => {
        // --- State ---
        const [mode, setMode] = useState('block'); // 'block' or 'fiber'
        const [n1, setN1] = useState(1.50); // Inside Block (Dense)
        const [n2, setN2] = useState(1.00); // Outside (Rare)
        const [angle, setAngle] = useState(30); // Incidence Angle
        
        // Results
        const [criticalAngle, setCriticalAngle] = useState(null);
        const [isTIR, setIsTIR] = useState(false);
        const [refractedAngle, setRefractedAngle] = useState(0);

        const canvasRef = useRef(null);
        const requestRef = useRef();
        const laserOffsetRef = useRef(0); // For animating laser pulse in fiber mode

        // --- Physics Logic ---
        useEffect(() => {
            // Critical Angle Calculation: sin(c) = n2 / n1
            if (n1 > n2) {
                const cRad = Math.asin(n2 / n1);
                setCriticalAngle(cRad * 180 / Math.PI);
            } else {
                setCriticalAngle(null); // Impossible if n1 <= n2
            }

            // Current Ray Calculation
            const theta1Rad = angle * Math.PI / 180;
            const sinTheta2 = (n1 / n2) * Math.sin(theta1Rad);

            if (Math.abs(sinTheta2) > 1.0) {
                setIsTIR(true);
                setRefractedAngle(null);
            } else {
                setIsTIR(false);
                setRefractedAngle(Math.asin(sinTheta2) * 180 / Math.PI);
            }

        }, [n1, n2, angle]);

        // Animation Loop for Fiber Mode
        const loop = (time) => {
            laserOffsetRef.current = (time / 20) % 40; // Moving dash pattern
            draw();
            requestRef.current = requestAnimationFrame(loop);
        };

        useEffect(() => {
            requestRef.current = requestAnimationFrame(loop);
            return () => cancelAnimationFrame(requestRef.current);
        }, [mode, n1, n2, angle, isTIR, refractedAngle, criticalAngle]);

        // --- Rendering ---
        const draw = () => {
            const ctx = canvasRef.current?.getContext('2d');
            if (!ctx) return;

            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            if (mode === 'block') {
                drawBlockMode(ctx);
            } else {
                drawFiberMode(ctx);
            }
        };

        const drawBlockMode = (ctx) => {
            // 1. Draw Semi-Circular Block
            ctx.beginPath();
            ctx.arc(CENTER_X, CENTER_Y, BLOCK_RADIUS, Math.PI, 0); // Top half arc? No, usually flat side up for measuring?
            // Lab Setup: Flat side is where refraction happens. Laser enters curved side.
            // Let's put Flat side Horizontal. Laser comes from bottom (Curved side).
            // So Semi-circle is Bottom half.
            ctx.arc(CENTER_X, CENTER_Y, BLOCK_RADIUS, 0, Math.PI); 
            ctx.closePath();
            
            ctx.fillStyle = `rgba(6, 182, 212, ${0.1 + (n1-1)*0.2})`; // Cyan tint based on density
            ctx.fill();
            ctx.strokeStyle = '#22d3ee';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Draw Flat Surface Line
            ctx.beginPath();
            ctx.moveTo(CENTER_X - 200, CENTER_Y);
            ctx.lineTo(CENTER_X + 200, CENTER_Y);
            ctx.strokeStyle = '#94a3b8';
            ctx.lineWidth = 1;
            ctx.stroke();

            // Normal Line
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(CENTER_X, CENTER_Y - 150);
            ctx.lineTo(CENTER_X, CENTER_Y + 150);
            ctx.strokeStyle = '#64748b';
            ctx.stroke();
            ctx.setLineDash([]);

            // 2. Draw Protractor (Simplified)
            ctx.strokeStyle = 'rgba(255,255,255,0.1)';
            ctx.beginPath();
            ctx.arc(CENTER_X, CENTER_Y, 180, Math.PI, 2*Math.PI); // Top half for measuring output
            ctx.stroke();
            
            // Mark Critical Angle
            if (criticalAngle) {
                const cRad = criticalAngle * Math.PI / 180;
                // Left and Right markings
                const cx = CENTER_X + 180 * Math.sin(cRad);
                const cy = CENTER_Y - 180 * Math.cos(cRad);
                ctx.fillStyle = '#ef4444';
                ctx.font = '10px Inter';
                ctx.fillText(`θc`, cx, cy - 5);
                ctx.beginPath(); ctx.arc(cx, cy, 3, 0, Math.PI*2); ctx.fill();
            }

            // 3. Draw Laser Rays
            const rayLen = 250;
            const theta1Rad = angle * Math.PI / 180;

            // Incident Ray (From Bottom)
            // x = sin(theta), y = cos(theta)
            const startX = CENTER_X - rayLen * Math.sin(theta1Rad);
            const startY = CENTER_Y + rayLen * Math.cos(theta1Rad);
            
            drawLaser(ctx, startX, startY, CENTER_X, CENTER_Y, '#ef4444', 1.0);

            // Reflected Ray (Always exists)
            // Reflection Law: Angle i = Angle r
            const reflX = CENTER_X + rayLen * Math.sin(theta1Rad);
            const reflY = CENTER_Y + rayLen * Math.cos(theta1Rad);
            
            // Brightness depends on TIR
            // If TIR, Reflection is 100%. If not, it's partial (~10-20% visually)
            const reflAlpha = isTIR ? 1.0 : 0.3;
            drawLaser(ctx, CENTER_X, CENTER_Y, reflX, reflY, '#ef4444', reflAlpha);

            // Refracted Ray (If not TIR)
            if (!isTIR && refractedAngle !== null) {
                const theta2Rad = refractedAngle * Math.PI / 180;
                const refrX = CENTER_X + rayLen * Math.sin(theta2Rad);
                const refrY = CENTER_Y - rayLen * Math.cos(theta2Rad); // Upwards
                drawLaser(ctx, CENTER_X, CENTER_Y, refrX, refrY, '#ef4444', 0.8);
                
                // Angle Label
                drawAngleArc(ctx, CENTER_X, CENTER_Y, -90, -90 + refractedAngle, 60, '#fcd34d', `${refractedAngle.toFixed(0)}°`);
            }

            // Incident Angle Label
            drawAngleArc(ctx, CENTER_X, CENTER_Y, 90, 90 + angle, 40, '#fcd34d', `${angle}°`);
            
            // Critical Angle warning
            if (isTIR) {
                ctx.font = 'bold 20px Inter';
                ctx.fillStyle = '#ef4444';
                ctx.textAlign = 'center';
                ctx.fillText("TOTAL INTERNAL REFLECTION", CENTER_X, CENTER_Y - 100);
            }
        };

        const drawFiberMode = (ctx) => {
            // Draw a wavy fiber optic cable
            const fiberY = CENTER_Y - 50;
            const coreWidth = 60;
            
            // Cladding (Outer)
            ctx.fillStyle = '#334155';
            ctx.fillRect(0, fiberY - 20, CANVAS_WIDTH, coreWidth + 40);
            
            // Core (Inner)
            ctx.fillStyle = `rgba(6, 182, 212, ${0.1 + (n1-1)*0.2})`;
            ctx.fillRect(0, fiberY, CANVAS_WIDTH, coreWidth);
            
            // Borders
            ctx.strokeStyle = '#22d3ee';
            ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(0, fiberY); ctx.lineTo(CANVAS_WIDTH, fiberY); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(0, fiberY+coreWidth); ctx.lineTo(CANVAS_WIDTH, fiberY+coreWidth); ctx.stroke();

            // Laser Path in Fiber
            // Zig-Zag pattern
            // theta1 is angle with Normal (Vertical).
            // Angle with wall = 90 - theta1.
            // If theta1 > Critical, it bounces.
            
            const theta1Rad = angle * Math.PI / 180;
            const isTrapped = isTIR; // In fiber, n1 (core) > n2 (cladding/air) usually.
            // Here n2 is "outside" which we set in controls.
            
            // Start point
            let x = 0;
            let y = fiberY + coreWidth / 2;
            
            // Initial Launch vector (from center left)
            // Let's assume we launch at an angle relative to the axis
            // Angle relative to axis = 90 - angle (incidence with normal)
            const axisAngle = (90 - angle) * Math.PI / 180;
            let dx = Math.cos(axisAngle);
            let dy = Math.sin(axisAngle); // Initial Up/Down? Let's say Up.
            
            // If input angle is 0 (normal incidence), it goes straight (90 deg to axis) -> Stuck?
            // Actually usually launch is along axis.
            // Let's reinterpret 'angle' slider for fiber: Angle of Incidence with the WALL.
            // So 'angle' is what we check against critical.
            
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.strokeStyle = '#ef4444';
            ctx.lineWidth = 3;
            ctx.shadowColor = '#ef4444';
            ctx.shadowBlur = 10;
            
            let bouncing = true;
            let count = 0;
            
            while (x < CANVAS_WIDTH && count < 50) {
                // Find distance to next wall hit
                // Current y is between fiberY and fiberY+coreWidth
                // If dy > 0 (going down), target is fiberY+coreWidth
                // If dy < 0 (going up), target is fiberY
                
                let distToWallY = dy > 0 ? (fiberY + coreWidth) - y : y - fiberY;
                
                // slope = dy/dx = tan(axisAngle)
                // dx_step = dy_step / |slope| ? No.
                // dy/dx ratio is constant. 
                // x_step = y_step / |dy/dx|
                // tan(axisAngle) = dy/dx. 
                // axisAngle = 90 - theta_incidence.
                // tan(90-theta) = cot(theta) = 1/tan(theta)
                
                // Simple geometry: dx = dy / tan(axisAngle)
                // Avoid div by zero
                let stepX = distToWallY / Math.abs(Math.tan(axisAngle));
                
                if (stepX > CANVAS_WIDTH) stepX = CANVAS_WIDTH; // Infinite line
                
                let nextX = x + stepX;
                let nextY = dy > 0 ? fiberY + coreWidth : fiberY;
                
                // Draw segment
                ctx.lineTo(nextX, nextY);
                
                // Update
                x = nextX;
                y = nextY;
                
                // Check Bounce or Leak
                if (isTIR) {
                    // Bounce
                    dy = -dy; // Reflect vertically
                } else {
                    // Leak out
                    // Draw fading ray out
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.strokeStyle = 'rgba(239, 68, 68, 0.3)';
                    ctx.moveTo(x, y);
                    ctx.lineTo(x + 50, y + (dy > 0 ? 50 : -50)); // Refract out roughly
                    ctx.stroke();
                    bouncing = false;
                    break;
                }
                count++;
            }
            if (bouncing) ctx.stroke();
            ctx.shadowBlur = 0;
            
            // Labels
            ctx.fillStyle = 'white';
            ctx.fillText("Core (n1)", 10, fiberY + 20);
            ctx.fillText("Cladding (n2)", 10, fiberY - 5);
        };

        const drawLaser = (ctx, x1, y1, x2, y2, color, alpha) => {
            ctx.save();
            ctx.strokeStyle = color;
            ctx.globalAlpha = alpha;
            ctx.lineWidth = 3;
            ctx.shadowColor = color;
            ctx.shadowBlur = 10;
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
            ctx.restore();
        };

        const drawAngleArc = (ctx, x, y, startDeg, endDeg, radius, color, label) => {
            const startRad = startDeg * Math.PI / 180;
            const endRad = endDeg * Math.PI / 180;
            ctx.beginPath();
            ctx.arc(x, y, radius, startRad, endRad);
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.stroke();
            // Label
            const midRad = (startRad + endRad) / 2;
            const tx = x + (radius + 20) * Math.cos(midRad);
            const ty = y + (radius + 20) * Math.sin(midRad);
            ctx.fillStyle = color;
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(label, tx, ty);
        };

        useEffect(() => {
            if (window.lucide) window.lucide.createIcons();
        });

        // --- UI ---
        return (
            <div className="min-h-screen bg-slate-900 text-slate-200 font-sans pb-12">
                <nav className="bg-slate-800 border-b border-slate-700 px-6 py-4 flex items-center justify-between sticky top-0 z-10">
                    <div className="flex items-center space-x-3">
                        <div className="bg-cyan-500/20 p-2 rounded-lg">
                            <i data-lucide="gem" className="w-6 h-6 text-cyan-400"></i>
                        </div>
                        <h1 className="text-xl font-bold text-white tracking-wide">Total Internal Reflection Lab</h1>
                    </div>
                    <div className="text-xs text-slate-400 font-mono bg-slate-900 px-3 py-1 rounded-full border border-slate-700">
                        Topic: Optics
                    </div>
                </nav>

                <main className="max-w-6xl mx-auto p-4 md:p-6 grid grid-cols-1 lg:grid-cols-12 gap-8">
                    
                    {/* Left: Simulation Canvas */}
                    <div className="lg:col-span-8 flex flex-col gap-6">
                        <div className="bg-slate-800 rounded-2xl border border-slate-700 p-1 shadow-2xl relative overflow-hidden">
                            <canvas 
                                ref={canvasRef} 
                                width={CANVAS_WIDTH} 
                                height={CANVAS_HEIGHT}
                                className="w-full h-auto bg-black rounded-xl"
                            />
                            
                            <div className="absolute top-4 left-4 flex gap-2">
                                <button onClick={() => setMode('block')} className={`px-4 py-2 rounded text-sm font-bold transition ${mode==='block' ? 'bg-cyan-600 text-white' : 'bg-slate-700 text-slate-400'}`}>
                                    Block Experiment
                                </button>
                                <button onClick={() => setMode('fiber')} className={`px-4 py-2 rounded text-sm font-bold transition ${mode==='fiber' ? 'bg-indigo-600 text-white' : 'bg-slate-700 text-slate-400'}`}>
                                    Fiber Optic Mode
                                </button>
                            </div>

                            {/* Critical Angle Marker */}
                            <div className="absolute bottom-4 left-4 bg-slate-900/90 px-4 py-2 rounded-lg border border-slate-700 text-sm">
                                <span className="text-slate-400">Critical Angle ($ \theta_c $): </span>
                                <span className="font-mono text-white font-bold">
                                    {criticalAngle ? `${criticalAngle.toFixed(1)}°` : 'None (n1 < n2)'}
                                </span>
                            </div>
                        </div>

                        {/* Controls */}
                        <div className="bg-slate-800 p-6 rounded-2xl border border-slate-700 grid grid-cols-1 md:grid-cols-2 gap-8">
                            
                            {/* Materials */}
                            <div className="space-y-4">
                                <h3 className="text-white font-bold text-sm flex items-center">
                                    <i data-lucide="layers" className="w-4 h-4 mr-2 text-indigo-400"></i> Materials
                                </h3>
                                <div>
                                    <div className="flex justify-between items-center mb-1">
                                        <label className="text-xs font-bold text-cyan-300">Inner Medium (n<sub>1</sub>)</label>
                                        <span className="text-white font-mono text-xs">{n1.toFixed(2)}</span>
                                    </div>
                                    <input type="range" min="1.0" max="3.0" step="0.01" value={n1} onChange={(e) => setN1(Number(e.target.value))} className="w-full h-1.5 bg-slate-700 rounded-lg slider-thumb thumb-cyan" />
                                    <div className="flex gap-1 mt-1">
                                        {['Glass', 'Diamond'].map(m => (
                                            <button key={m} onClick={() => setN1(MATERIALS[m])} className="px-2 py-0.5 text-[10px] bg-slate-700 hover:bg-slate-600 rounded text-slate-300">{m}</button>
                                        ))}
                                    </div>
                                </div>
                                <div>
                                    <div className="flex justify-between items-center mb-1">
                                        <label className="text-xs font-bold text-blue-300">Outer Medium (n<sub>2</sub>)</label>
                                        <span className="text-white font-mono text-xs">{n2.toFixed(2)}</span>
                                    </div>
                                    <input type="range" min="1.0" max="3.0" step="0.01" value={n2} onChange={(e) => setN2(Number(e.target.value))} className="w-full h-1.5 bg-slate-700 rounded-lg slider-thumb thumb-blue" />
                                    <div className="flex gap-1 mt-1">
                                        {['Air', 'Water'].map(m => (
                                            <button key={m} onClick={() => setN2(MATERIALS[m])} className="px-2 py-0.5 text-[10px] bg-slate-700 hover:bg-slate-600 rounded text-slate-300">{m}</button>
                                        ))}
                                    </div>
                                </div>
                            </div>

                            {/* Angle */}
                            <div className="space-y-4">
                                <h3 className="text-white font-bold text-sm flex items-center">
                                    <i data-lucide="move" className="w-4 h-4 mr-2 text-rose-400"></i> Laser Angle
                                </h3>
                                <div className="bg-slate-900 p-4 rounded-xl border border-slate-700 text-center">
                                    <div className="text-3xl font-mono font-bold text-white mb-2">{angle}°</div>
                                    <input type="range" min="0" max="85" step="1" value={angle} onChange={(e) => setAngle(Number(e.target.value))} className="w-full h-2 bg-slate-700 rounded-lg slider-thumb" />
                                    <div className="flex justify-between text-[10px] text-slate-500 mt-1">
                                        <span>0° (Normal)</span>
                                        <span>90° (Surface)</span>
                                    </div>
                                </div>
                                <div className={`text-center text-xs font-bold py-2 rounded border ${isTIR ? 'bg-red-900/20 border-red-500/50 text-red-300' : 'bg-emerald-900/20 border-emerald-500/50 text-emerald-300'}`}>
                                    {isTIR ? "Reflection Only (TIR)" : "Refraction + Reflection"}
                                </div>
                            </div>

                        </div>
                    </div>

                    {/* Right: Data Analysis */}
                    <div className="lg:col-span-4 space-y-6">
                        
                        <div className="bg-slate-800 p-6 rounded-2xl border border-slate-700">
                            <h2 className="text-white font-bold mb-4 flex items-center">
                                <i data-lucide="calculator" className="w-5 h-5 mr-2 text-indigo-400"></i>
                                Snell's Law Check
                            </h2>
                            <div className="space-y-3 font-mono text-sm">
                                <div className="flex justify-between p-2 rounded bg-slate-900/50 border border-slate-700/50">
                                    <span className="text-cyan-300"><i>n</i><sub>1</sub> sin <i>θ</i><sub>1</sub></span>
                                    <span className="text-white">{(n1 * Math.sin(angle * Math.PI / 180)).toFixed(3)}</span>
                                </div>
                                <div className="flex justify-between p-2 rounded bg-slate-900/50 border border-slate-700/50">
                                    <span className="text-blue-300"><i>n</i><sub>2</sub> sin <i>θ</i><sub>2</sub></span>
                                    <span className="text-white">
                                        {isTIR ? <span className="text-red-400 italic">Undefined</span> : (n2 * Math.sin(refractedAngle * Math.PI / 180)).toFixed(3)}
                                    </span>
                                </div>
                            </div>
                        </div>

                        <div className="bg-indigo-900/10 border border-indigo-500/20 p-5 rounded-2xl">
                            <h3 className="text-indigo-300 font-bold text-sm mb-3 flex items-center">
                                <i data-lucide="lightbulb" className="w-4 h-4 mr-2"></i> How Fiber Optics Work
                            </h3>
                            <div className="text-xs text-slate-300 leading-relaxed space-y-2">
                                <p>
                                    Switch to <strong>"Fiber Optic Mode"</strong>.
                                </p>
                                <p>
                                    Fiber cables have a dense <strong>Core (n<sub>1</sub>)</strong> surrounded by a less dense <strong>Cladding (n<sub>2</sub>)</strong>.
                                </p>
                                <p>
                                    As long as the light hits the wall at an angle greater than the Critical Angle, it is trapped inside forever! This allows internet data to travel kilometers without leaking out.
                                </p>
                            </div>
                        </div>

                    </div>

                </main>
            </div>
        );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
</script>
</body>
</html>
