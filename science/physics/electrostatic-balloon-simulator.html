<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Electrostatic Balloon Lab | Luminous Learner</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@0.263.1"></script>

    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;700;900&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">

    <style>
        body { font-family: 'Inter', sans-serif; background-color: #0f172a; color: #e2e8f0; }
        .canvas-container { cursor: grab; }
        .canvas-container:active { cursor: grabbing; }
        .noselect { user-select: none; }
    </style>
</head>
<body>

<div id="root"></div>

<script type="text/babel">
    const { useState, useEffect, useRef } = React;

    const CANVAS_WIDTH = 800;
    const CANVAS_HEIGHT = 500;
    
    // Physics Constants
    const BALLOON_RADIUS = 60;
    const CHARGE_COUNT = 18; // Base charges per object
    
    // Objects
    const SWEATER_X = 150;
    const SWEATER_Y = 250;
    const SWEATER_W = 180;
    const SWEATER_H = 300;

    const WALL_X = 750;
    const WALL_W = 50;

    const App = () => {
        // --- State ---
        const [showCharges, setShowCharges] = useState(true);
        const [balloonPos, setBalloonPos] = useState({ x: 400, y: 250 });
        const [balloonCharges, setBalloonCharges] = useState([]); // Array of {type: +/-, x, y (relative)}
        const [sweaterCharges, setSweaterCharges] = useState([]);
        const [wallCharges, setWallCharges] = useState([]);
        
        const [isDragging, setIsDragging] = useState(false);
        const [netCharge, setNetCharge] = useState(0); // Balloon net charge

        const canvasRef = useRef(null);
        const requestRef = useRef();
        const physicsRef = useRef({
            bx: 400, by: 250, vx: 0, vy: 0,
            dragging: false
        });

        // --- Initialization ---
        useEffect(() => {
            resetSim();
        }, []);

        const resetSim = () => {
            // 1. Init Sweater Charges (Fixed Grid)
            const sCharges = [];
            for(let r=0; r<6; r++) {
                for(let c=0; c<4; c++) {
                    const cx = (c - 1.5) * 40;
                    const cy = (r - 2.5) * 50;
                    sCharges.push({ type: 1, x: cx, y: cy, baseX: cx, baseY: cy }); // Protons
                    sCharges.push({ type: -1, x: cx + 5, y: cy + 5, baseX: cx+5, baseY: cy+5 }); // Electrons
                }
            }
            setSweaterCharges(sCharges);

            // 2. Init Balloon Charges (Random inside circle)
            const bCharges = [];
            for(let i=0; i<CHARGE_COUNT; i++) {
                const angle = Math.random() * Math.PI * 2;
                const dist = Math.sqrt(Math.random()) * (BALLOON_RADIUS - 15);
                const bx = Math.cos(angle) * dist;
                const by = Math.sin(angle) * dist;
                bCharges.push({ type: 1, x: bx, y: by });
                bCharges.push({ type: -1, x: bx + 5, y: by + 5 });
            }
            setBalloonCharges(bCharges);

            // 3. Init Wall Charges (Column)
            const wCharges = [];
            for(let i=0; i<10; i++) {
                const wy = (i - 4.5) * 50;
                wCharges.push({ type: 1, x: 0, y: wy });
                wCharges.push({ type: -1, x: 0, y: wy, baseX: 0 }); // Electrons movable in x
            }
            setWallCharges(wCharges);

            // Reset Physics
            physicsRef.current = { bx: 400, by: 250, vx: 0, vy: 0, dragging: false };
            setNetCharge(0);
            setBalloonPos({ x: 400, y: 250 });
        };

        // --- Physics Loop ---
        const loop = () => {
            const state = physicsRef.current;
            const dt = 0.016;

            if (!state.dragging) {
                // Apply Forces
                let fx = 0;
                let fy = 0;

                // 1. Attraction to Sweater (if balloon is negative)
                // Calculate net charge of sweater (which becomes positive)
                // Actually simplified model: 
                // Force ~ k * q1 * q2 / r^2
                // Balloon Net Charge (Negative) attracted to Sweater Net Charge (Positive)
                
                // Calculate actual net charges
                const balloonNet = balloonCharges.reduce((acc, c) => acc + c.type, 0);
                const sweaterNet = sweaterCharges.reduce((acc, c) => acc + c.type, 0); // Should be positive if balloon is neg
                
                if (balloonNet !== 0) {
                    const dx = SWEATER_X - state.bx;
                    const dy = SWEATER_Y - state.by;
                    const distSq = dx*dx + dy*dy;
                    const dist = Math.sqrt(distSq);
                    
                    // F = k * q1 * q2 / r^2. 
                    // Since q1 (balloon) is neg and q2 (sweater) is pos, force is attractive
                    // Direction is towards sweater
                    const forceMag = 5000 * Math.abs(balloonNet * sweaterNet) / (distSq + 1000);
                    
                    fx += (dx/dist) * forceMag;
                    fy += (dy/dist) * forceMag;
                }

                // 2. Attraction to Wall (Induction)
                // Wall is neutral overall, but polarized.
                // Positive charges on wall surface attract balloon electrons.
                // Negative charges on wall are pushed away (repel).
                // Net force is attractive because positive charges are closer.
                
                // Simplified induction force:
                // F_ind = k * q_balloon^2 / dist^3 (Dipole-like or image charge approximation)
                // Only if near wall
                const distToWall = WALL_X - (state.bx + BALLOON_RADIUS);
                if (distToWall < 150) {
                    const forceInd = 20000 * (balloonNet * balloonNet) / Math.pow(distToWall + 50, 2.5); // Heuristic
                    fx += forceInd; // Pulls right
                }

                // 3. Update Motion
                state.vx += fx * dt;
                state.vy += fy * dt;
                
                // Damping (Air resistance)
                state.vx *= 0.95;
                state.vy *= 0.95;

                // Move
                state.bx += state.vx;
                state.by += state.vy;

                // Collision
                // Wall
                if (state.bx + BALLOON_RADIUS > WALL_X) {
                    state.bx = WALL_X - BALLOON_RADIUS;
                    state.vx = 0;
                }
                // Sweater
                // Simple box collision
                if (state.bx - BALLOON_RADIUS < SWEATER_X + SWEATER_W/2) {
                    // Soft bounce or stick? Stick if charged.
                    if (balloonNet !== 0) {
                         state.vx = 0;
                         state.vy = 0;
                    } else {
                        // Bounce
                        if (state.bx - BALLOON_RADIUS < SWEATER_X + SWEATER_W/2) {
                             state.bx = SWEATER_X + SWEATER_W/2 + BALLOON_RADIUS;
                             state.vx *= -0.5;
                        }
                    }
                }
            }

            // Sync State for React Render
            setBalloonPos({ x: state.bx, y: state.by });
            // Calculate Net Charge for UI
            const bNet = balloonCharges.reduce((acc, c) => acc + c.type, 0);
            setNetCharge(bNet);

            // --- Wall Polarization Logic (Visual Only) ---
            // If balloon is negative and near wall, push wall electrons right
            setWallCharges(prev => prev.map(c => {
                if (c.type === 1) return c; // Protons don't move
                
                // Electron logic
                const balloonNet = balloonCharges.reduce((acc, q) => acc + q.type, 0); // e.g. -5
                const distToWall = WALL_X - (state.bx + BALLOON_RADIUS);
                
                let targetX = c.baseX;
                if (balloonNet < -2 && distToWall < 200) {
                     // Push right
                     // Strength depends on dist
                     const push = Math.min(40, 1000 / (distToWall + 10));
                     targetX = c.baseX + push;
                }
                
                // Smooth lerp
                return { ...c, x: c.x + (targetX - c.x) * 0.1 };
            }));

            requestRef.current = requestAnimationFrame(loop);
        };

        // --- Interaction Handlers ---
        const handleMouseDown = (e) => {
            const rect = canvasRef.current.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Check balloon hit
            if (Math.hypot(x - balloonPos.x, y - balloonPos.y) < BALLOON_RADIUS + 20) {
                physicsRef.current.dragging = true;
                setIsDragging(true);
            }
        };

        const handleMouseMove = (e) => {
            const rect = canvasRef.current.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            if (physicsRef.current.dragging) {
                // Update Physics State
                physicsRef.current.bx = x;
                physicsRef.current.by = y;
                physicsRef.current.vx = 0;
                physicsRef.current.vy = 0;
                
                // Check Friction/Rubbing
                // If balloon overlaps sweater
                const sweaterLeft = SWEATER_X - SWEATER_W/2;
                const sweaterRight = SWEATER_X + SWEATER_W/2;
                const sweaterTop = SWEATER_Y - SWEATER_H/2;
                const sweaterBottom = SWEATER_Y + SWEATER_H/2;

                // Simple AABB check overlap
                if (x - BALLOON_RADIUS < sweaterRight && x + BALLOON_RADIUS > sweaterLeft &&
                    y - BALLOON_RADIUS < sweaterBottom && y + BALLOON_RADIUS > sweaterTop) {
                    
                    // Transfer Electrons!
                    // Take random electron from sweater, add to balloon
                    // Find an electron on sweater
                    const electronIdx = sweaterCharges.findIndex(c => c.type === -1);
                    if (electronIdx !== -1) {
                        // Chance to transfer based on movement? Or just auto
                        if (Math.random() > 0.8) {
                            const newElectron = sweaterCharges[electronIdx];
                            // Remove from sweater
                            const newSweaterCharges = [...sweaterCharges];
                            newSweaterCharges.splice(electronIdx, 1);
                            setSweaterCharges(newSweaterCharges);

                            // Add to balloon (random pos relative to center)
                            const angle = Math.random() * Math.PI * 2;
                            const r = Math.sqrt(Math.random()) * (BALLOON_RADIUS - 10);
                            
                            setBalloonCharges(prev => [...prev, {
                                type: -1,
                                x: r * Math.cos(angle),
                                y: r * Math.sin(angle)
                            }]);
                        }
                    }
                }
            }
        };

        const handleMouseUp = () => {
            physicsRef.current.dragging = false;
            setIsDragging(false);
        };

        // --- Rendering ---
        useEffect(() => {
            const ctx = canvasRef.current?.getContext('2d');
            if (!ctx) return;

            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            // 1. Draw Sweater
            ctx.fillStyle = '#facc15'; // Yellow
            ctx.fillRect(SWEATER_X - SWEATER_W/2, SWEATER_Y - SWEATER_H/2, SWEATER_W, SWEATER_H);
            // Texture
            ctx.strokeStyle = '#eab308';
            ctx.lineWidth = 2;
            for(let i=0; i<10; i++) {
                ctx.beginPath();
                ctx.moveTo(SWEATER_X - SWEATER_W/2, SWEATER_Y - SWEATER_H/2 + i*30);
                ctx.lineTo(SWEATER_X + SWEATER_W/2, SWEATER_Y - SWEATER_H/2 + i*30 + 20);
                ctx.stroke();
            }
            
            // Draw Sweater Charges
            if (showCharges) {
                sweaterCharges.forEach(c => {
                    drawCharge(ctx, SWEATER_X + c.x, SWEATER_Y + c.y, c.type);
                });
            }

            // 2. Draw Wall
            ctx.fillStyle = '#334155';
            ctx.fillRect(WALL_X, 0, WALL_W, CANVAS_HEIGHT);
            
            // Draw Wall Charges
            if (showCharges) {
                wallCharges.forEach(c => {
                    drawCharge(ctx, WALL_X + 15 + c.x, 50 + c.y, c.type); // Centered in wall width somewhat
                });
            }

            // 3. Draw Balloon
            const bx = balloonPos.x;
            const by = balloonPos.y;

            // String
            ctx.beginPath();
            ctx.moveTo(bx, by + BALLOON_RADIUS);
            ctx.quadraticCurveTo(bx + 10, by + BALLOON_RADIUS + 50, bx + 5, by + BALLOON_RADIUS + 100);
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Balloon Body
            ctx.fillStyle = '#eab308'; // Yellowish default
            if (netCharge < -5) ctx.fillStyle = '#fde047'; // Bright yellow if charged
            
            ctx.beginPath();
            ctx.ellipse(bx, by, BALLOON_RADIUS, BALLOON_RADIUS * 1.1, 0, 0, Math.PI*2);
            ctx.fill();
            
            // Glow if charged
            if (Math.abs(netCharge) > 0) {
                ctx.shadowColor = '#3b82f6';
                ctx.shadowBlur = Math.abs(netCharge) * 2;
                ctx.strokeStyle = '#60a5fa';
                ctx.lineWidth = 3;
                ctx.stroke();
                ctx.shadowBlur = 0;
            }

            // Balloon Charges
            if (showCharges) {
                balloonCharges.forEach(c => {
                    drawCharge(ctx, bx + c.x, by + c.y, c.type);
                });
            }

        }, [balloonPos, sweaterCharges, wallCharges, balloonCharges, showCharges, netCharge]);

        const drawCharge = (ctx, x, y, type) => {
            ctx.beginPath();
            ctx.arc(x, y, 6, 0, Math.PI*2);
            ctx.fillStyle = type > 0 ? '#ef4444' : '#3b82f6';
            ctx.fill();
            
            ctx.fillStyle = 'white';
            ctx.font = 'bold 10px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(type > 0 ? '+' : '-', x, y + 1);
        };

        useEffect(() => {
            requestRef.current = requestAnimationFrame(loop);
            return () => cancelAnimationFrame(requestRef.current);
        }); // Loop dependency empty? No, rely on refs.

        useEffect(() => {
            if (window.lucide) window.lucide.createIcons();
        });

        return (
            <div className="min-h-screen bg-slate-900 text-slate-200 font-sans pb-12 noselect">
                <nav className="bg-slate-800 border-b border-slate-700 px-6 py-4 flex items-center justify-between sticky top-0 z-10">
                    <div className="flex items-center space-x-3">
                        <div className="bg-yellow-500/20 p-2 rounded-lg">
                            <i data-lucide="zap" className="w-6 h-6 text-yellow-400"></i>
                        </div>
                        <h1 className="text-xl font-bold text-white tracking-wide">Electrostatic Balloon Lab</h1>
                    </div>
                    <div className="text-xs text-slate-400 font-mono bg-slate-900 px-3 py-1 rounded-full border border-slate-700">
                        Topic: Static Electricity
                    </div>
                </nav>

                <main className="max-w-6xl mx-auto p-4 md:p-6 grid grid-cols-1 lg:grid-cols-12 gap-8">
                    
                    {/* Left: Simulation Canvas */}
                    <div className="lg:col-span-9 flex flex-col gap-6">
                        <div className="bg-slate-800 rounded-2xl border border-slate-700 p-1 shadow-2xl relative overflow-hidden">
                            <canvas 
                                ref={canvasRef} 
                                width={CANVAS_WIDTH} 
                                height={CANVAS_HEIGHT}
                                onMouseDown={handleMouseDown}
                                onMouseMove={handleMouseMove}
                                onMouseUp={handleMouseUp}
                                onMouseLeave={handleMouseUp}
                                className="w-full h-auto bg-slate-950 rounded-xl canvas-container"
                            />
                            
                            <div className="absolute top-4 left-4 bg-slate-900/80 px-4 py-2 rounded-lg border border-slate-700 text-sm text-slate-300 pointer-events-none">
                                Drag the <strong>Balloon</strong>. Rub it on the <strong>Sweater</strong>. Move it near the <strong>Wall</strong>.
                            </div>
                        </div>

                        {/* Controls */}
                        <div className="bg-slate-800 p-6 rounded-2xl border border-slate-700 flex justify-between items-center">
                            <div className="flex items-center gap-4">
                                <label className="flex items-center gap-2 cursor-pointer p-2 rounded-lg bg-slate-700/50 hover:bg-slate-700 transition-colors">
                                    <input type="checkbox" checked={showCharges} onChange={() => setShowCharges(!showCharges)} className="w-5 h-5 rounded text-yellow-500 focus:ring-0" />
                                    <span className="text-sm font-bold text-slate-300">Show Charges</span>
                                </label>
                            </div>
                            <button onClick={resetSim} className="px-6 py-3 bg-slate-700 hover:bg-slate-600 rounded-xl text-white font-bold transition-colors flex items-center gap-2">
                                <i data-lucide="rotate-ccw" className="w-4 h-4"></i> Reset Balloon
                            </button>
                        </div>
                    </div>

                    {/* Right: Data Analysis */}
                    <div className="lg:col-span-3 space-y-6">
                        
                        <div className="bg-slate-800 p-6 rounded-2xl border border-slate-700">
                            <h2 className="text-white font-bold mb-4 flex items-center">
                                <i data-lucide="battery-charging" className="w-5 h-5 mr-2 text-indigo-400"></i>
                                Charge Status
                            </h2>
                            <div className="space-y-4">
                                <div className="p-4 rounded-xl bg-slate-900 border border-slate-700 text-center">
                                    <div className="text-xs text-slate-500 uppercase tracking-widest mb-1">Balloon Net Charge</div>
                                    <div className={`text-3xl font-mono font-bold ${netCharge < 0 ? 'text-blue-400' : 'text-slate-400'}`}>
                                        {netCharge === 0 ? "Neutral" : `${netCharge} e‚Åª`}
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div className="bg-indigo-900/10 border border-indigo-500/20 p-5 rounded-2xl">
                            <h3 className="text-indigo-300 font-bold text-sm mb-2 flex items-center">
                                <i data-lucide="lightbulb" className="w-4 h-4 mr-2"></i> Observation
                            </h3>
                            <ul className="text-xs text-slate-300 leading-relaxed space-y-2 list-disc pl-4">
                                <li>
                                    <strong>Triboelectric Effect:</strong> Rubbing the balloon steals electrons (blue) from the sweater. The balloon becomes negatively charged.
                                </li>
                                <li>
                                    <strong>Induction:</strong> When the negative balloon goes near the neutral wall, it repels the wall's electrons deeper inside, leaving positive charges on the surface. This attracts the balloon!
                                </li>
                            </ul>
                        </div>

                    </div>

                </main>
            </div>
        );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
</script>
</body>
</html>
