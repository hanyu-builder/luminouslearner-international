<!DOCTYPE html>
<html lang="zh-HK">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enzyme Lock & Key Model</title>
    
    <!-- React & Tailwind -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #0F172A; color: #e2e8f0; margin: 0; overflow: hidden; }
        .font-mono { font-family: 'JetBrains Mono', monospace; }
        canvas { outline: none; }
        
        /* Keyframe for product release */
        @keyframes popOut {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(0); opacity: 0; }
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        const Icon = ({ name, className = "", size = 20 }) => {
            const [svgHtml, setSvgHtml] = useState('');
            useEffect(() => {
                if (window.lucide && window.lucide.icons) {
                    const pascalName = name.split('-').map(part => part.charAt(0).toUpperCase() + part.slice(1)).join('');
                    const iconData = window.lucide.icons[pascalName];
                    if (iconData && typeof window.lucide.createElement === 'function') {
                        const svgElement = window.lucide.createElement(iconData);
                        svgElement.setAttribute('class', className);
                        svgElement.setAttribute('width', size);
                        svgElement.setAttribute('height', size);
                        setSvgHtml(svgElement.outerHTML);
                    }
                }
            }, [name, className, size]);
            if (!svgHtml) return <span className={className} style={{ width: size, height: size, display: 'inline-block' }}></span>;
            return <span dangerouslySetInnerHTML={{ __html: svgHtml }} className="flex items-center justify-center" />;
        };

        // --- 3D SCENE ---
        const EnzymeScene = ({ activeSubstrate, onReactionComplete }) => {
            const mountRef = useRef(null);
            const sceneRef = useRef(null);
            const enzymeRef = useRef(null);
            const substrateRef = useRef(null);
            const productsRef = useRef([]);
            const animationState = useRef('idle'); // idle, binding, reacting, releasing
            const intervalRef = useRef(null); // Track bounce animation interval

            useEffect(() => {
                if (!mountRef.current) return;

                const container = mountRef.current;
                const width = container.clientWidth;
                const height = container.clientHeight;
                
                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0x020617); 
                sceneRef.current = scene;

                const camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 100);
                camera.position.set(0, 5, 18); // Moved camera back slightly

                const renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(width, height);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                container.appendChild(renderer.domElement);

                const controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.autoRotate = false; 
                
                // Lights
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.8); // Brightened
                scene.add(ambientLight);
                const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
                dirLight.position.set(5, 10, 7);
                scene.add(dirLight);
                const pointLight = new THREE.PointLight(0x38bdf8, 0.8);
                pointLight.position.set(-5, -5, 5);
                scene.add(pointLight);

                // --- BUILD ENZYME (The "Lock") ---
                const enzymeGroup = new THREE.Group();
                
                // Top part
                const topGeo = new THREE.BoxGeometry(4, 2, 4);
                const topMesh = new THREE.Mesh(topGeo, new THREE.MeshStandardMaterial({ color: 0x6366f1, roughness: 0.2, metalness: 0.1 }));
                topMesh.position.set(0, 2.5, 0);
                enzymeGroup.add(topMesh);

                // Bottom part
                const botMesh = new THREE.Mesh(topGeo, new THREE.MeshStandardMaterial({ color: 0x6366f1, roughness: 0.2, metalness: 0.1 }));
                botMesh.position.set(0, -2.5, 0);
                enzymeGroup.add(botMesh);

                // Back part (Connecting them)
                const backGeo = new THREE.BoxGeometry(2, 7, 4);
                const backMesh = new THREE.Mesh(backGeo, new THREE.MeshStandardMaterial({ color: 0x6366f1, roughness: 0.2, metalness: 0.1 }));
                backMesh.position.set(-3, 0, 0);
                enzymeGroup.add(backMesh);

                // Active Site Highlight (Inside the C)
                const activeSiteGeo = new THREE.BoxGeometry(0.2, 5, 4);
                const activeSiteMat = new THREE.MeshStandardMaterial({ color: 0xfacc15, emissive: 0xca8a04, emissiveIntensity: 0.2 });
                const activeSite = new THREE.Mesh(activeSiteGeo, activeSiteMat);
                activeSite.position.set(-1.9, 0, 0); // Just inside the back wall
                enzymeGroup.add(activeSite);

                enzymeRef.current = enzymeGroup;
                scene.add(enzymeGroup);

                // Helper: Create Products (Defined here to be accessible in animate)
                const createProducts = (scene) => {
                    const p1 = new THREE.Mesh(new THREE.BoxGeometry(2.5, 1.8, 2.5), new THREE.MeshStandardMaterial({ color: 0x4ade80 })); // Green product
                    p1.position.set(0, 1, 0);
                    
                    const p2 = new THREE.Mesh(new THREE.BoxGeometry(2.5, 1.8, 2.5), new THREE.MeshStandardMaterial({ color: 0x4ade80 })); 
                    p2.position.set(0, -1, 0);
                    
                    scene.add(p1);
                    scene.add(p2);
                    productsRef.current = [p1, p2];
                };

                // Animation Loop
                let frameId;
                const animate = () => {
                    frameId = requestAnimationFrame(animate);
                    
                    // Enzyme gentle float
                    if (enzymeRef.current) {
                        enzymeRef.current.rotation.y = Math.sin(Date.now() * 0.0005) * 0.2;
                        enzymeRef.current.position.y = Math.sin(Date.now() * 0.001) * 0.2;
                    }

                    // Substrate Animation Logic
                    if (substrateRef.current && animationState.current !== 'idle') {
                        const sub = substrateRef.current;
                        
                        if (animationState.current === 'binding') {
                            // Move towards (0,0,0) - Active Site
                            sub.position.lerp(new THREE.Vector3(0, 0, 0), 0.05);
                            // Rotate to align
                            sub.rotation.z = THREE.MathUtils.lerp(sub.rotation.z, 0, 0.1);
                            
                            if (sub.position.distanceTo(new THREE.Vector3(0,0,0)) < 0.1) {
                                animationState.current = 'reacting';
                                // Flash effect
                                activeSite.material.emissiveIntensity = 2;
                                setTimeout(() => { 
                                    activeSite.material.emissiveIntensity = 0.2;
                                    animationState.current = 'releasing';
                                    
                                    // Break into products (Visual swap)
                                    scene.remove(sub);
                                    createProducts(scene);
                                }, 1000); // Reaction time
                            }
                        }
                    }

                    // Products Animation
                    if (animationState.current === 'releasing' && productsRef.current.length > 0) {
                        productsRef.current.forEach((prod, i) => {
                            prod.position.x += 0.1;
                            prod.position.y += (i === 0 ? 0.05 : -0.05);
                            prod.rotation.z += 0.05;
                        });
                        
                        if (productsRef.current[0].position.x > 8) {
                            // Done
                            animationState.current = 'idle';
                            productsRef.current.forEach(p => scene.remove(p));
                            productsRef.current = [];
                            if (onReactionComplete) onReactionComplete();
                        }
                    }

                    controls.update();
                    renderer.render(scene, camera);
                };
                animate();

                // Resize Observer for robustness
                const resizeObserver = new ResizeObserver(() => {
                    if (container) {
                        const newWidth = container.clientWidth;
                        const newHeight = container.clientHeight;
                        camera.aspect = newWidth / newHeight;
                        camera.updateProjectionMatrix();
                        renderer.setSize(newWidth, newHeight);
                    }
                });
                resizeObserver.observe(container);

                // Cleanup
                return () => {
                    cancelAnimationFrame(frameId);
                    resizeObserver.disconnect();
                    if (mountRef.current && renderer.domElement) {
                        mountRef.current.removeChild(renderer.domElement);
                    }
                    if (intervalRef.current) clearInterval(intervalRef.current);
                    renderer.dispose();
                };
            }, []); // Init once

            // Trigger New Substrate
            useEffect(() => {
                if (!sceneRef.current || !activeSubstrate) return;
                
                // Clear previous interval if any
                if (intervalRef.current) clearInterval(intervalRef.current);

                // Remove old if any
                if (substrateRef.current) {
                    sceneRef.current.remove(substrateRef.current);
                    substrateRef.current = null;
                }
                
                // Create new substrate mesh based on type
                let geo, mat;
                if (activeSubstrate.shape === 'square') { // Fits!
                    geo = new THREE.BoxGeometry(2.5, 4, 2.5);
                    mat = new THREE.MeshStandardMaterial({ color: 0xef4444 }); // Red
                } else if (activeSubstrate.shape === 'circle') { // Doesn't fit
                    geo = new THREE.SphereGeometry(2, 32, 32);
                    mat = new THREE.MeshStandardMaterial({ color: 0xf97316 }); // Orange
                } else if (activeSubstrate.shape === 'triangle') { // Doesn't fit
                    geo = new THREE.ConeGeometry(2, 4, 4); // Pyramid-ish
                    mat = new THREE.MeshStandardMaterial({ color: 0xeab308 }); // Yellow
                }

                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.set(8, 0, 0); // Start from right
                mesh.rotation.z = Math.random(); // Random rotation to show alignment needed
                
                sceneRef.current.add(mesh);
                substrateRef.current = mesh;
                
                // Start animation logic
                // If it fits (square), it binds. If not, it bounces off.
                if (activeSubstrate.shape === 'square') {
                    animationState.current = 'binding';
                } else {
                    // Bounce logic for wrong shape
                    // Simple animation: Move close, then bounce back
                    const bounceAnim = () => {
                        const startPos = mesh.position.clone();
                        const targetPos = new THREE.Vector3(2, 0, 0); // Close but not in
                        
                        let t = 0;
                        const id = setInterval(() => {
                            t += 0.02;
                            if (t < 1) {
                                mesh.position.lerpVectors(startPos, targetPos, t);
                            } else if (t < 2) {
                                mesh.position.lerpVectors(targetPos, new THREE.Vector3(10, 5, 0), t - 1); // Fly away
                            } else {
                                clearInterval(id);
                                if (substrateRef.current) {
                                    sceneRef.current.remove(mesh);
                                    substrateRef.current = null;
                                }
                                if (onReactionComplete) onReactionComplete(false); // False = failed
                            }
                        }, 16);
                        intervalRef.current = id;
                    };
                    bounceAnim();
                }

            }, [activeSubstrate]);

            return <div ref={mountRef} className="w-full h-full" />;
        };

        // --- MAIN APP ---
        const App = () => {
            const [substrate, setSubstrate] = useState(null);
            const [feedback, setFeedback] = useState(null); // { type: 'success'|'fail', msg: '' }

            const handleSelectSubstrate = (shape) => {
                if (substrate) return; // Wait for current to finish
                setSubstrate({ shape });
                setFeedback(null);
            };

            const handleReactionEnd = (success = true) => {
                setSubstrate(null);
                if (success) {
                    setFeedback({ type: 'success', msg: 'Reaction Successful! Substrate fits the active site.' });
                } else {
                    setFeedback({ type: 'fail', msg: 'Reaction Failed. Shape does not match the active site.' });
                }
            };

            return (
                <div className="min-h-screen bg-[#0F172A] text-white flex flex-col md:flex-row overflow-hidden">
                    
                    {/* Sidebar */}
                    <div className="w-full md:w-80 bg-slate-900 border-r border-slate-800 flex flex-col z-10 shadow-xl h-screen shrink-0">
                        <div className="p-6 border-b border-slate-800">
                            <h1 className="text-xl font-bold flex items-center gap-2">
                                <Icon name="lock" className="text-emerald-400" /> Enzyme Lab
                            </h1>
                            <p className="text-xs text-slate-400 mt-1">Lock & Key Hypothesis</p>
                        </div>

                        <div className="p-6 space-y-8 flex-1 overflow-y-auto">
                            
                            {/* Substrate Selector */}
                            <div className="space-y-3">
                                <label className="text-xs font-bold text-slate-500 uppercase tracking-widest px-1">Select Substrate (Key)</label>
                                <div className="grid grid-cols-1 gap-3">
                                    <button 
                                        onClick={() => handleSelectSubstrate('square')}
                                        disabled={!!substrate}
                                        className="p-4 bg-slate-800 hover:bg-slate-700 border border-slate-700 hover:border-emerald-500 rounded-xl flex items-center gap-4 transition-all group disabled:opacity-50"
                                    >
                                        <div className="w-8 h-8 bg-red-500 rounded-sm shadow-md group-hover:scale-110 transition-transform"></div>
                                        <div className="text-left">
                                            <div className="font-bold text-sm">Substrate A</div>
                                            <div className="text-[10px] text-slate-400">Rectangular Shape</div>
                                        </div>
                                    </button>

                                    <button 
                                        onClick={() => handleSelectSubstrate('circle')}
                                        disabled={!!substrate}
                                        className="p-4 bg-slate-800 hover:bg-slate-700 border border-slate-700 hover:border-orange-500 rounded-xl flex items-center gap-4 transition-all group disabled:opacity-50"
                                    >
                                        <div className="w-8 h-8 bg-orange-500 rounded-full shadow-md group-hover:scale-110 transition-transform"></div>
                                        <div className="text-left">
                                            <div className="font-bold text-sm">Substrate B</div>
                                            <div className="text-[10px] text-slate-400">Spherical Shape</div>
                                        </div>
                                    </button>

                                    <button 
                                        onClick={() => handleSelectSubstrate('triangle')}
                                        disabled={!!substrate}
                                        className="p-4 bg-slate-800 hover:bg-slate-700 border border-slate-700 hover:border-yellow-500 rounded-xl flex items-center gap-4 transition-all group disabled:opacity-50"
                                    >
                                        <div className="w-0 h-0 border-l-[16px] border-l-transparent border-r-[16px] border-r-transparent border-b-[32px] border-b-yellow-500 shadow-md group-hover:scale-110 transition-transform"></div>
                                        <div className="text-left">
                                            <div className="font-bold text-sm">Substrate C</div>
                                            <div className="text-[10px] text-slate-400">Triangular Shape</div>
                                        </div>
                                    </button>
                                </div>
                            </div>

                            {/* Concept Note */}
                            <div className="bg-slate-800/50 p-4 rounded-xl border border-slate-700">
                                <div className="flex items-center gap-2 mb-2 text-indigo-400 font-bold text-xs uppercase">
                                    <Icon name="book-open" size={14} /> Key Concept
                                </div>
                                <p className="text-xs text-slate-300 leading-relaxed">
                                    Enzymes are <strong>specific</strong>. Only a substrate with a complementary shape can fit into the enzyme's <strong>active site</strong> to trigger a reaction.
                                </p>
                            </div>

                        </div>
                    </div>

                    {/* Main Stage */}
                    <div className="flex-1 relative bg-[#020617] flex flex-col">
                        
                        <div className="flex-1 relative overflow-hidden">
                            <EnzymeScene activeSubstrate={substrate} onReactionComplete={handleReactionEnd} />
                            
                            {/* Labels */}
                            <div className="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 pointer-events-none">
                                {/* Enzyme Label (Static approx position) */}
                                <div className="absolute -left-32 -top-20 text-slate-500 text-xs font-bold">ENZYME (Lock)</div>
                                <div className="absolute -left-24 top-0 text-yellow-500 text-[10px] font-bold animate-pulse">ACTIVE SITE</div>
                            </div>
                            
                            <div className="absolute bottom-6 right-6 text-slate-500 text-xs pointer-events-none select-none bg-black/40 backdrop-blur px-4 py-2 rounded-full border border-white/10">
                                3D Simulation View
                            </div>
                        </div>

                        {/* Feedback Panel */}
                        <div className="h-32 bg-slate-900 border-t border-slate-800 p-6 flex items-center justify-center">
                            {feedback ? (
                                <div className={`flex items-center gap-4 p-4 rounded-2xl border animate-in slide-in-from-bottom-4 
                                    ${feedback.type === 'success' ? 'bg-emerald-900/30 border-emerald-500/50 text-emerald-400' : 'bg-red-900/30 border-red-500/50 text-red-400'}
                                `}>
                                    <div className={`p-2 rounded-full ${feedback.type === 'success' ? 'bg-emerald-500 text-white' : 'bg-red-500 text-white'}`}>
                                        <Icon name={feedback.type === 'success' ? 'check' : 'x'} size={24} />
                                    </div>
                                    <div>
                                        <div className="font-bold text-lg">{feedback.type === 'success' ? 'Perfect Match!' : 'Mismatch!'}</div>
                                        <div className="text-sm opacity-80">{feedback.msg}</div>
                                    </div>
                                </div>
                            ) : (
                                <div className="text-slate-500 text-sm flex items-center gap-2">
                                    <Icon name="mouse-pointer-click" size={16}/> Select a substrate to start the experiment
                                </div>
                            )}
                        </div>

                    </div>

                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
